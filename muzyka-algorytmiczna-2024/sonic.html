
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="robots" content="noindex,nofollow,nosnippet,noodp,noarchive,noimageindex">
	<title>Muzyka algorytmiczna</title>
<style>
html { color-scheme: light dark; }
body {
	font-size: 16px;
  font-family: system-ui, sans-serif;
  margin-inline: auto;
  max-width: 80ch;
}
.arg_type {
  opacity: 0.5;
}
.function {
  font-weight: bold;
}
section:not(:last-child) {
  border-bottom: 1px dotted;
}
details[open] {
  border: 1px dotted;
}
</style>
	</head>
  <body>
    <a href="index.html">Muzyka algorytmiczna</a>
    <h1>Dokumentacja funkcji Sonic Pi</h1>

    <!-- TODO: Sonic Pi version number -->
    <p>231 funkcji </p>

    <table>
      
      <tr>
        <th><a href="#all_sample_names">all_sample_names</a></th>
        <td>Get all sample names</td>
      </tr>
      
      <tr>
        <th><a href="#assert">assert</a></th>
        <td>Ensure arg is valid</td>
      </tr>
      
      <tr>
        <th><a href="#assert_equal">assert_equal</a></th>
        <td>Ensure args are equal</td>
      </tr>
      
      <tr>
        <th><a href="#assert_error">assert_error</a></th>
        <td>Ensure block throws an error</td>
      </tr>
      
      <tr>
        <th><a href="#assert_not">assert_not</a></th>
        <td>Ensure arg is not valid</td>
      </tr>
      
      <tr>
        <th><a href="#assert_not_equal">assert_not_equal</a></th>
        <td>Ensure args are not equal</td>
      </tr>
      
      <tr>
        <th><a href="#assert_similar">assert_similar</a></th>
        <td>Ensure args are similar</td>
      </tr>
      
      <tr>
        <th><a href="#at">at</a></th>
        <td>Asynchronous Time. Run a block at the given time(s)</td>
      </tr>
      
      <tr>
        <th><a href="#beat">beat</a></th>
        <td>Get current beat</td>
      </tr>
      
      <tr>
        <th><a href="#block_duration">block_duration</a></th>
        <td>Return block duration</td>
      </tr>
      
      <tr>
        <th><a href="#block_slept?">block_slept?</a></th>
        <td>Determine if block contains sleep time</td>
      </tr>
      
      <tr>
        <th><a href="#bools">bools</a></th>
        <td>Create a ring of boolean values</td>
      </tr>
      
      <tr>
        <th><a href="#bt">bt</a></th>
        <td>Beat time conversion</td>
      </tr>
      
      <tr>
        <th><a href="#buffer">buffer</a></th>
        <td>Initialise or return named buffer</td>
      </tr>
      
      <tr>
        <th><a href="#choose">choose</a></th>
        <td>Random list selection</td>
      </tr>
      
      <tr>
        <th><a href="#chord">chord</a></th>
        <td>Create chord</td>
      </tr>
      
      <tr>
        <th><a href="#chord_degree">chord_degree</a></th>
        <td>Construct chords of stacked thirds, based on scale degrees</td>
      </tr>
      
      <tr>
        <th><a href="#chord_invert">chord_invert</a></th>
        <td>Chord inversion</td>
      </tr>
      
      <tr>
        <th><a href="#chord_names">chord_names</a></th>
        <td>All chord names</td>
      </tr>
      
      <tr>
        <th><a href="#clear">clear</a></th>
        <td>Clear all thread locals to defaults</td>
      </tr>
      
      <tr>
        <th><a href="#comment">comment</a></th>
        <td>Block level commenting</td>
      </tr>
      
      <tr>
        <th><a href="#control">control</a></th>
        <td>Control running synth</td>
      </tr>
      
      <tr>
        <th><a href="#cue">cue</a></th>
        <td>Cue other threads</td>
      </tr>
      
      <tr>
        <th><a href="#current_arg_checks">current_arg_checks</a></th>
        <td>Get current arg checking status</td>
      </tr>
      
      <tr>
        <th><a href="#current_beat_duration">current_beat_duration</a></th>
        <td>Duration of current beat</td>
      </tr>
      
      <tr>
        <th><a href="#current_bpm">current_bpm</a></th>
        <td>Get current tempo</td>
      </tr>
      
      <tr>
        <th><a href="#current_bpm_mode">current_bpm_mode</a></th>
        <td>Get current tempo mode</td>
      </tr>
      
      <tr>
        <th><a href="#current_cent_tuning">current_cent_tuning</a></th>
        <td>Get current cent shift</td>
      </tr>
      
      <tr>
        <th><a href="#current_debug">current_debug</a></th>
        <td>Get current debug status</td>
      </tr>
      
      <tr>
        <th><a href="#current_midi_defaults">current_midi_defaults</a></th>
        <td>Get current MIDI defaults</td>
      </tr>
      
      <tr>
        <th><a href="#current_octave">current_octave</a></th>
        <td>Get current octave shift</td>
      </tr>
      
      <tr>
        <th><a href="#current_random_seed">current_random_seed</a></th>
        <td>Get current random seed</td>
      </tr>
      
      <tr>
        <th><a href="#current_random_source">current_random_source</a></th>
        <td>Get current random source</td>
      </tr>
      
      <tr>
        <th><a href="#current_sample_defaults">current_sample_defaults</a></th>
        <td>Get current sample defaults</td>
      </tr>
      
      <tr>
        <th><a href="#current_sched_ahead_time">current_sched_ahead_time</a></th>
        <td>Get current sched ahead time</td>
      </tr>
      
      <tr>
        <th><a href="#current_synth">current_synth</a></th>
        <td>Get current synth</td>
      </tr>
      
      <tr>
        <th><a href="#current_synth_defaults">current_synth_defaults</a></th>
        <td>Get current synth defaults</td>
      </tr>
      
      <tr>
        <th><a href="#current_time">current_time</a></th>
        <td>Get current (logically quantized) time</td>
      </tr>
      
      <tr>
        <th><a href="#current_transpose">current_transpose</a></th>
        <td>Get current transposition</td>
      </tr>
      
      <tr>
        <th><a href="#current_volume">current_volume</a></th>
        <td>Get current volume</td>
      </tr>
      
      <tr>
        <th><a href="#dec">dec</a></th>
        <td>Decrement</td>
      </tr>
      
      <tr>
        <th><a href="#define">define</a></th>
        <td>Define a new function</td>
      </tr>
      
      <tr>
        <th><a href="#defonce">defonce</a></th>
        <td>Define a named value only once</td>
      </tr>
      
      <tr>
        <th><a href="#degree">degree</a></th>
        <td>Convert a degree into a note</td>
      </tr>
      
      <tr>
        <th><a href="#density">density</a></th>
        <td>Squash and repeat time</td>
      </tr>
      
      <tr>
        <th><a href="#dice">dice</a></th>
        <td>Random dice throw</td>
      </tr>
      
      <tr>
        <th><a href="#doubles">doubles</a></th>
        <td>Create a ring of successive doubles</td>
      </tr>
      
      <tr>
        <th><a href="#eval_file">eval_file</a></th>
        <td>Evaluate the contents of the file inline in the current thread like a function.</td>
      </tr>
      
      <tr>
        <th><a href="#factor?">factor?</a></th>
        <td>Factor test</td>
      </tr>
      
      <tr>
        <th><a href="#fx_names">fx_names</a></th>
        <td>Get all FX names</td>
      </tr>
      
      <tr>
        <th><a href="#get">get</a></th>
        <td>Get information from the Time State</td>
      </tr>
      
      <tr>
        <th><a href="#halves">halves</a></th>
        <td>Create a ring of successive halves</td>
      </tr>
      
      <tr>
        <th><a href="#hz_to_midi">hz_to_midi</a></th>
        <td>Hz to MIDI conversion</td>
      </tr>
      
      <tr>
        <th><a href="#in_thread">in_thread</a></th>
        <td>Run code block at the same time</td>
      </tr>
      
      <tr>
        <th><a href="#inc">inc</a></th>
        <td>Increment</td>
      </tr>
      
      <tr>
        <th><a href="#kill">kill</a></th>
        <td>Kill synth</td>
      </tr>
      
      <tr>
        <th><a href="#knit">knit</a></th>
        <td>Knit a sequence of repeated values</td>
      </tr>
      
      <tr>
        <th><a href="#line">line</a></th>
        <td>Create a ring buffer representing a straight line</td>
      </tr>
      
      <tr>
        <th><a href="#link">link</a></th>
        <td>Use Ableton Link network metronome with automatic phase syncing.</td>
      </tr>
      
      <tr>
        <th><a href="#link_sync">link_sync</a></th>
        <td>Use Ableton Link network metronome with automatic session and phase syncing.</td>
      </tr>
      
      <tr>
        <th><a href="#live_audio">live_audio</a></th>
        <td>A named audio stream live from your soundcard</td>
      </tr>
      
      <tr>
        <th><a href="#live_loop">live_loop</a></th>
        <td>A loop for live coding</td>
      </tr>
      
      <tr>
        <th><a href="#load_buffer">load_buffer</a></th>
        <td>Load the contents of a file to the current buffer</td>
      </tr>
      
      <tr>
        <th><a href="#load_example">load_example</a></th>
        <td>Load a built-in example</td>
      </tr>
      
      <tr>
        <th><a href="#load_sample">load_sample</a></th>
        <td>Pre-load first matching sample</td>
      </tr>
      
      <tr>
        <th><a href="#load_samples">load_samples</a></th>
        <td>Pre-load all matching samples</td>
      </tr>
      
      <tr>
        <th><a href="#load_synthdef">load_synthdef</a></th>
        <td>Load a single external synthdef</td>
      </tr>
      
      <tr>
        <th><a href="#load_synthdefs">load_synthdefs</a></th>
        <td>Load external synthdefs</td>
      </tr>
      
      <tr>
        <th><a href="#look">look</a></th>
        <td>Obtain value of a tick</td>
      </tr>
      
      <tr>
        <th><a href="#loop">loop</a></th>
        <td>Repeat do/end block forever</td>
      </tr>
      
      <tr>
        <th><a href="#map">map</a></th>
        <td>Create an immutable map</td>
      </tr>
      
      <tr>
        <th><a href="#math_scale">math_scale</a></th>
        <td>Linear scaling algorithm</td>
      </tr>
      
      <tr>
        <th><a href="#midi">midi</a></th>
        <td>Trigger and release an external synth via MIDI</td>
      </tr>
      
      <tr>
        <th><a href="#midi_all_notes_off">midi_all_notes_off</a></th>
        <td>Turn off all notes on MIDI devices</td>
      </tr>
      
      <tr>
        <th><a href="#midi_cc">midi_cc</a></th>
        <td>Send MIDI control change message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_channel_pressure">midi_channel_pressure</a></th>
        <td>Send MIDI channel pressure (aftertouch) message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_clock_beat">midi_clock_beat</a></th>
        <td>Send a quarter-note's worth of MIDI clock ticks</td>
      </tr>
      
      <tr>
        <th><a href="#midi_clock_tick">midi_clock_tick</a></th>
        <td>Send an individual MIDI clock tick</td>
      </tr>
      
      <tr>
        <th><a href="#midi_continue">midi_continue</a></th>
        <td>Send MIDI system message - continue</td>
      </tr>
      
      <tr>
        <th><a href="#midi_local_control_off">midi_local_control_off</a></th>
        <td>Disable local control on MIDI devices</td>
      </tr>
      
      <tr>
        <th><a href="#midi_local_control_on">midi_local_control_on</a></th>
        <td>Enable local control on MIDI devices</td>
      </tr>
      
      <tr>
        <th><a href="#midi_mode">midi_mode</a></th>
        <td>Set Omni/Mono/Poly mode</td>
      </tr>
      
      <tr>
        <th><a href="#midi_note_off">midi_note_off</a></th>
        <td>Send MIDI note off message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_note_on">midi_note_on</a></th>
        <td>Send MIDI note on message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_notes">midi_notes</a></th>
        <td>Create a ring buffer of midi note numbers</td>
      </tr>
      
      <tr>
        <th><a href="#midi_pc">midi_pc</a></th>
        <td>Send MIDI program change message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_pitch_bend">midi_pitch_bend</a></th>
        <td>Send MIDI pitch bend message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_poly_pressure">midi_poly_pressure</a></th>
        <td>Send a MIDI polyphonic key pressure message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_raw">midi_raw</a></th>
        <td>Send raw MIDI message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_reset">midi_reset</a></th>
        <td>Reset MIDI devices</td>
      </tr>
      
      <tr>
        <th><a href="#midi_sound_off">midi_sound_off</a></th>
        <td>Silence all MIDI devices</td>
      </tr>
      
      <tr>
        <th><a href="#midi_start">midi_start</a></th>
        <td>Send MIDI system message - start</td>
      </tr>
      
      <tr>
        <th><a href="#midi_stop">midi_stop</a></th>
        <td>Send MIDI system message - stop</td>
      </tr>
      
      <tr>
        <th><a href="#midi_sysex">midi_sysex</a></th>
        <td>Send MIDI System Exclusive (SysEx) message</td>
      </tr>
      
      <tr>
        <th><a href="#midi_to_hz">midi_to_hz</a></th>
        <td>MIDI to Hz conversion</td>
      </tr>
      
      <tr>
        <th><a href="#ndefine">ndefine</a></th>
        <td>Define a new function</td>
      </tr>
      
      <tr>
        <th><a href="#note">note</a></th>
        <td>Describe note</td>
      </tr>
      
      <tr>
        <th><a href="#note_info">note_info</a></th>
        <td>Get note info</td>
      </tr>
      
      <tr>
        <th><a href="#note_range">note_range</a></th>
        <td>Get a range of notes</td>
      </tr>
      
      <tr>
        <th><a href="#octs">octs</a></th>
        <td>Create a ring of octaves</td>
      </tr>
      
      <tr>
        <th><a href="#on">on</a></th>
        <td>Optionally evaluate block</td>
      </tr>
      
      <tr>
        <th><a href="#one_in">one_in</a></th>
        <td>Random true value with specified probability</td>
      </tr>
      
      <tr>
        <th><a href="#osc">osc</a></th>
        <td>Send an OSC message (Open Sound Control)</td>
      </tr>
      
      <tr>
        <th><a href="#osc_send">osc_send</a></th>
        <td>Send an OSC message to a specific host and port</td>
      </tr>
      
      <tr>
        <th><a href="#pick">pick</a></th>
        <td>Randomly pick from list (with duplicates)</td>
      </tr>
      
      <tr>
        <th><a href="#pitch_to_ratio">pitch_to_ratio</a></th>
        <td>relative MIDI pitch to frequency ratio</td>
      </tr>
      
      <tr>
        <th><a href="#play">play</a></th>
        <td>Play current synth</td>
      </tr>
      
      <tr>
        <th><a href="#play_chord">play_chord</a></th>
        <td>Play notes simultaneously</td>
      </tr>
      
      <tr>
        <th><a href="#play_pattern">play_pattern</a></th>
        <td>Play pattern of notes</td>
      </tr>
      
      <tr>
        <th><a href="#play_pattern_timed">play_pattern_timed</a></th>
        <td>Play pattern of notes with specific times</td>
      </tr>
      
      <tr>
        <th><a href="#print">print</a></th>
        <td>Display a message in the output pane</td>
      </tr>
      
      <tr>
        <th><a href="#puts">puts</a></th>
        <td>Display a message in the output pane</td>
      </tr>
      
      <tr>
        <th><a href="#quantise">quantise</a></th>
        <td>Quantise a value to resolution</td>
      </tr>
      
      <tr>
        <th><a href="#ramp">ramp</a></th>
        <td>Create a ramp vector</td>
      </tr>
      
      <tr>
        <th><a href="#rand">rand</a></th>
        <td>Generate a random float below a value</td>
      </tr>
      
      <tr>
        <th><a href="#rand_back">rand_back</a></th>
        <td>Roll back random generator</td>
      </tr>
      
      <tr>
        <th><a href="#rand_i">rand_i</a></th>
        <td>Generate a random whole number below a value (exclusive)</td>
      </tr>
      
      <tr>
        <th><a href="#rand_i_look">rand_i_look</a></th>
        <td>Generate a random whole number without consuming a rand</td>
      </tr>
      
      <tr>
        <th><a href="#rand_look">rand_look</a></th>
        <td>Generate a random number without consuming a rand</td>
      </tr>
      
      <tr>
        <th><a href="#rand_reset">rand_reset</a></th>
        <td>Reset rand generator to last seed</td>
      </tr>
      
      <tr>
        <th><a href="#rand_skip">rand_skip</a></th>
        <td>Jump forward random generator</td>
      </tr>
      
      <tr>
        <th><a href="#range">range</a></th>
        <td>Create a ring buffer with the specified start, finish and step size</td>
      </tr>
      
      <tr>
        <th><a href="#ratio_to_pitch">ratio_to_pitch</a></th>
        <td>relative frequency ratio to MIDI pitch</td>
      </tr>
      
      <tr>
        <th><a href="#rdist">rdist</a></th>
        <td>Random number in centred distribution</td>
      </tr>
      
      <tr>
        <th><a href="#reset">reset</a></th>
        <td>Reset all thread locals</td>
      </tr>
      
      <tr>
        <th><a href="#reset_mixer!">reset_mixer!</a></th>
        <td>Reset main mixer</td>
      </tr>
      
      <tr>
        <th><a href="#rest?">rest?</a></th>
        <td>Determine if note or args is a rest</td>
      </tr>
      
      <tr>
        <th><a href="#ring">ring</a></th>
        <td>Create a ring buffer</td>
      </tr>
      
      <tr>
        <th><a href="#rrand">rrand</a></th>
        <td>Generate a random float between two numbers</td>
      </tr>
      
      <tr>
        <th><a href="#rrand_i">rrand_i</a></th>
        <td>Generate a random whole number between two points inclusively</td>
      </tr>
      
      <tr>
        <th><a href="#rt">rt</a></th>
        <td>Real time conversion</td>
      </tr>
      
      <tr>
        <th><a href="#run_code">run_code</a></th>
        <td>Evaluate the code passed as a String as a new Run</td>
      </tr>
      
      <tr>
        <th><a href="#run_file">run_file</a></th>
        <td>Evaluate the contents of the file as a new Run</td>
      </tr>
      
      <tr>
        <th><a href="#sample">sample</a></th>
        <td>Trigger sample</td>
      </tr>
      
      <tr>
        <th><a href="#sample_buffer">sample_buffer</a></th>
        <td>Get sample data</td>
      </tr>
      
      <tr>
        <th><a href="#sample_duration">sample_duration</a></th>
        <td>Get duration of sample in beats</td>
      </tr>
      
      <tr>
        <th><a href="#sample_free">sample_free</a></th>
        <td>Free a sample on the synth server</td>
      </tr>
      
      <tr>
        <th><a href="#sample_free_all">sample_free_all</a></th>
        <td>Free all loaded samples on the synth server</td>
      </tr>
      
      <tr>
        <th><a href="#sample_groups">sample_groups</a></th>
        <td>Get all sample groups</td>
      </tr>
      
      <tr>
        <th><a href="#sample_info">sample_info</a></th>
        <td>Get sample information</td>
      </tr>
      
      <tr>
        <th><a href="#sample_loaded?">sample_loaded?</a></th>
        <td>Test if sample was pre-loaded</td>
      </tr>
      
      <tr>
        <th><a href="#sample_names">sample_names</a></th>
        <td>Get sample names</td>
      </tr>
      
      <tr>
        <th><a href="#sample_paths">sample_paths</a></th>
        <td>Sample Pack Filter Resolution</td>
      </tr>
      
      <tr>
        <th><a href="#scale">scale</a></th>
        <td>Create scale</td>
      </tr>
      
      <tr>
        <th><a href="#scale_names">scale_names</a></th>
        <td>All scale names</td>
      </tr>
      
      <tr>
        <th><a href="#scsynth_info">scsynth_info</a></th>
        <td>Return information about the internal SuperCollider sound server</td>
      </tr>
      
      <tr>
        <th><a href="#set">set</a></th>
        <td>Store information in the Time State</td>
      </tr>
      
      <tr>
        <th><a href="#set_audio_latency!">set_audio_latency!</a></th>
        <td>Globally modify audio latency</td>
      </tr>
      
      <tr>
        <th><a href="#set_cent_tuning!">set_cent_tuning!</a></th>
        <td>Global Cent tuning</td>
      </tr>
      
      <tr>
        <th><a href="#set_control_delta!">set_control_delta!</a></th>
        <td>Set control delta globally</td>
      </tr>
      
      <tr>
        <th><a href="#set_link_bpm!">set_link_bpm!</a></th>
        <td>Set the tempo for the link metronome.</td>
      </tr>
      
      <tr>
        <th><a href="#set_mixer_control!">set_mixer_control!</a></th>
        <td>Control main mixer</td>
      </tr>
      
      <tr>
        <th><a href="#set_recording_bit_depth!">set_recording_bit_depth!</a></th>
        <td>Set the bit depth for recording wav files</td>
      </tr>
      
      <tr>
        <th><a href="#set_sched_ahead_time!">set_sched_ahead_time!</a></th>
        <td>Set sched ahead time globally</td>
      </tr>
      
      <tr>
        <th><a href="#set_volume!">set_volume!</a></th>
        <td>Set Volume globally</td>
      </tr>
      
      <tr>
        <th><a href="#shuffle">shuffle</a></th>
        <td>Randomise order of a list</td>
      </tr>
      
      <tr>
        <th><a href="#sleep">sleep</a></th>
        <td>Wait for beat duration</td>
      </tr>
      
      <tr>
        <th><a href="#spark">spark</a></th>
        <td>Print a string representing a list of numeric values as a spark graph/bar chart</td>
      </tr>
      
      <tr>
        <th><a href="#spark_graph">spark_graph</a></th>
        <td>Returns a string representing a list of numeric values as a spark graph/bar chart</td>
      </tr>
      
      <tr>
        <th><a href="#spread">spread</a></th>
        <td>Euclidean distribution for beats</td>
      </tr>
      
      <tr>
        <th><a href="#status">status</a></th>
        <td>Get server status</td>
      </tr>
      
      <tr>
        <th><a href="#stop">stop</a></th>
        <td>Stop current thread or run</td>
      </tr>
      
      <tr>
        <th><a href="#stretch">stretch</a></th>
        <td>Stretch a sequence of values</td>
      </tr>
      
      <tr>
        <th><a href="#sync">sync</a></th>
        <td>Sync with other threads</td>
      </tr>
      
      <tr>
        <th><a href="#sync_bpm">sync_bpm</a></th>
        <td>Sync and inherit BPM from other threads </td>
      </tr>
      
      <tr>
        <th><a href="#synth">synth</a></th>
        <td>Trigger specific synth</td>
      </tr>
      
      <tr>
        <th><a href="#synth_names">synth_names</a></th>
        <td>Get all synth names</td>
      </tr>
      
      <tr>
        <th><a href="#tick">tick</a></th>
        <td>Increment a tick and return value</td>
      </tr>
      
      <tr>
        <th><a href="#tick_reset">tick_reset</a></th>
        <td>Reset tick to 0</td>
      </tr>
      
      <tr>
        <th><a href="#tick_reset_all">tick_reset_all</a></th>
        <td>Reset all ticks</td>
      </tr>
      
      <tr>
        <th><a href="#tick_set">tick_set</a></th>
        <td>Set tick to a specific value</td>
      </tr>
      
      <tr>
        <th><a href="#time_warp">time_warp</a></th>
        <td>Shift time forwards or backwards for the given block</td>
      </tr>
      
      <tr>
        <th><a href="#uncomment">uncomment</a></th>
        <td>Block level comment ignoring</td>
      </tr>
      
      <tr>
        <th><a href="#use_arg_bpm_scaling">use_arg_bpm_scaling</a></th>
        <td>Enable and disable BPM scaling</td>
      </tr>
      
      <tr>
        <th><a href="#use_arg_checks">use_arg_checks</a></th>
        <td>Enable and disable arg checks</td>
      </tr>
      
      <tr>
        <th><a href="#use_bpm">use_bpm</a></th>
        <td>Set the tempo</td>
      </tr>
      
      <tr>
        <th><a href="#use_bpm_mul">use_bpm_mul</a></th>
        <td>Set new tempo as a multiple of current tempo</td>
      </tr>
      
      <tr>
        <th><a href="#use_cent_tuning">use_cent_tuning</a></th>
        <td>Cent tuning</td>
      </tr>
      
      <tr>
        <th><a href="#use_cue_logging">use_cue_logging</a></th>
        <td>Enable and disable cue logging</td>
      </tr>
      
      <tr>
        <th><a href="#use_debug">use_debug</a></th>
        <td>Enable and disable debug</td>
      </tr>
      
      <tr>
        <th><a href="#use_merged_midi_defaults">use_merged_midi_defaults</a></th>
        <td>Merge MIDI defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_merged_sample_defaults">use_merged_sample_defaults</a></th>
        <td>Merge new sample defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_merged_synth_defaults">use_merged_synth_defaults</a></th>
        <td>Merge synth defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_midi_defaults">use_midi_defaults</a></th>
        <td>Use new MIDI defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_midi_logging">use_midi_logging</a></th>
        <td>Enable and disable MIDI logging</td>
      </tr>
      
      <tr>
        <th><a href="#use_octave">use_octave</a></th>
        <td>Note octave transposition</td>
      </tr>
      
      <tr>
        <th><a href="#use_osc">use_osc</a></th>
        <td>Set the default hostname and port number for outgoing OSC messages.</td>
      </tr>
      
      <tr>
        <th><a href="#use_osc_logging">use_osc_logging</a></th>
        <td>Enable and disable OSC logging</td>
      </tr>
      
      <tr>
        <th><a href="#use_random_seed">use_random_seed</a></th>
        <td>Set random seed generator to known seed</td>
      </tr>
      
      <tr>
        <th><a href="#use_random_source">use_random_source</a></th>
        <td>Change how random numbers are chosen</td>
      </tr>
      
      <tr>
        <th><a href="#use_real_time">use_real_time</a></th>
        <td>Set sched ahead time to 0 for the current thread</td>
      </tr>
      
      <tr>
        <th><a href="#use_sample_bpm">use_sample_bpm</a></th>
        <td>Sample-duration-based bpm modification</td>
      </tr>
      
      <tr>
        <th><a href="#use_sample_defaults">use_sample_defaults</a></th>
        <td>Use new sample defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_sched_ahead_time">use_sched_ahead_time</a></th>
        <td>Set sched ahead time for the current thread</td>
      </tr>
      
      <tr>
        <th><a href="#use_synth">use_synth</a></th>
        <td>Switch current synth</td>
      </tr>
      
      <tr>
        <th><a href="#use_synth_defaults">use_synth_defaults</a></th>
        <td>Use new synth defaults</td>
      </tr>
      
      <tr>
        <th><a href="#use_timing_guarantees">use_timing_guarantees</a></th>
        <td>Inhibit synth triggers if too late</td>
      </tr>
      
      <tr>
        <th><a href="#use_transpose">use_transpose</a></th>
        <td>Note transposition</td>
      </tr>
      
      <tr>
        <th><a href="#use_tuning">use_tuning</a></th>
        <td>Use alternative tuning systems</td>
      </tr>
      
      <tr>
        <th><a href="#vector">vector</a></th>
        <td>Create a vector</td>
      </tr>
      
      <tr>
        <th><a href="#version">version</a></th>
        <td>Get current version information</td>
      </tr>
      
      <tr>
        <th><a href="#vt">vt</a></th>
        <td>Get virtual time</td>
      </tr>
      
      <tr>
        <th><a href="#wait">wait</a></th>
        <td>Wait for duration</td>
      </tr>
      
      <tr>
        <th><a href="#with_arg_bpm_scaling">with_arg_bpm_scaling</a></th>
        <td>Block-level enable and disable BPM scaling</td>
      </tr>
      
      <tr>
        <th><a href="#with_arg_checks">with_arg_checks</a></th>
        <td>Block-level enable and disable arg checks</td>
      </tr>
      
      <tr>
        <th><a href="#with_bpm">with_bpm</a></th>
        <td>Set the tempo for the code block</td>
      </tr>
      
      <tr>
        <th><a href="#with_bpm_mul">with_bpm_mul</a></th>
        <td>Set new tempo as a multiple of current tempo for block</td>
      </tr>
      
      <tr>
        <th><a href="#with_cent_tuning">with_cent_tuning</a></th>
        <td>Block-level cent tuning</td>
      </tr>
      
      <tr>
        <th><a href="#with_cue_logging">with_cue_logging</a></th>
        <td>Block-level enable and disable cue logging</td>
      </tr>
      
      <tr>
        <th><a href="#with_debug">with_debug</a></th>
        <td>Block-level enable and disable debug</td>
      </tr>
      
      <tr>
        <th><a href="#with_fx">with_fx</a></th>
        <td>Use Studio FX</td>
      </tr>
      
      <tr>
        <th><a href="#with_merged_midi_defaults">with_merged_midi_defaults</a></th>
        <td>Block-level merge midi defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_merged_sample_defaults">with_merged_sample_defaults</a></th>
        <td>Block-level use merged sample defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_merged_synth_defaults">with_merged_synth_defaults</a></th>
        <td>Block-level merge synth defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_midi_defaults">with_midi_defaults</a></th>
        <td>Block-level use new MIDI defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_midi_logging">with_midi_logging</a></th>
        <td>Block-level enable and disable MIDI logging</td>
      </tr>
      
      <tr>
        <th><a href="#with_octave">with_octave</a></th>
        <td>Block level octave transposition</td>
      </tr>
      
      <tr>
        <th><a href="#with_osc">with_osc</a></th>
        <td>Block-level setting for the default hostname and port number of outgoing OSC messages.</td>
      </tr>
      
      <tr>
        <th><a href="#with_osc_logging">with_osc_logging</a></th>
        <td>Block-level enable and disable OSC logging</td>
      </tr>
      
      <tr>
        <th><a href="#with_random_seed">with_random_seed</a></th>
        <td>Specify random seed for code block</td>
      </tr>
      
      <tr>
        <th><a href="#with_random_source">with_random_source</a></th>
        <td>Specify random distribution for code block</td>
      </tr>
      
      <tr>
        <th><a href="#with_real_time">with_real_time</a></th>
        <td>Sets sched ahead time to 0 within the block for the current thread</td>
      </tr>
      
      <tr>
        <th><a href="#with_sample_bpm">with_sample_bpm</a></th>
        <td>Block-scoped sample-duration-based bpm modification</td>
      </tr>
      
      <tr>
        <th><a href="#with_sample_defaults">with_sample_defaults</a></th>
        <td>Block-level use new sample defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_sched_ahead_time">with_sched_ahead_time</a></th>
        <td>Block-level set sched ahead time for the current thread</td>
      </tr>
      
      <tr>
        <th><a href="#with_swing">with_swing</a></th>
        <td>Add swing to successive calls to do/end block</td>
      </tr>
      
      <tr>
        <th><a href="#with_synth">with_synth</a></th>
        <td>Block-level synth switching</td>
      </tr>
      
      <tr>
        <th><a href="#with_synth_defaults">with_synth_defaults</a></th>
        <td>Block-level use new synth defaults</td>
      </tr>
      
      <tr>
        <th><a href="#with_timing_guarantees">with_timing_guarantees</a></th>
        <td>Block-scoped inhibition of synth triggers if too late</td>
      </tr>
      
      <tr>
        <th><a href="#with_transpose">with_transpose</a></th>
        <td>Block-level note transposition</td>
      </tr>
      
      <tr>
        <th><a href="#with_tuning">with_tuning</a></th>
        <td>Block-level tuning modification</td>
      </tr>
      
    </table>

    
      <section>
        <h2 id="all_sample_names">Get all sample names</h2>
        <code><span class="function">all_sample_names</span> </code>
        <p>Return a list of all the sample names available</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="assert">Ensure arg is valid</h2>
        <code><span class="function">assert</span> arg <span class="arg_type">(anything)</span></code>
        <p>Raises an exception if the argument is either nil or false.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple assertions
assert true   # As true is neither nil or false, this assertion passes
assert 1      # Similarly, 1 passes
assert "foo" # As do string
assert false  # This will raise an exception</code></pre>
          
            <pre><code>
# Communicating error messages
assert false, "oops" # This will raise an exception containing the message "oops"</code></pre>
          
            <pre><code>
# More interesting assertions
assert (1 + 1) == 2 # Ensure that arithmetic is sane!
assert [:a, :b, :c].size == 3 # ensure lists can be correctly counted</code></pre>
          
          </details>
        
        <p>Introduced in 2.8.0</p>
      </section>
    
      <section>
        <h2 id="assert_equal">Ensure args are equal</h2>
        <code><span class="function">assert_equal</span> arg1 <span class="arg_type">(anything)</span>, arg2 <span class="arg_type">(anything)</span></code>
        <p>Raises an exception if both arguments aren&#8217;t equal. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple assertions
assert_equal 1, 1</code></pre>
          
            <pre><code>
# More interesting assertions
assert_equal 1 + 1, 2 # Ensure that arithmetic is sane!
assert_equal [:a, :b, :c].size,  3 # ensure lists can be correctly counted</code></pre>
          
            <pre><code>
# Add messages to the exceptions
assert_equal 3, 5, "something is seriously wrong!"</code></pre>
          
          </details>
        
        <p>Introduced in 2.8.0</p>
      </section>
    
      <section>
        <h2 id="assert_error">Ensure block throws an error</h2>
        <code><span class="function">assert_error</span> class <span class="arg_type">(Exception)</span></code>
        <p>Runs the block and ensures that it raises the correct Exception. Useful for asserting that an Exception will be raised. You may specify the particular Exception class, which defaults to <code>Exception</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
assert_error do
  play 70
end                         # Will throw an exception: "Assert error failed!" as the block
                            # contains no errors.</code></pre>
          
            <pre><code>
assert_error do
  1 / 0
end                         # Will not throw an exception as the block contains an error.</code></pre>
          
            <pre><code>
assert_error ZeroDivisionError do
  1 / 0
end                         # Will not throw an exception as the block contains a ZeroDivisionError.</code></pre>
          
            <pre><code>
assert_error ThreadError do
  1 / 0
end                         # Will throw an exception as the block contains a ZeroDivisionError rather than
                            # a ThreadError.</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="assert_not">Ensure arg is not valid</h2>
        <code><span class="function">assert_not</span> arg <span class="arg_type">(anything)</span></code>
        <p>Raises an exception if the argument is not either nil or false.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple assertions
assert_not false   # As false is either nil or false, this assertion passes
assert_not nil     # As nil is either nil or false, this assertion passes
assert_not 1 == 5  # These numbers are not equal
assert true  # This will raise an exception</code></pre>
          
            <pre><code>
# Communicating error messages
assert_not true , "oops" # This will raise an exception containing the message "oops"</code></pre>
          
          </details>
        
        <p>Introduced in 3.3.0</p>
      </section>
    
      <section>
        <h2 id="assert_not_equal">Ensure args are not equal</h2>
        <code><span class="function">assert_not_equal</span> arg1 <span class="arg_type">(anything)</span>, arg2 <span class="arg_type">(anything)</span></code>
        <p>Raises an exception if both arguments are qual. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple assertions
assert_not_equal 1, 3
assert_not_equal 1, -1
assert_not_equal 1, :foo</code></pre>
          
            <pre><code>
# Add messages to the exceptions
assert_not_equal 3, 3, "something is seriously wrong!"</code></pre>
          
          </details>
        
        <p>Introduced in 3.3.0</p>
      </section>
    
      <section>
        <h2 id="assert_similar">Ensure args are similar</h2>
        <code><span class="function">assert_similar</span> arg1 <span class="arg_type">(anything)</span>, arg2 <span class="arg_type">(anything)</span></code>
        <p>Raises an exception if both arguments aren&#8217;t similar.</p>
<p>Currently similarity is only defined for numbers - all other types are compared for equality with assert_equal.</p>
<p>Useful for testing in cases where floating point imprecision stops you from being able to use <code>assert_equal</code>. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple assertions
assert_similar 1, 1 #=> True</code></pre>
          
            <pre><code>
# Handles floating point imprecision
assert_similar(4.9999999999, 5.0) #=> True</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="at">Asynchronous Time. Run a block at the given time(s)</h2>
        <code><span class="function">at</span> times <span class="arg_type">(list)</span>, params <span class="arg_type">(list)</span></code>
        <p>Given a list of times, run the block once after waiting each given time. If passed an optional params list, will pass each param individually to each block call. If size of params list is smaller than the times list, the param values will act as rings (rotate through). If the block is given 1 arg, the times are fed through. If the block is given 2 args, both the times and the params are fed through. A third block arg will receive the index of the time.</p>
<p>Note, all code within the block is executed in its own thread. Therefore despite inheriting all thread locals such as the random stream and ticks, modifications will be isolated to the block and will not affect external code.</p>
<p><code>at</code> is just-in-time scheduling using multiple isolated threads. See <code>time_warp</code> for ahead-of-time scheduling within the current thread.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  at 4 do
    sample :ambi_choir    # play sample after waiting for 4 beats
  end
  </code></pre>
          
            <pre><code>
  at [1, 2, 4] do  # plays a note after waiting 1 beat,
    play 75           # then after 1 more beat,
  end                 # then after 2 more beats (4 beats total)
  </code></pre>
          
            <pre><code>
  at [1, 2, 3], [75, 76, 77] do |n|  # plays 3 different notes
    play n
  end
  </code></pre>
          
            <pre><code>
  at [1, 2, 3],
      [{:amp=>0.5}, {:amp=> 0.8}] do |p| # alternate soft and loud
    sample :drum_cymbal_open, p          # cymbal hits three times
  end
  </code></pre>
          
            <pre><code>
  at [0, 1, 2] do |t| # when no params are given to at, the times are fed through to the block
    puts t #=> prints 0, 1, then 2
  end
  </code></pre>
          
            <pre><code>
  at [0, 1, 2], [:a, :b] do |t, b|  #If you specify the block with 2 args, it will pass through both the time and the param
    puts [t, b] #=> prints out [0, :a], [1, :b], then [2, :a]
  end
  </code></pre>
          
            <pre><code>
  at [0, 0.5, 2] do |t, idx|  #If you specify the block with 2 args, and no param list to at, it will pass through both the time and the index
    puts [t, idx] #=> prints out [0, 0], [0.5, 1], then [2, 2]
  end
  </code></pre>
          
            <pre><code>
  at [0, 0.5, 2], [:a, :b] do |t, b, idx|  #If you specify the block with 3 args, it will pass through the time, the param and the index
    puts [t, b, idx] #=> prints out [0, :a, 0], [0.5, :b, 1], then [2, :a, 2]
  end
  </code></pre>
          
            <pre><code> # at does not consume & interfere with the outer random stream
puts "main: ", rand  # 0.75006103515625
rand_back
at 1 do         # the random stream inside the at block is separate and
                # isolated from the outer stream.
  puts "at:", rand # 0.9287109375
  puts "at:", rand # 0.1043701171875
end

sleep 2
puts "main: ", rand # value is still 0.75006103515625</code></pre>
          
            <pre><code>
            # Each block run within at has its own isolated random stream:
at [1, 2] do
            # first time round (after 1 beat) prints:
  puts rand # 0.9287109375
  puts rand # 0.1043701171875
end
            # second time round (after 2 beats) prints:
            # 0.1043701171875
            # 0.764617919921875</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="beat">Get current beat</h2>
        <code><span class="function">beat</span> </code>
        <p>Returns the beat value for the current thread&#47;live_loop. Beats are advanced only by calls to <code>sleep</code> and <code>sync</code>. Beats are distinct from virtual time (the value obtained by calling <code>vt</code>) in that it has no notion of rate. It is just essentially a counter for sleeps. After a <code>sync</code>, the beat is overridden with the beat value from the thread which called <code>cue</code>. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_bpm 120  #=> The initial beat does not start at 0
puts beat    #=> 109252.703125
sleep 1
puts beat    #=> 109253.703125
use_bpm 2000 # Changing the BPM makes no difference
sleep 2
puts beat    #=> 109255.703125</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="block_duration">Return block duration</h2>
        <code><span class="function">block_duration</span> </code>
        <p>Given a block, runs it and returns the amount of time that has passed. This time is in seconds and is not scaled to the current BPM. Any threads spawned in the block are not accounted for.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
dur = block_duration do
  play 50
  sleep 1
  play 62
  sleep 2
end

puts dur #=> Returns 3 as 3 seconds have passed within the block</code></pre>
          
            <pre><code>use_bpm 120
dur = block_duration do
  play 50
  sleep 1
  play 62
  sleep 2
end

puts dur #=> Returns 1.5 as 1.5 seconds have passed within the block
         #   (due to the BPM being 120)</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="block_slept?">Determine if block contains sleep time</h2>
        <code><span class="function">block_slept?</span> </code>
        <p>Given a block, runs it and returns whether or not the block contained sleeps or syncs</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
slept = block_slept? do
  play 50
  sleep 1
  play 62
  sleep 2
end

puts slept #=> Returns true as there were sleeps in the block</code></pre>
          
            <pre><code>
in_thread do
  sleep 1
  cue :foo  # trigger a cue on a different thread
end

slept = block_slept? do
  sync :foo  # wait for the cue before playing the note
  play 62
end

puts slept #=> Returns true as the block contained a sync.</code></pre>
          
            <pre><code>
slept = block_slept? do
  play 50
  play 62
end

puts slept #=> Returns false as there were no sleeps in the block</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="bools">Create a ring of boolean values</h2>
        <code><span class="function">bools</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new ring of booleans values from 1s and 0s, which can be easier to write and manipulate in a live setting.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(bools 1, 0)    #=> (ring true, false)</code></pre>
          
            <pre><code>(bools 1, 0, true, false, nil) #=> (ring true, false, true, false, false)</code></pre>
          
          </details>
        
        <p>Introduced in 2.2.0</p>
      </section>
    
      <section>
        <h2 id="bt">Beat time conversion</h2>
        <code><span class="function">bt</span> seconds <span class="arg_type">(number)</span></code>
        <p>Beat time representation. Scales the time to the current BPM. Useful for adding bpm scaling</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 120  # Set the BPM to be double the default
  puts bt(1) # 0.5
  use_bpm 60   # BPM is now default
  puts bt(1) # 1
  use_bpm 30   # BPM is now half the default
  puts bt(1) # 2</code></pre>
          
          </details>
        
        <p>Introduced in 2.8.0</p>
      </section>
    
      <section>
        <h2 id="buffer">Initialise or return named buffer</h2>
        <code><span class="function">buffer</span> symbol <span class="arg_type">(name)</span>, number <span class="arg_type">(duration)</span></code>
        <p>Initialise or return a named buffer with a specific duration (defaults to 8 beats). Useful for working with the <code>:record</code> FX. If the buffer is requested with a different duration, then a new buffer will be initialised and the old one recycled.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
buffer(:foo) # load a 8s buffer and name it :foo
b = buffer(:foo) # return cached buffer and bind it to b
puts b.duration  #=> 8.0</code></pre>
          
            <pre><code>
buffer(:foo, 16) # load a 16s buffer and name it :foo</code></pre>
          
            <pre><code>
use_bpm 120
buffer(:foo, 16) # load a 8s buffer and name it :foo
                 # (this isn't 16s as the BPM has been
                 # doubled from the default of 60)</code></pre>
          
            <pre><code>
buffer(:foo)     # init a 8s buffer and name it :foo
buffer(:foo, 8)  # return cached 8s buffer (has the same duration)
buffer(:foo, 10) # init a new 10s buffer and name it :foo
buffer(:foo, 10) # return cached 10s buffer
buffer(:foo)     # init a 8s buffer and name it :foo
buffer(:foo)     # return cached 8s buffer (has the same duration)</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="choose">Random list selection</h2>
        <code><span class="function">choose</span> list <span class="arg_type">(array)</span></code>
        <p>Choose an element at random from a list (array).</p>
<p>If no arguments are given, will return a lambda function which when called takes an argument which will be a list to be chosen from. This is useful for choosing random <code>onset:</code> vals for samples</p>
<p>Always returns a single element (or nil)</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  loop do
    play choose([60, 64, 67]) #=> plays one of 60, 64 or 67 at random
    sleep 1
    play chord(:c, :major).choose #=> You can also call .choose on the list
    sleep 1
  end</code></pre>
          
            <pre><code>
# Using choose for random sample onsets
live_loop :foo do
  sample :loop_amen, onset: choose   # choose a random onset value each time
  sleep 0.125
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="chord">Create chord</h2>
        <code><span class="function">chord</span> tonic <span class="arg_type">(symbol)</span>, name <span class="arg_type">(symbol)</span></code>
        <p>Creates an immutable ring of Midi note numbers when given a tonic note and a chord type. If only passed a chord type, will default the tonic to 0. See examples.</p>

        
          <table>
          
            <tr>
              <th><code>invert</code></th>
              <td>Apply the specified num inversions to chord. See the fn `chord_invert`.</td>
            </tr>
          
            <tr>
              <th><code>num_octaves</code></th>
              <td>Create an arpeggio of the chord over n octaves</td>
            </tr>
          
            <caption>Options for chord</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts (chord :e, :minor) # returns a ring of midi notes - (ring 64, 67, 71)</code></pre>
          
            <pre><code># Play all the notes together
play (chord :e, :minor)</code></pre>
          
            <pre><code>
# Chord inversions (see the fn chord_invert)
play (chord :e3, :minor, invert: 0) # Play the basic :e3, :minor chord - (ring 52, 55, 59)
play (chord :e3, :minor, invert: 1) # Play the first inversion of :e3, :minor - (ring 55, 59, 64)
play (chord :e3, :minor, invert: 2) # Play the first inversion of :e3, :minor - (ring 59, 64, 67)</code></pre>
          
            <pre><code># You can create a chord without a tonic:
puts (chord :minor) #=> (ring 0, 3, 7)</code></pre>
          
            <pre><code># chords are great for arpeggiators
live_loop :arp do
  play chord(:e, :minor, num_octaves: 2).tick, release: 0.1
  sleep 0.125
end</code></pre>
          
            <pre><code># Sonic Pi supports a large range of chords
 # Notice that the more exotic ones have to be surrounded by ' quotes
(chord :C, '1')
(chord :C, '5')
(chord :C, '+5')
(chord :C, 'm+5')
(chord :C, :sus2)
(chord :C, :sus4)
(chord :C, '6')
(chord :C, :m6)
(chord :C, '7sus2')
(chord :C, '7sus4')
(chord :C, '7-5')
(chord :C, 'm7-5')
(chord :C, '7+5')
(chord :C, 'm7+5')
(chord :C, '9')
(chord :C, :m9)
(chord :C, 'm7+9')
(chord :C, :maj9)
(chord :C, '9sus4')
(chord :C, '6*9')
(chord :C, 'm6*9')
(chord :C, '7-9')
(chord :C, 'm7-9')
(chord :C, '7-10')
(chord :C, '9+5')
(chord :C, 'm9+5')
(chord :C, '7+5-9')
(chord :C, 'm7+5-9')
(chord :C, '11')
(chord :C, :m11)
(chord :C, :maj11)
(chord :C, '11+')
(chord :C, 'm11+')
(chord :C, '13')
(chord :C, :m13)
(chord :C, :add2)
(chord :C, :add4)
(chord :C, :add9)
(chord :C, :add11)
(chord :C, :add13)
(chord :C, :madd2)
(chord :C, :madd4)
(chord :C, :madd9)
(chord :C, :madd11)
(chord :C, :madd13)
(chord :C, :major)
(chord :C, :M)
(chord :C, :minor)
(chord :C, :m)
(chord :C, :major7)
(chord :C, :dom7)
(chord :C, '7')
(chord :C, :M7)
(chord :C, :minor7)
(chord :C, :m7)
(chord :C, :augmented)
(chord :C, :a)
(chord :C, :diminished)
(chord :C, :dim)
(chord :C, :i)
(chord :C, :diminished7)
(chord :C, :dim7)
(chord :C, :i7)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="chord_degree">Construct chords of stacked thirds, based on scale degrees</h2>
        <code><span class="function">chord_degree</span> degree <span class="arg_type">(symbol_or_number)</span>, tonic <span class="arg_type">(symbol)</span>, scale <span class="arg_type">(symbol)</span>, number_of_notes <span class="arg_type">(number)</span></code>
        <p>In music we build chords from scales. For example, a C major chord is made by taking the 1st, 3rd and 5th notes of the C major scale (C, E and G). If you do this on a piano you might notice that you play one, skip one, play one, skip one etc. If we use the same spacing and start from the second note in C major (which is a D), we get a D minor chord which is the 2nd, 4th and 6th notes in C major (D, F and A). We can move this pattern all the way up or down the scale to get different types of chords. <code>chord_degree</code> is a helper method that returns a ring of midi note numbers when given a degree (starting point in a scale) which is a symbol <code>:i</code>, <code>:ii</code>, <code>:iii</code>, <code>:iv</code>, <code>:v</code>, <code>:vi</code>, <code>:vii</code> or a number <code>1</code>-<code>7</code>. The second argument is the tonic note of the scale, the third argument is the scale type and finally the fourth argument is number of notes to stack up in the chord. If we choose 4 notes from degree <code>:i</code> of the C major scale, we take the 1st, 3rd, 5th and 7th notes of the scale to get a C major 7 chord.</p>

        
          <table>
          
            <tr>
              <th><code>invert</code></th>
              <td>Apply the specified num inversions to chord. See the fn `chord_invert`.</td>
            </tr>
          
            <caption>Options for chord_degree</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts (chord_degree :i, :A3, :major) # returns a ring of midi notes - (ring 57, 61, 64, 68) - an A major 7 chord</code></pre>
          
            <pre><code>play (chord_degree :i, :A3, :major, 3)</code></pre>
          
            <pre><code>play (chord_degree :ii, :A3, :major, 3) # Chord ii in A major is a B minor chord</code></pre>
          
            <pre><code>play (chord_degree :iii, :A3, :major, 3) # Chord iii in A major is a C# minor chord</code></pre>
          
            <pre><code>play (chord_degree :iv, :A3, :major, 3) # Chord iv in A major is a D major chord</code></pre>
          
            <pre><code>play (chord_degree :i, :C4, :major, 4) # Taking four notes is the default. This gives us 7th chords - here it plays a C major 7</code></pre>
          
            <pre><code>play (chord_degree :i, :C4, :major, 5) # Taking five notes gives us 9th chords - here it plays a C major 9 chord</code></pre>
          
            <pre><code>play (chord_degree :i, :C4, :major, 3, invert: 1) # Play the first inversion of chord i in C major - (ring 64, 67, 72)</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="chord_invert">Chord inversion</h2>
        <code><span class="function">chord_invert</span> notes <span class="arg_type">(list)</span>, shift <span class="arg_type">(number)</span></code>
        <p>Given a set of notes, apply a number of inversions indicated by the <code>shift</code> parameter. Inversions being an increase to notes if <code>shift</code> is positive or decreasing the notes if <code>shift</code> is negative.</p>
<p>An inversion is simply rotating the chord and shifting the wrapped notes up or down an octave. For example, consider the chord :e3, :minor - <code>(ring 52, 55, 59)</code>. When we invert it once, we rotate the notes around to <code>(ring 55, 59, 52)</code>. However, because note 52 is wrapped round, it&#8217;s shifted up an octave (12 semitones) so the actual first inversion of the chord :e3, :minor is <code>(ring 55, 59, 52 + 12)</code> or <code>(ring 55, 59, 64)</code>.</p>
<p>Note that it&#8217;s also possible to directly invert chords on creation with the <code>invert:</code> opt - <code>(chord :e3, :minor, invert: 2)</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play (chord_invert (chord :A3, "M"), 0) #No inversion     - (ring 57, 61, 64)
sleep 1
play (chord_invert (chord :A3, "M"), 1) #First inversion  - (ring 61, 64, 69)
sleep 1
play (chord_invert (chord :A3, "M"), 2) #Second inversion - (ring 64, 69, 73)</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="chord_names">All chord names</h2>
        <code><span class="function">chord_names</span> </code>
        <p>Returns a ring containing all chord names known to Sonic Pi</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts chord_names #=>  prints a list of all the chords</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="clear">Clear all thread locals to defaults</h2>
        <code><span class="function">clear</span> </code>
        <p>All settings such as the current synth, BPM, random stream and tick values will be reset to their defaults. Consider using <code>reset</code> to reset all these values to those inherited from the parent thread.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>Clear wipes out the threads locals
use_synth :blade
use_octave 3

puts "before"         #=> "before"
puts current_synth      #=> :blade
puts current_octave     #=> 3
puts rand               #=> 0.75006103515625
puts tick               #=> 0

at do
  use_synth :tb303
  puts rand               #=> 0.9287109375
  clear
  puts "thread"         #=> "thread"


                          # The clear reset the current synth to the default
                          # of :beep. We are therefore ignoring any inherited
                          # synth settings. It is as if the thread was a completely
                          # new Run.
  puts current_synth      #=> :beep

                          # The current octave defaults back to 0
  puts current_octave     #=> 0

                          # The random stream defaults back to the standard
                          # stream used by every new Run.
  puts rand               #=> 0.75006103515625
  puts tick               #=> 0
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="comment">Block level commenting</h2>
        <code><span class="function">comment</span> </code>
        <p>Does not evaluate any of the code within the block. However, any optional args passed before the block <em>will</em> be evaluated although they will be ignored. See <code>uncomment</code> for switching commenting off without having to remove the comment form.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  comment do # starting a block level comment:
    play 50 # not played
    sleep 1 # no sleep happens
    play 62 # not played
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="control">Control running synth</h2>
        <code><span class="function">control</span> node <span class="arg_type">(synth_node)</span></code>
        <p>If no synth to control is specified, then the last synth triggered by the current (or parent) thread will be controlled - see example below.</p>

        
          <table>
          
            <caption>Options for control</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
## Basic control

my_node = play 50, release: 5, cutoff: 60 # play note 50 with release of 5 and cutoff of 60. Assign return value to variable my_node
sleep 1 # Sleep for a second
control my_node, cutoff: 70 # Now modify cutoff from 60 to 70, sound is still playing
sleep 1 # Sleep for another second
control my_node, cutoff: 90 # Now modify cutoff from 70 to 90, sound is still playing</code></pre>
          
            <pre><code>
## Combining control with slide opts allows you to create nice transitions.

s = synth :prophet, note: :e1, cutoff: 70, cutoff_slide: 8, release: 8 # start synth and specify slide time for cutoff opt
control s, cutoff: 130 # Change the cutoff value with a control.
                       # Cutoff will now slide over 8 beats from 70 to 130</code></pre>
          
            <pre><code>
## Use a short slide time and many controls to create a sliding melody

notes = (scale :e3, :minor_pentatonic, num_octaves: 2).shuffle # get a random ordering of a scale

s = synth :beep, note: :e3, sustain: 8, note_slide: 0.05 # Start our synth running with a long sustain and short note slide time
64.times do
  control s, note: notes.tick                            # Keep quickly changing the note by ticking through notes repeatedly
  sleep 0.125
end</code></pre>
          
            <pre><code>
## Controlling FX

with_fx :bitcrusher, sample_rate: 1000, sample_rate_slide: 8 do |bc| # Start FX but also use the handy || goalposts
                                                                     # to grab a handle on the running FX. We can call
                                                                     # our handle anything we want. Here we've called it bc
  sample :loop_garzul, rate: 1
  control bc, sample_rate: 5000                                      # We can use our handle bc now just like we used s in the
                                                                     # previous example to modify the FX as it runs.
end</code></pre>
          
            <pre><code>
## Controlling chords

cg = play (chord :e4, :minor), sustain: 2  # start a chord
sleep 1
control cg, notes: (chord :c3, :major)     # transition to new chord.
                                           # Each note in the original chord is mapped onto
                                           # the equivalent in the new chord.</code></pre>
          
            <pre><code>
## Sliding between chords

cg = play (chord :e4, :minor), sustain: 4, note_slide: 3  # start a chord
sleep 1
control cg, notes: (chord :c3, :major)                    # slide to new chord.
                                                          # Each note in the original chord is mapped onto
                                                          # the equivalent in the new chord.</code></pre>
          
            <pre><code>
## Sliding from a larger to smaller chord

cg = play (chord :e3, :m13), sustain: 4, note_slide: 3  # start a chord with 7 notes
sleep 1
control cg, notes: (chord :c3, :major)                    # slide to new chord with fewer notes (3)
                                                          # Each note in the original chord is mapped onto
                                                          # the equivalent in the new chord using ring-like indexing.
                                                          # This means that the 4th note in the original chord will
                                                          # be mapped onto the 1st note in the second chord and so-on.</code></pre>
          
            <pre><code>
## Sliding from a smaller to larger chord
cg = play (chord :c3, :major), sustain: 4, note_slide: 3  # start a chord with 3 notes
sleep 1
control cg, notes: (chord :e3, :m13)                     # slide to new chord with more notes (7)
                                                          # Each note in the original chord is mapped onto
                                                          # the equivalent in the new chord.
                                                          # This means that the 4th note in the new chord
                                                          # will not sound as there is no 4th note in the
                                                          # original chord.</code></pre>
          
            <pre><code>
## Changing the slide rate

s = synth :prophet, note: :e1, release: 8, cutoff: 70, cutoff_slide: 8 # Start a synth playing with a long cutoff slide
sleep 1                                                                # wait a beat
control s, cutoff: 130                                                 # change the cutoff so it starts sliding slowly
sleep 3                                                                # wait for 3 beats
control s, cutoff_slide: 1                                             # Change the cutoff_slide - the cutoff now slides more quickly to 130
                                                                       # it will now take 1 beat to slide from its *current* value
                                                                       # (somewhere between 70 and 130) to 130</code></pre>
          
            <pre><code>
## Controlling the last triggered synth

synth :prophet, note: :e1, release: 8                                  # Every time a synth is triggered, Sonic Pi automatically remembers the node
sleep 1
16.times do
  control note: (octs :e1, 3).tick                                     # This means we don't need to use an explicit variable to control the synth
  sleep 0.125                                                          # we last triggered.
end</code></pre>
          
            <pre><code>
## Controlling multiple synths without variables

synth :beep, release: 4                  # Trigger a beep synth
sleep 0.1
control note: :e5                        # Control last triggered synth (:beep)
sleep 0.5
synth :dsaw, release: 4                  # Next, trigger a dsaw synth
sleep 0.1
control note: :e4                        # Control last triggered synth (:dsaw)
</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="cue">Cue other threads</h2>
        <code><span class="function">cue</span> cue_id <span class="arg_type">(symbol)</span></code>
        <p>Send a heartbeat synchronisation message containing the (virtual) timestamp of the current thread. Useful for syncing up external threads via the <code>sync</code> fn. Any opts which are passed are given to the thread which syncs on the <code>cue_id</code>. The values of the opts must be immutable. Currently numbers, symbols, booleans, nil and frozen strings, or vectors&#47;rings&#47;frozen arrays&#47;maps of immutable values are supported.</p>

        
          <table>
          
            <tr>
              <th><code>your_key</code></th>
              <td>Your value</td>
            </tr>
          
            <tr>
              <th><code>another_key</code></th>
              <td>Another value</td>
            </tr>
          
            <tr>
              <th><code>key</code></th>
              <td>All these opts are passed through to the thread which syncs</td>
            </tr>
          
            <caption>Options for cue</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  in_thread do
    sync :foo # this parks the current thread waiting for a foo cue message to be received.
    sample :ambi_lunar_land
  end

  sleep 5

  cue :foo # We send a cue message from the main thread.
            # This then unblocks the thread above and we then hear the sample</code></pre>
          
            <pre><code>
  in_thread do   # Start a metronome thread
    loop do      # Loop forever:
      cue :tick  # sending tick heartbeat messages
      sleep 0.5  # and sleeping for 0.5 beats between ticks
    end
  end

  # We can now play sounds using the metronome.
  loop do                    # In the main thread, just loop
    sync :tick               # waiting for :tick cue messages
    sample :drum_heavy_kick  # after which play the drum kick sample
  end</code></pre>
          
            <pre><code>
  in_thread do   # Start a metronome thread
    loop do      # Loop forever:
      cue [:foo, :bar, :baz].choose # sending one of three tick heartbeat messages randomly
      sleep 0.5  # and sleeping for 0.5 beats between ticks
    end
  end

  # We can now play sounds using the metronome:

  in_thread do
    loop do              # In the main thread, just loop
      sync :foo          # waiting for :foo cue messages
      sample :elec_beep  # after which play the elec beep sample
    end
  end

  in_thread do
    loop do              # In the main thread, just loop
      sync :bar          # waiting for :bar cue messages
      sample :elec_flip  # after which play the elec flip sample
    end
  end

  in_thread do
    loop do              # In the main thread, just loop
      sync :baz          # waiting for :baz cue messages
      sample :elec_blup  # after which play the elec blup sample
    end
  end</code></pre>
          
            <pre><code>
  in_thread do
    loop do
      cue :tick, foo: 64  # sending tick heartbeat messages with a value :foo
      sleep 0.5
    end
  end

  # The value for :foo can now be used in synced threads

  loop do
    values = sync :tick
    play values[:foo]    # play the note value from :foo
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_arg_checks">Get current arg checking status</h2>
        <code><span class="function">current_arg_checks</span> </code>
        <p>Returns the current arg checking setting (<code>true</code> or <code>false</code>).</p>
<p>This can be set via the fns <code>use_arg_checks</code> and <code>with_arg_checks</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_arg_checks # Print out the current arg check setting</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_beat_duration">Duration of current beat</h2>
        <code><span class="function">current_beat_duration</span> </code>
        <p>Get the duration of the current beat in seconds. This is the actual length of time which will elapse with <code>sleep 1</code>.</p>
<p>Affected by calls to <code>use_bpm</code>, <code>with_bpm</code>, <code>use_sample_bpm</code> and <code>with_sample_bpm</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60
  puts current_beat_duration #=> 1

  use_bpm 120
  puts current_beat_duration #=> 0.5</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="current_bpm">Get current tempo</h2>
        <code><span class="function">current_bpm</span> </code>
        <p>To know if this thread is in :link or standard bpm mode see <code>current_bpm_mode</code>.</p>
<p>This can be set via the fns <code>use_bpm</code>, <code>with_bpm</code>, <code>use_sample_bpm</code> and <code>with_sample_bpm</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60
  puts current_bpm_mode    # => 60
  use_bpm 70
  puts current_bpm_mode    # => 70
  use_bpm :link
  puts current_bpm_mode    # => 120 (or whatever the current Link BPM value is)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_bpm_mode">Get current tempo mode</h2>
        <code><span class="function">current_bpm_mode</span> </code>
        <p>To know the current BPM value when this thread is in :link mode see <code>current_bpm</code>.</p>
<p>This can be set via the fns <code>use_bpm</code>, <code>with_bpm</code>, <code>use_sample_bpm</code> and <code>with_sample_bpm</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60
  puts current_bpm_mode    # => 60
  use_bpm 70
  puts current_bpm_mode    # => 70
  use_bpm :link
  puts current_bpm_mode    # => :link</code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="current_cent_tuning">Get current cent shift</h2>
        <code><span class="function">current_cent_tuning</span> </code>
        <p>Returns the cent shift value.</p>
<p>This can be set via the fns <code>use_cent_tuning</code> and <code>with_cent_tuning</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_cent_tuning # Print out the current cent shift</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="current_debug">Get current debug status</h2>
        <code><span class="function">current_debug</span> </code>
        <p>Returns the current debug setting (<code>true</code> or <code>false</code>).</p>
<p>This can be set via the fns <code>use_debug</code> and <code>with_debug</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_debug # Print out the current debug setting</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_midi_defaults">Get current MIDI defaults</h2>
        <code><span class="function">current_midi_defaults</span> </code>
        <p>Returns the current MIDI defaults. This is a map of opt names to values</p>
<p>This can be set via the fns <code>use_midi_defaults</code>, <code>with_midi_defaults</code>, <code>use_merged_midi_defaults</code> and <code>with_merged_midi_defaults</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_midi_defaults channel: 1, port: "foo"
midi_note_on :e1 # Sends MIDI :e1 note on to channel 1 on port "foo"
current_midi_defaults #=> Prints {channel: 1, port: "foo"}</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="current_octave">Get current octave shift</h2>
        <code><span class="function">current_octave</span> </code>
        <p>Returns the octave shift value.</p>
<p>This can be set via the fns <code>use_octave</code> and <code>with_octave</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_octave # Print out the current octave shift</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="current_random_seed">Get current random seed</h2>
        <code><span class="function">current_random_seed</span> </code>
        <p>Returns the current random seed.</p>
<p>This can be set via the fns <code>use_random_seed</code> and <code>with_random_seed</code>. It is incremented every time you use the random number generator via fns such as <code>choose</code> and <code>rand</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts current_random_seed # Print out the current random seed</code></pre>
          
            <pre><code>
## Resetting the seed back to a known place
puts rand               #=>  0.75006103515625
puts rand               #=>  0.733917236328125
a = current_random_seed # Grab the current seed
puts rand               #=> 0.464202880859375
puts rand               #=> 0.24249267578125
use_random_seed a       # Restore the seed
                        # we'll now get the same random values:
puts rand               #=> 0.464202880859375
puts rand               #=> 0.24249267578125</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="current_random_source">Get current random source</h2>
        <code><span class="function">current_random_source</span> </code>
        <p>Returns the source of the current random number generator (what kind of noise is generating the random numbers).</p>
<p>This can be set via the fns <code>use_random_source</code> and <code>with_random_source</code>. Each source will provide a different pattern of random numbers.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts current_random_source # Print out the current random source</code></pre>
          
            <pre><code>
use_random_source :white # Use white noise as the distribution (default)
puts rand # => 0.75006103515625
puts rand # => 0.733917236328125
a = current_random_source # Grab the current random number source (:white)
use_random_source :perlin # Use perlin noise as the distribution
puts rand # => 0.58526611328125
puts rand # => 0.597015380859375
use_random_source a # Restore the previous random number source (:white)
                    # The numbers will again be generated from a white noise distribution
puts rand # => 0.10821533203125
puts rand # => 0.54010009765625</code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="current_sample_defaults">Get current sample defaults</h2>
        <code><span class="function">current_sample_defaults</span> </code>
        <p>Returns the current sample defaults. This is a map of synth arg names to either values or functions.</p>
<p>This can be set via the fns <code>use_sample_defaults</code>, <code>with_sample_defaults</code>, <code>use_merged_sample_defaults</code> and <code>with_merged_sample_defaults</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_sample_defaults amp: 0.5, cutoff: 80
sample :loop_amen # Plays amen break with amp 0.5 and cutoff 80
puts current_sample_defaults #=> Prints {amp: 0.5, cutoff: 80}</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="current_sched_ahead_time">Get current sched ahead time</h2>
        <code><span class="function">current_sched_ahead_time</span> </code>
        <p>Returns the current schedule ahead time.</p>
<p>This can be set via the fn <code>set_sched_ahead_time!</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_sched_ahead_time! 0.5
puts current_sched_ahead_time # Prints 0.5</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_synth">Get current synth</h2>
        <code><span class="function">current_synth</span> </code>
        <p>Returns the current synth name.</p>
<p>This can be set via the fns <code>use_synth</code> and <code>with_synth</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_synth # Print out the current synth name</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_synth_defaults">Get current synth defaults</h2>
        <code><span class="function">current_synth_defaults</span> </code>
        <p>Returns the current synth defaults. This is a map of synth arg names to values.</p>
<p>This can be set via the fns <code>use_synth_defaults</code>, <code>with_synth_defaults</code>, <code>use_merged_synth_defaults</code> and <code>with_merged_synth_defaults</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_synth_defaults amp: 0.5, cutoff: 80
play 50 # Plays note 50 with amp 0.5 and cutoff 80
puts current_synth_defaults #=> Prints {amp: 0.5, cutoff: 80}</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_time">Get current (logically quantized) time</h2>
        <code><span class="function">current_time</span> </code>
        <p>Returns the current logical time. This is a &#8216;wall-clock&#8217; time which should typically be pretty similar to Time.now but quantised to a nearby sleep point in the thread. May be quite different to Time.now within a time_warp!</p>
<p>Unlike <code>Time.now</code>, Multiple calls to <code>current_time</code> with no interleaved calls to <code>sleep</code> or <code>sync</code> will return the same value.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts current_time # 2017-03-19 23:37:57.324 +0000</code></pre>
          
            <pre><code>
# The difference between current_time and Time.now
# See that Time.now is continuous and current_time is discrete
#
# {run: 19, time: 0.0}
puts "A", Time.now.to_f # ├─ "A" 1489966042.761211
puts "B", current_time.to_f # ├─ "B" 1489966042.760181
puts "C", Time.now.to_f # ├─ "C" 1489966042.761235
puts "D", current_time.to_f # ├─ "D" 1489966042.760181
puts "E", current_time.to_f # └─ "E" 1489966042.760181
</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="current_transpose">Get current transposition</h2>
        <code><span class="function">current_transpose</span> </code>
        <p>Returns the current transpose value.</p>
<p>This can be set via the fns <code>use_transpose</code> and <code>with_transpose</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_transpose # Print out the current transpose value</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="current_volume">Get current volume</h2>
        <code><span class="function">current_volume</span> </code>
        <p>Returns the current volume.</p>
<p>This can be set via the fn <code>set_volume!</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts current_volume # Print out the current volume</code></pre>
          
            <pre><code>set_volume! 2
puts current_volume #=> 2</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="dec">Decrement</h2>
        <code><span class="function">dec</span> n <span class="arg_type">(number)</span></code>
        <p>Decrement a number by <code>1</code>. Equivalent to <code>n - 1</code></p>

        
          <table>
          
            <caption>Options for dec</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>dec 1 # returns 0</code></pre>
          
            <pre><code>dec -1 # returns -2</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="define">Define a new function</h2>
        <code><span class="function">define</span> name <span class="arg_type">(symbol)</span></code>
        <p>Allows you to group a bunch of code and give it your own name for future re-use. Functions are very useful for structuring your code. They are also the gateway into live coding as you may redefine a function whilst a thread is calling it, and the next time the thread calls your function, it will use the latest definition.</p>
<p>Note, it is not recommended to start a function name with a capital letter if it takes no parameters.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Define a new function called foo
  define :foo do
    play 50
    sleep 1
  end

  # Call foo on its own
  foo

  # You can use foo anywhere you would use normal code.
  # For example, in a block:
  3.times do
    foo
  end</code></pre>
          
            <pre><code>
  # Define a new function called play2, taking one parameter
  define :play2 do |x|
    play x, release: 2
  end

  # Call play2, passing in a value for the parameter
  play2 42</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="defonce">Define a named value only once</h2>
        <code><span class="function">defonce</span> name <span class="arg_type">(symbol)</span></code>
        <p>Allows you to assign the result of some code to a name, with the property that the code will only execute once - therefore stopping re-definitions. This is useful for defining values that you use in your compositions but you don&#8217;t want to reset every time you press run. You may force the block to execute again regardless of whether or not it has executed once already by using the override option (see examples).</p>

        
          <table>
          
            <tr>
              <th><code>override</code></th>
              <td>If set to true, re-definitions are allowed and this acts like define</td>
            </tr>
          
            <caption>Options for defonce</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>

  defonce :foo do  # Define a new function called foo
    sleep 1        # Sleep for a beat in the function definition. Note that this amount
                   # of time in seconds will depend on the current BPM of the live_loop
                   # or thread calling this function.
    puts "hello" # Print hello
    10             # Return a value of 10
  end

  # Call foo on its own
  puts foo # The run sleeps for a beat and prints "hello" before returning 10

  # Try it again:
  puts foo # This time the run doesn't sleep or print anything out. However, 10 is still returned.



  defonce :foo do # Try redefining foo
    puts "you can't redefine me"
    15
  end

  puts foo # We still don't see any printing or sleeping, and the result is still 10

  # You can use foo anywhere you would use normal code.
  # For example, in a block:
  3.times do
    play foo  # play 10
  end</code></pre>
          
            <pre><code>
  defonce :bar do
    50
  end

  play bar # plays 50

  defonce :bar do # This redefinition doesn't work due to the behaviour of defonce
    70
  end

  play bar # Still plays 50

  defonce :bar, override: true do  # Force definition to take place with override option
    80
  end

  play bar # plays 80</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="degree">Convert a degree into a note</h2>
        <code><span class="function">degree</span> degree <span class="arg_type">(symbol_or_number)</span>, tonic <span class="arg_type">(symbol)</span>, scale <span class="arg_type">(symbol)</span></code>
        <p>For a given scale and tonic it takes a symbol&#47;string&#47;number and resolves it to a midi note. The degree can be either a decimal number or a roman numeral (if it&#8217;s a string or symbol), and may optionally be prefixed an augmentation (<code>a</code>&#47;<code>d</code> for an augmented&#47;diminished interval, <code>aa</code>&#47;<code>dd</code> for double augmented&#47;diminished or <code>p</code> for a perfect (unchanged) interval).</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play degree(:iii, :D3, :major) # major third up from :D3
play degree(3, :C3, :minor) # minor third up from :C3
play degree('d5', :B3, :major) # diminished fifth up from :B3</code></pre>
          
            <pre><code>
chrd = []
[:i, :iii, :v, :dvii, :dix, :Axi, :xiii].each do |d|  # for each degree in the chord
  chrd.append (degree d, :Fs, :major)  # add the corresponding note
end
play chrd  # play an F# 13+11-9 chord, using roman numeral symbols</code></pre>
          
            <pre><code>
chrd = []
['1', '3', '5', 'd7', 'd9', 'A11', '13'].each do |d|
  chrd.append (degree d, :Fs, :major)
end
play chrd  # the same chord as above, but using decimal number strings</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="density">Squash and repeat time</h2>
        <code><span class="function">density</span> d <span class="arg_type">(density)</span></code>
        <p>Runs the block <code>d</code> times with the bpm for the block also multiplied by <code>d</code>. Great for repeating sections a number of times faster yet keeping within a fixed time. If <code>d</code> is less than 1, then time will be stretched accordingly and the block will take longer to complete.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60   # Set the BPM to 60

  density 2 do       # BPM for block is now 120
                     # block is called 2.times
    sample :bd_haus # sample is played twice
    sleep 0.5        # sleep is 0.25s
  end</code></pre>
          
            <pre><code>
  density 2 do |idx| # You may also pass a param to the block similar to n.times
    puts idx         # prints out 0, 1
    sleep 0.5        # sleep is 0.25s
  end
  </code></pre>
          
            <pre><code>
  density 0.5 do          # Specifying a density val of < 1 will stretch out time
                          # A density of 0.5 will double the length of the block's
                          # execution time.
    play 80, release: 1   # plays note 80 with 2s release
    sleep 0.5             # sleep is 1s
  end
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.3.0</p>
      </section>
    
      <section>
        <h2 id="dice">Random dice throw</h2>
        <code><span class="function">dice</span> num_sides <span class="arg_type">(number)</span></code>
        <p>Throws a dice with the specified num_sides (defaults to <code>6</code>) and returns the score as a number between <code>1</code> and <code>num_sides</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  dice # will return a number between 1 and 6 inclusively
       # (with an even probability distribution).</code></pre>
          
            <pre><code>
  dice 3 # will return a number between 1 and 3 inclusively</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="doubles">Create a ring of successive doubles</h2>
        <code><span class="function">doubles</span> start <span class="arg_type">(number)</span>, num_doubles <span class="arg_type">(int)</span></code>
        <p>Create a ring containing the results of successive doubling of the <code>start</code> value. If <code>num_doubles</code> is negative, will return a ring of <code>halves</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(doubles 60, 2)  #=> (ring 60, 120)</code></pre>
          
            <pre><code>(doubles 1.5, 3) #=> (ring 1.5, 3, 6)</code></pre>
          
            <pre><code>(doubles 1.5, 5) #=> (ring 1.5, 3, 6, 12, 24)</code></pre>
          
            <pre><code>(doubles 100, -4) #=> (ring 100, 50, 25, 12.5)</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="eval_file">Evaluate the contents of the file inline in the current thread like a function.</h2>
        <code><span class="function">eval_file</span> filename <span class="arg_type">(path)</span></code>
        <p>Reads the full contents of the file with <code>path</code> and executes within the current thread like a function call.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
eval_file "~/path/to/sonic-pi-code.rb" #=> will run the contents of this file</code></pre>
          
          </details>
        
        <p>Introduced in 3.2.0</p>
      </section>
    
      <section>
        <h2 id="factor?">Factor test</h2>
        <code><span class="function">factor?</span> val <span class="arg_type">(number)</span>, factor <span class="arg_type">(number)</span></code>
        <p>Test to see if factor is indeed a factor of <code>val</code>. In other words, can <code>val</code> be divided exactly by factor.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  factor?(10, 2) # true - 10 is a multiple of 2 (2 * 5 = 10)
  </code></pre>
          
            <pre><code>
  factor?(11, 2) #false - 11 is not a multiple of 2
  </code></pre>
          
            <pre><code>
  factor?(2, 0.5) #true - 2 is a multiple of 0.5 (0.5 * 4 = 2) </code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="fx_names">Get all FX names</h2>
        <code><span class="function">fx_names</span> </code>
        <p>Return a list of all the FX available</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="get">Get information from the Time State</h2>
        <code><span class="function">get</span> time_state_key <span class="arg_type">(default)</span></code>
        <p>Retrieve information from Time State set prior to the current time from either the current or any other thread. If called multiple times will always return the same value unless a call to <code>sleep</code>, <code>sync</code>, <code>set</code> or <code>cue</code> is interleaved. Also, calls to <code>get</code> will always return the same value across Runs for deterministic behaviour - which means you may safely use it in your compositions for repeatable music. If no value is stored with the relevant key, will return <code>nil</code>.</p>
<p>May be used within a <code>time_warp</code> to retrieve past events. If in a time warp, <code>get</code> can not be called from a future position. Does not advance time.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  get :foo #=> returns the last value set as :foo, or nil</code></pre>
          
            <pre><code>
set :foo, 3
get[:foo] #=> returns 3</code></pre>
          
            <pre><code>
in_thread do
  set :foo, 3
end

in_thread do
  puts get[:foo]  #=> always returns 3 (no race conditions here!)
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="halves">Create a ring of successive halves</h2>
        <code><span class="function">halves</span> start <span class="arg_type">(number)</span>, num_halves <span class="arg_type">(int)</span></code>
        <p>Create a ring containing the results of successive halving of the <code>start</code> value. If <code>num_halves</code> is negative, will return a ring of <code>doubles</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(halves 60, 2)  #=> (ring 60, 30)</code></pre>
          
            <pre><code>(halves 120, 3) #=> (ring 120, 60, 30)</code></pre>
          
            <pre><code>(halves 120, 5) #=> (ring 120, 60, 30, 15, 7.5)</code></pre>
          
            <pre><code>(halves 30, -5) #=> (ring 30, 60, 120, 240, 480)</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="hz_to_midi">Hz to MIDI conversion</h2>
        <code><span class="function">hz_to_midi</span> freq <span class="arg_type">(number)</span></code>
        <p>Convert a frequency in hz to a midi note. Note that the result isn&#8217;t an integer and there is a potential for some very minor rounding errors.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>hz_to_midi(261.63) #=> 60.0003</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="in_thread">Run code block at the same time</h2>
        <code><span class="function">in_thread</span> </code>
        <p>It is possible to delay the initial trigger of the thread on creation with both the <code>delay:</code> and <code>sync:</code> opts. See their respective docstrings. If both <code>delay:</code> and <code>sync:</code> are specified, on initial thread creation first the delay will be honoured and then the sync.</p>

        
          <table>
          
            <tr>
              <th><code>name</code></th>
              <td>Make this thread a named thread with name. If a thread with this name already exists, a new thread will not be created.</td>
            </tr>
          
            <tr>
              <th><code>delay</code></th>
              <td>Initial delay in beats before the thread starts. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>sync</code></th>
              <td>Initial sync symbol. Will sync with this symbol before the thread starts.</td>
            </tr>
          
            <tr>
              <th><code>sync_bpm</code></th>
              <td>Initial sync symbol. Will sync with this symbol before the thread starts. Thread will also inherit the BPM of the thread which cued the symbol.</td>
            </tr>
          
            <caption>Options for in_thread</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  loop do      # If you write two loops one after another like this,
    play 50    # then only the first loop will execute as the loop acts
    sleep 1    # like a trap not letting the flow of control out
  end

  loop do      # This code is never executed.
    play 55
    sleep 0.5
  end </code></pre>
          
            <pre><code>

  # In order to play two loops at the same time, the first loops need to
  # be in a thread (note that it's probably more idiomatic to use live_loop
  # when performing):

  # By wrapping our loop in an in_thread block, we split the
  # control flow into two parts. One flows into the loop (a) and
  # the other part flows immediately after the in_thread block (b).
  # both parts of the control flow execute at exactly the same time.

  in_thread do
    # (a)
    loop do
      # (a)
      play 50
      sleep 1
    end
  end

  # (b)

  loop do      # This loop is executed thanks to the thread above
    play 55
    sleep 0.5
  end</code></pre>
          
            <pre><code>
  use_bpm 120  # Set the bpm to be double rate
  use_synth :dsaw  # Set the current synth to be :dsaw

  in_thread do     # Create a new thread
    play 50        # Play note 50 at time 0
    use_synth :fm  # Switch to fm synth (only affects this thread)
    sleep 1        # sleep for 0.5 seconds (as we're double rate)
    play 38        # Play note 38 at time 0.5
  end

  play 62          # Play note 62 at time 0 (with dsaw synth)
  sleep 2          # sleep 1s
  play 67          # Play note 67 at time 1s (also with dsaw synth)
  </code></pre>
          
            <pre><code>
  in_thread(name: :foo) do # Here we've created a named thread
    loop do
      sample :drum_bass_hard
      sleep 1
    end
  end

  in_thread(name: :foo) do # This thread isn't created as the name is
    loop do                # the same as the previous thread which is
      sample :elec_chime   # still executing.
      sleep 0.5
    end
  end</code></pre>
          
            <pre><code>
   # Named threads work well with functions for live coding:
  define :foo do  # Create a function foo
    play 50       # which does something simple
    sleep 1       # and sleeps for some time
  end

  in_thread(name: :main) do  # Create a named thread
    loop do                  # which loops forever
      foo                    # calling our function
    end
  end

  # We are now free to modify the contents of :foo and re-run the entire buffer.
  # We'll hear the effect immediately without having to stop and re-start the code.
  # This is because our fn has been redefined, (which our thread will pick up) and
  # due to the thread being named, the second re-run will not create a new similarly
  # named thread. This is a nice pattern for live coding and is the basis of live_loop.
  </code></pre>
          
            <pre><code>
  #Delaying the start of a thread
  in_thread delay: 1 do
    sample :ambi_lunar_land # this sample is not triggered at time 0 but after 1 beat
  end

  play 80                   # Note 80 is played at time 0
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="inc">Increment</h2>
        <code><span class="function">inc</span> n <span class="arg_type">(number)</span></code>
        <p>Increment a number by <code>1</code>. Equivalent to <code>n + 1</code></p>

        
          <table>
          
            <caption>Options for inc</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>inc 1 # returns 2</code></pre>
          
            <pre><code>inc -1 # returns 0</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="kill">Kill synth</h2>
        <code><span class="function">kill</span> node <span class="arg_type">(synth_node)</span></code>
        <p>Kill a running synth sound or sample. In order to kill a sound, you need to have stored a reference to it in a variable.</p>

        
          <table>
          
            <caption>Options for kill</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# store a reference to a running synth in a variable called foo:
foo = play 50, release: 4
sleep 1
# foo is still playing, but we can kill it early:
kill foo</code></pre>
          
            <pre><code>bar = sample :loop_amen
sleep 0.5
kill bar</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="knit">Knit a sequence of repeated values</h2>
        <code><span class="function">knit</span> value <span class="arg_type">(anything)</span>, count <span class="arg_type">(number)</span></code>
        <p>Knits a series of value, count pairs to create a ring buffer where each value is repeated count times.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(knit 1, 5)    #=> (ring 1, 1, 1, 1, 1)</code></pre>
          
            <pre><code>(knit :e2, 2, :c2, 3) #=> (ring :e2, :e2, :c2, :c2, :c2)</code></pre>
          
          </details>
        
        <p>Introduced in 2.2.0</p>
      </section>
    
      <section>
        <h2 id="line">Create a ring buffer representing a straight line</h2>
        <code><span class="function">line</span> start <span class="arg_type">(number)</span>, finish <span class="arg_type">(number)</span></code>
        <p>Create a ring buffer representing a straight line between start and finish of steps elements. Steps defaults to <code>4</code>. Indexes wrap around positively and negatively. Similar to <code>range</code>.</p>

        
          <table>
          
            <tr>
              <th><code>steps</code></th>
              <td>number of slices or segments along the line</td>
            </tr>
          
            <tr>
              <th><code>inclusive</code></th>
              <td>boolean value representing whether or not to include finish value in line</td>
            </tr>
          
            <caption>Options for line</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(line 0, 4, steps: 4)    #=> (ring 0.0, 1.0, 2.0, 3.0)</code></pre>
          
            <pre><code>(line 5, 0, steps: 5)    #=> (ring 5.0, 4.0, 3.0, 2.0, 1.0)</code></pre>
          
            <pre><code>(line 0, 3, inclusive: true) #=> (ring 0.0, 1.0, 2.0, 3.0)</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="link">Use Ableton Link network metronome with automatic phase syncing.</h2>
        <code><span class="function">link</span> quantum <span class="arg_type">(number)</span>, phase <span class="arg_type">(number)</span></code>
        <p>By default link waits for the start of the next bar of the shared network metronome link. You can choose how many beats there are in a bar by setting the quantum option and&#47;or which beat to wait for by setting the phase option.</p>
<p>By default, the phase to sync on is 0 and the quantum (max number of beats) is 4.</p>
<p>Also switches BPM to :link mode so there is no explicit need to call use_bpm :link.  The time and beat set to match the network Link metronome.</p>
<p>This function will block the current thread until the next matching phase as if <code>sleep</code> had been called with the exact sleep time</p>
<p>If the quantum is 4 (the default) this suggests there are 4 beats in each bar. If the phase is set to 0 (also the default) this means that calling link will sleep until the very start of the next bar before continuing.</p>
<p>This can be used to sync multiple instances of Sonic Pi running on different computers connected to the same network (via wifi or ethernet). It can also be used to share and coordinate time with other apps and devices. For a full list of link-compatible apps and devices see:  <a href="https://www.ableton.com/en/link/products/">https:&#47;&#47;www.ableton.com&#47;en&#47;link&#47;products&#47;</a></p>
<p>For other related link functions see link<em>sync, use</em>bpm :link, set<em>link</em>bpm!</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_bpm 120      # bpm is at 120
link             # wait for the start of the next bar before continuing
                 # (where each bar has 4 beats)
puts current_bpm #=> :link (not 120)
  </code></pre>
          
            <pre><code>
link 8 # wait for the start of the next bar
       # (where each bar has 8 beats)</code></pre>
          
            <pre><code>
link 7, 2 # wait for the 2nd beat of the next bar
          # (where each bar has 7 beats)</code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="link_sync">Use Ableton Link network metronome with automatic session and phase syncing.</h2>
        <code><span class="function">link_sync</span> quantum <span class="arg_type">(number)</span>, phase <span class="arg_type">(number)</span></code>
        <p>Similar to link except it also waits for the link session to be playing. If it is, then it behaves identially to link. If the session is not playing, then link_sync will first wait until the session has started before then continuing as if just link had been called.</p>
<p>See link for further details and usage.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code></code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="live_audio">A named audio stream live from your soundcard</h2>
        <code><span class="function">live_audio</span> name <span class="arg_type">(symbol)</span></code>
        <p>Create a named synthesiser which works similar to <code>play</code>, <code>sample</code> or <code>synth</code>. Rather than synthesising the sound mathematically or playing back recorded audio, it streams audio live from your sound card.</p>
<p>However, unlike <code>play</code>, <code>sample</code> and <code>synth</code>, which allow multiple similar synths to play at the same time (i.e. a chord) only one <code>live_audio</code> synth of a given name may exist in the system at any one time. This is similar to <code>live_loop</code> where only one live loop of each name may exist at any one time. See examples for further information.</p>
<p>An additional difference is that <code>live_audio</code> will create an infinitely long synth rather than be timed to an envelope like the standard <code>synth</code> and <code>sample</code> synths. This is particularly suitable for working with continuous incoming audio streams where the source of the audio is unknown (for example, it may be a guitar, an analog synth or an electronic violin). If the source is continuous, then it may not be suited to being stitched together by successive enveloped calls to something like: <code>synth :sound_in, attack: 0, sustain: 4, release: 0</code>. If we were to <code>live_loop</code> this with a <code>sleep 4</code> to match the sustain duration, we would get something that emulated a continuous stream, but for certain inputs you&#8217;ll hear clicking at the seams between each successive call to <code>synth</code> where the final part of the audio signal from the previous synth doesn&#8217;t precisely match up with the start of the signal in the next synth due to very minor timing differences.</p>
<p>Another important feature of <code>live_audio</code> is that it will automatically move an existing <code>live_audio</code> synth into the current FX context. This means you can live code the FX chain around the live stream and it will update automatically. See examples.</p>
<p>To stop a <code>live_audio</code> synth, use the <code>:stop</code> arg: <code>live_audio :foo, :stop</code>.
.</p>

        
          <table>
          
            <tr>
              <th><code>input</code></th>
              <td>The audio card input to read audio from.</td>
            </tr>
          
            <tr>
              <th><code>stereo</code></th>
              <td>If set to truthy value (true, 1) will read from two consecutive audio card inputs.</td>
            </tr>
          
            <caption>Options for live_audio</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Basic usage
live_audio :foo  # Play whatever audio is coming into the sound card on input 1</code></pre>
          
            <pre><code>
# Specify an input
live_audio :foo, input: 3  # Play whatever audio is coming into the sound card on input 3</code></pre>
          
            <pre><code>
# Work with stereo input
live_audio :foo, input: 3, stereo: true  # Play whatever audio is coming into the sound card on inputs 3 and 4
                                         # as a stereo stream</code></pre>
          
            <pre><code># Switching audio contexts (i.e. changing FX)
live_audio :guitar     # Play whatever audio is coming into the sound card on input 1

sleep 2                # Wait for 2 seconds then...

with_fx :reverb do
  live_audio :guitar   # Add reverb to the audio from input 1
end

sleep 2                # Wait for another 2 seconds then...

live_audio :guitar     # Remove the reverb from input 1</code></pre>
          
            <pre><code>
# Working with live_loops

live_loop :foo do
  with_fx [:reverb, :distortion, :echo].choose do   # chooses a new FX each time round the live loop
    live_audio :voice                               # the audio stream from input 1 will be moved to the
  end                                               # new FX and the old FX will complete and finish as normal.
  sleep 8
end</code></pre>
          
            <pre><code>
# Stopping

live_audio :foo            #=> start playing audio from input 1
live_audio :bar, input: 2  #=> start playing audio from input 2

sleep 3                    #=> wait for 3s...

live_audio :foo, :stop     #=> stop playing audio from input 1
                           #=> (live_audio :bar is still playing)</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="live_loop">A loop for live coding</h2>
        <code><span class="function">live_loop</span> name <span class="arg_type">(symbol)</span></code>
        <p>Loop the do&#47;end block forever. However, unlike a basic loop, a live_loop has two special properties. Firstly it runs in a thread - so you can have any number of live loops running at the same time (concurrently). Secondly, you can change the behaviour of a live loop whilst it is still running without needing to stop it. Live loops are therefore the secret to live coding with Sonic Pi.</p>
<p>As live loops are excecuted within a named in<em>thread, they behave similarly. See the in</em>thread documentation for all the details. However, it&#8217;s worth mentioning a few important points here. Firstly, only one live loop with a given name can run at any one time. Therefore, if you define two or more <code>live_loop</code>s called <code>:foo</code> only one will be running. Another important aspect of <code>live_loop</code>s is that they manage their own thread locals set with the <code>use_*</code> and <code>with_*</code> fns. This means that each <code>live_loop</code> can have its own separate default synth, BPM and sample defaults. When a <code>live_loop</code> is <em>first</em> created, it inherits the thread locals from the parent thread, but once it has started, the only way to change them is by re-defining the do&#47;end body of the <code>live_loop</code>. See the examples below for details. Finally, as mentioned above, provided their names are different, you may have many <code>live_loop</code>s executing at once.</p>
<p>A typical way of live coding with live loops is to define a number of them in a buffer, hit Run to start them and then to modify their do&#47;end blocks and then hit Run again. This will not create any more thread, but instead just modify the behaviour of the existing threads. The changes will <em>not</em> happen immediately. Instead, they will only happen the next time round the loop. This is because the behaviour of each live loop is implemented with a standard function. When a live loop is updated, the function definition is also updated. Each time round the live loop, the function is called, so the new behviour is only observed next time round the loop.</p>
<p>Also sends a <code>cue</code> with the same name each time the <code>live_loop</code> repeats. This may be used to <code>sync</code> with other threads and <code>live_loop</code>s.</p>
<p>If the <code>live_loop</code> block is given a parameter, this is given the result of the last run of the loop (with initial value either being <code>0</code> or an init arg). This allows you to &#8216;thread&#8217; values across loops.</p>
<p>Finally, it is possible to delay the initial trigger of the live<em>loop on creation with both the <code>delay:</code> and <code>sync:</code> opts. See their respective docstrings. If both <code>delay:</code> and <code>sync:</code> are specified, on initial live</em>loop creation first the delay will be honoured and then the sync.</p>

        
          <table>
          
            <tr>
              <th><code>init</code></th>
              <td>initial value for optional block arg</td>
            </tr>
          
            <tr>
              <th><code>auto_cue</code></th>
              <td>enable or disable automatic cue (default is true)</td>
            </tr>
          
            <tr>
              <th><code>delay</code></th>
              <td>Initial delay in beats before the live_loop starts. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>sync</code></th>
              <td>Initial sync symbol. Will sync with this symbol before the live_loop starts.</td>
            </tr>
          
            <tr>
              <th><code>sync_bpm</code></th>
              <td>Initial sync symbol. Will sync with this symbol before the live_loop starts. Live loop will also inherit the BPM of the thread which cued the symbol.</td>
            </tr>
          
            <tr>
              <th><code>seed</code></th>
              <td>override initial random generator seed before starting loop.</td>
            </tr>
          
            <caption>Options for live_loop</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
## Define and start a simple live loop

live_loop :ping do  # Create a live loop called :ping
  sample :elec_ping # This live loops plays the :elec_ping sample
  sleep 1           # Then sleeps for 1 beat before repeating
end
  </code></pre>
          
            <pre><code>
## Every live loop must sleep or sync

live_loop :ping do  # Create a live loop called :ping
  sample :elec_ping # This live loops plays the :elec_ping sample
                    # However, because the do/end lock of the live loop does not
                    # contain any calls to sleep or sync, the live loop stops at
                    # the end of the first loop with a 'Did not sleep' error.
end</code></pre>
          
            <pre><code>
## Multiple live loops will play at the same time
live_loop :foo do  # Start a live loop called :foo
  play 70
  sleep 1
end

live_loop :bar do  # Start another live loop called :bar
  sample :bd_haus  # Both :foo and :bar will be playing
  sleep 0.5        # at the same time.
end</code></pre>
          
            <pre><code>
## Live loops inherit external use_* thread locals
use_bpm 30
live_loop :foo do
  play 70           # live loop :foo now has a BPM of 30
  sleep 1           # This sleep will be for 2 seconds
end</code></pre>
          
            <pre><code>
## Live loops can have their own thread locals
live_loop :foo do
  use_bpm 30       # Set the BPM of live loop :foo to 30
  play 70
  sleep 1          # This sleep will be for 2 seconds
end

live_loop :bar do
  use_bpm 120      # Set the BPM of live loop :bar to 120
  play 82
  sleep 1          # This sleep will be for 0.5 seconds
end</code></pre>
          
            <pre><code>
## Live loops can pass values between iterations
live_loop :foo do |a|  # pass a param (a) to the block (inits to 0)
  puts a               # prints out all the integers
  sleep 1
  a += 1               # increment a by 1 (last value is passed back into the loop)
end
  </code></pre>
          
            <pre><code>
## Live loop names must be unique
live_loop :foo do  # Start a live loop called :foo
  play 70
  sleep 1
end

live_loop :foo do  # Attempt to start another also called :foo
  sample :bd_haus  # With a different do/end block
  sleep 0.5        # This will not start another live loop
                   # but instead replace the behaviour of the first.
end                # There will only be one live loop running playing
                   # The bass drum</code></pre>
          
            <pre><code>
## You can sync multiple live loops together
live_loop :foo, sync: :bar do # Wait for a :bar cue event before starting :foo
 play 70                      # Live loop :foo is therefore blocked and does
 sleep 1                      # not make a sound initially
end

sleep 4                       # Wait for 4 beats

live_loop :bar do             # Start a live loop called :foo which will emit a :bar
  sample :bd_haus             # cue message therefore releasing the :foo live loop.
  sleep 0.5                   # Live loop :foo therefore starts and also inherits the
end                           # logical time of live loop :bar.

                              # This pattern is also useful to re-sync live loops after
                              # errors are made. For example, when modifying live loop :foo
                              # it is possible to introduce a runtime error which will stop
                              # :foo but not :bar (as they are separate, isolated threads).
                              # Once the error has been fixed and the code is re-run, :foo
                              # will automatically wait for :bar to loop round and restart
                              # in sync with the correct virtual clock.</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="load_buffer">Load the contents of a file to the current buffer</h2>
        <code><span class="function">load_buffer</span> path <span class="arg_type">(string)</span></code>
        <p>Given a path to a file, will read the contents and load it into the current buffer. This will replace any previous content.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
load_buffer "~/sonic-pi-tracks/phat-beats.rb" # will replace content of current buffer with contents of the file</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="load_example">Load a built-in example</h2>
        <code><span class="function">load_example</span> path <span class="arg_type">(string)</span></code>
        <p>Given a keyword representing an example, will load it into the current buffer. This will replace any previous content.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
load_example :rerezzed # will replace content of current buffer with the rerezzed example</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="load_sample">Pre-load first matching sample</h2>
        <code><span class="function">load_sample</span> path <span class="arg_type">(string)</span></code>
        <p>Given a path to a <code>.wav</code>, <code>.wave</code>, <code>.aif</code>, <code>.aiff</code>, <code>.ogg</code>, <code>.oga</code> or <code>.flac</code> file, pre-loads the sample into memory.</p>
<p>You may also specify the same set of source and filter pre-args available to <code>sample</code> itself. <code>load_sample</code> will then load all matching samples. See <code>sample</code>&#8217;s docs for more information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
load_sample :elec_blip # :elec_blip is now loaded and ready to play as a sample
sample :elec_blip # No delay takes place when attempting to trigger it</code></pre>
          
            <pre><code># Using source and filter pre-args
dir = "/path/to/sample/dir"
load_sample dir # loads first matching sample in "/path/to/sample/dir"
load_sample dir, 1 # loads sample with index 1 in "/path/to/sample/dir"
load_sample dir, :foo # loads sample with name "foo" in "/path/to/sample/dir"
load_sample dir, "quux" # loads first sample with file name containing "quux" in "/path/to/sample/dir"
load_sample dir, /[Bb]ar/ # loads first sample which matches regex /[Bb]ar/ in "/path/to/sample/dir"</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="load_samples">Pre-load all matching samples</h2>
        <code><span class="function">load_samples</span> paths <span class="arg_type">(list)</span></code>
        <p>Given a directory containing multiple <code>.wav</code>, <code>.wave</code>, <code>.aif</code>, <code>.aiff</code>, <code>.ogg</code>, <code>.oga</code> or <code>.flac</code> files, pre-loads all the samples into memory.</p>
<p>You may also specify the same set of source and filter pre-args available to <code>sample</code> itself. <code>load_sample</code> will load all matching samples (not just the sample <code>sample</code> would play given the same opts) - see <code>sample</code>&#8217;s docs for more information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
 load_sample :elec_blip # :elec_blip is now loaded and ready to play as a sample
 sample :elec_blip # No delay takes place when attempting to trigger it</code></pre>
          
            <pre><code># Using source and filter pre-args
 dir = "/path/to/sample/dir"
 load_sample dir # loads all samples in "/path/to/sample/dir"
 load_sample dir, 1 # loads sample with index 1 in "/path/to/sample/dir"
 load_sample dir, :foo # loads sample with name "foo" in "/path/to/sample/dir"
 load_sample dir, "quux" # loads all samples with file names containing "quux" in "/path/to/sample/dir"
 load_sample dir, /[Bb]ar/ # loads all samples which match regex /[Bb]ar/ in "/path/to/sample/dir"

 </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="load_synthdef">Load a single external synthdef</h2>
        <code><span class="function">load_synthdef</span> path <span class="arg_type">(string)</span></code>
        <p>Load a pre-compiled synth design from the specified file. This is useful if you wish to use your own SuperCollider synthesiser designs within Sonic Pi.</p>
<h2 id="important-notes">Important notes</h2>
<p>The binary file containing the synth design must have the extension <code>.scsyndef</code>.</p>
<p>You may not trigger external synthdefs unless you enable the following GUI preference:</p>
<pre><code>Studio -&#62; Synths and FX -&#62; Enable external synths and FX
</code></pre>
<p>If you wish your synth to work with Sonic Pi&#8217;s automatic stereo sound infrastructure <em>you need to ensure your synth outputs a stereo signal</em> to an audio bus with an index specified by a synth arg named <code>out_bus</code>. Also, Sonic Pi makes no automatic attempt to free a synth once triggered, so to behave like the built-in synths, your synth needs to automatically free itself. For example, the following synth would work nicely:</p>
<pre><code>(
SynthDef(\piTest,
         {|freq = 200, amp = 1, out_bus = 0 |
           Out.ar(out_bus,
                  SinOsc.ar([freq,freq],0,0.5)* Line.kr(1, 0, 5, amp, doneAction: 2))}
).writeDefFile("&#47;Users&#47;sam&#47;Desktop&#47;")
)
</code></pre>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>load_synthdef "~/Desktop/my_noises/whoosh.scsyndef" # Load whoosh synthdef design.</code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="load_synthdefs">Load external synthdefs</h2>
        <code><span class="function">load_synthdefs</span> path <span class="arg_type">(string)</span></code>
        <p>Load all pre-compiled synth designs in the specified directory. This is useful if you wish to use your own SuperCollider synthesiser designs within Sonic Pi.</p>
<h2 id="important-notes">Important notes</h2>
<p>Only files with the extension <code>.scsyndef</code> within the specified directory will be loaded.</p>
<p>You may not trigger external synthdefs unless you enable the following GUI preference:</p>
<pre><code>Studio -&#62; Synths and FX -&#62; Enable external synths and FX
</code></pre>
<p>If you wish your synth to work with Sonic Pi&#8217;s automatic stereo sound infrastructure <em>you need to ensure your synth outputs a stereo signal</em> to an audio bus with an index specified by a synth arg named <code>out_bus</code>. Also, Sonic Pi makes no automatic attempt to free a synth once triggered, so to behave like the built-in synths, your synth needs to automatically free itself. For example, the following synth would work nicely:</p>
<pre><code>(
SynthDef(\piTest,
         {|freq = 200, amp = 1, out_bus = 0 |
           Out.ar(out_bus,
                  SinOsc.ar([freq,freq],0,0.5)* Line.kr(1, 0, 5, amp, doneAction: 2))}
).writeDefFile("&#47;Users&#47;sam&#47;Desktop&#47;")
)
</code></pre>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>load_synthdefs "~/Desktop/my_noises" # Load all synthdefs in my_noises folder</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="look">Obtain value of a tick</h2>
        <code><span class="function">look</span> </code>
        <p>Read and return value of default tick. If a <code>key</code> is specified, read the value of that specific tick. Ticks are <code>in_thread</code> and <code>live_loop</code> local, so the tick read will be the tick of the current thread calling <code>look</code>.</p>

        
          <table>
          
            <tr>
              <th><code>offset</code></th>
              <td>Offset to add to index returned. Useful when calling look on lists, rings and vectors to offset the returned value</td>
            </tr>
          
            <caption>Options for look</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts look #=> 0
  puts look #=> 0
  puts look #=> 0 # look doesn't advance the tick, it just returns the current value
  </code></pre>
          
            <pre><code>
  puts look #=> 0 # A look is always 0 before the first tick
  tick # advance the tick
  puts look #=> 0 # Note: a look is still 0 after the first tick.
  tick
  puts look #=> 1
  puts look #=> 1 # making multiple calls to look doesn't affect tick value
  tick
  puts look #=> 2
  </code></pre>
          
            <pre><code>
  tick(:foo)
  tick(:foo)
  puts look(:foo) #=> 1 (keyed look :foo has been advanced)
  puts look #=> 0 (default look hasn't been advanced)
  puts look(:bar) #=> 0 (other keyed looks haven't been advanced either)
  </code></pre>
          
            <pre><code>
  # You can call look on lists and rings
  live_loop :foo do
    tick                                      # advance the default tick
    use_synth :beep
    play (scale :e3, :minor_pentatonic).look  # look into the default tick to play all notes in sequence
    sleep 0.5
    use_synth :square
    play (ring :e1, :e2, :e3).look, release: 0.25 # use the same look on another ring
    sleep 0.25
  end
  </code></pre>
          
            <pre><code>
# Returns numbers unchanged if single argument
puts look(0)     #=> 0
puts look(4)     #=> 4
puts look(-4)    #=> -4
puts look(20.3)  #=> 20.3</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="loop">Repeat do/end block forever</h2>
        <code><span class="function">loop</span> </code>
        <p>Given a do&#47;end block, repeats it forever. Note that once the program enters the loop - it will not move on but will instead stay within the loop. Plain loops like this are like black holes - instead of sucking in the light they suck in the program.</p>
<p>The loop must either <code>sleep</code> or <code>sync</code> each time round otherwise it will stop and throw an error. This is to stop the loop from spinning out of control and locking the system.</p>
<p>For a more powerful, flexible loop built for live coding see <code>live_loop</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>

play 70       # note 70 is played

loop do
  play 50     # This loop will repeat notes 50 and 62 forever
  sleep 1
  play 62
  sleep 2
end

play 80      # This is *never* played as the program is trapped in the loop above</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="map">Create an immutable map</h2>
        <code><span class="function">map</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new immutable key&#47;value map from args. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(map foo: 1, bar: 2)[:foo] #=> 1</code></pre>
          
            <pre><code>(map foo: 1, bar: 2)[:bar] #=> 2</code></pre>
          
            <pre><code>(map foo: 1, bar: 2)[:quux] #=> nil</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="math_scale">Linear scaling algorithm</h2>
        <code><span class="function">math_scale</span>  <span class="arg_type">()</span></code>
        <p>Scales a given input value within the specified input range to a
  corresponding value in the specified output range using the formula:</p>
<pre><code>       (out_max - out_min) (val - in_min)
</code></pre>
<p>f (x) = &#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;  + out<em>min
                    in</em>max - in_min</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>math_scale 0.5, 0, 1, 10, 20 #=> 15</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi">Trigger and release an external synth via MIDI</h2>
        <code><span class="function">midi</span> note <span class="arg_type">(number)</span></code>
        <p>Sends a MIDI note on event to <em>all</em> connected MIDI devices and <em>all</em> channels and then after sustain beats sends a MIDI note off event. Ensures MIDI trigger is synchronised with standard calls to play and sample. Co-operates completely with Sonic Pi&#8217;s timing system including <code>time_warp</code>.</p>
<p>If <code>note</code> is specified as <code>:off</code> then all notes will be turned off (same as <code>midi_all_notes_off</code>).</p>

        
          <table>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Duration of note event in beats</td>
            </tr>
          
            <tr>
              <th><code>vel</code></th>
              <td>Velocity of note as a MIDI number</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi on/off messages from being sent out. (Ensures all opts are evaluated in this call to `midi` regardless of value).</td>
            </tr>
          
            <caption>Options for midi</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi :e1, sustain: 0.3, vel_f: 0.5, channel: 3 # Play E, octave 1 for 0.3 beats at half velocity on channel 3 on all connected MIDI ports.</code></pre>
          
            <pre><code>midi :off, channel: 3 #=> Turn off all notes on channel 3 on all connected MIDI ports</code></pre>
          
            <pre><code>midi :e1, channel: 3, port: "foo" #=> Play note :E1 for 1 beats on channel 3 on MIDI port named "foo" only</code></pre>
          
            <pre><code>
live_loop :arp do
  midi (octs :e1, 3).tick, sustain: 0.1 # repeatedly play a ring of octaves
  sleep 0.125
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_all_notes_off">Turn off all notes on MIDI devices</h2>
        <code><span class="function">midi_all_notes_off</span> </code>
        <p>When an All Notes Off event is received, all oscillators will turn off.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - All Notes Off</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the all notes off message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi all notes off message from being sent out. (Ensures all opts are evaluated in this call to `midi_all_notes_off` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_all_notes_off</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_all_notes_off #=> Turn off all notes on MIDI devices on all channels (and ports)</code></pre>
          
            <pre><code>midi_all_notes_off channel: 2 #=> Turn off all notes on MIDI devices on channel 2</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_cc">Send MIDI control change message</h2>
        <code><span class="function">midi_cc</span> control_num <span class="arg_type">(midi)</span>, value <span class="arg_type">(midi)</span></code>
        <p>Control number and control value can be passed as a note such as <code>:e3</code> and decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3.</p>
<p>You may also optionally pass the control value as a floating point value between 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between 0 and 127) using the <code>val_f:</code> opt.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Control change</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>value</code></th>
              <td>Control value as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>val_f</code></th>
              <td>Control value as a value between 0 and 1 (will be converted to a MIDI value)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi cc message from being sent out. (Ensures all opts are evaluated in this call to `midi_cc` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_cc</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_cc 100, 32  #=> Sends MIDI cc message to control 100 with value 32 to all ports and channels</code></pre>
          
            <pre><code>midi_cc :e7, 32  #=> Sends MIDI cc message to control 100 with value 32 to all ports and channels</code></pre>
          
            <pre><code>midi_cc 100, 32, channel: 5  #=> Sends MIDI cc message to control 100 with value 32 on channel 5 to all ports</code></pre>
          
            <pre><code>midi_cc 100, val_f: 0.8, channel: 5  #=> Sends MIDI cc message to control 100 with value 102 on channel 5 to all ports</code></pre>
          
            <pre><code>midi_cc 100, value: 102, channel: [1, 5]  #=> Sends MIDI cc message to control 100 with value 102 on channel 1 and 5 to all ports</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_channel_pressure">Send MIDI channel pressure (aftertouch) message</h2>
        <code><span class="function">midi_channel_pressure</span> val <span class="arg_type">(midi)</span></code>
        <p>The pressure value can be passed as a note such as <code>:e3</code> and decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3.</p>
<p>You may also optionally pass the pressure value as a floating point value between 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between 0 and 127) using the <code>val_f:</code> opt.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Channel Pressure (Aftertouch)</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>value</code></th>
              <td>Pressure value as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>val_f</code></th>
              <td>Pressure value as a value between 0 and 1 (will be converted to a MIDI value)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi channel pressure message from being sent out. (Ensures all opts are evaluated in this call to `midi_channel_pressure` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_channel_pressure</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_channel_pressure 50  #=> Sends MIDI channel pressure message with value 50 to all ports and channels</code></pre>
          
            <pre><code>midi_channel_pressure :C4  #=> Sends MIDI channel pressure message with value 60 to all ports and channels</code></pre>
          
            <pre><code>midi_channel_pressure 0.5  #=> Sends MIDI channel pressure message with value 63.5 to all ports and channels</code></pre>
          
            <pre><code>midi_channel_pressure 30, channel: [1, 5]  #=> Sends MIDI channel pressure message with value 30 on channel 1 and 5 to all ports</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_clock_beat">Send a quarter-note's worth of MIDI clock ticks</h2>
        <code><span class="function">midi_clock_beat</span> duration <span class="arg_type">(beats)</span></code>
        <p>The MIDI specification requires 24 clock tick events to be sent per beat. These can either be sent manually using <code>midi_clock_tick</code> or all 24 can be scheduled in one go using this fn. <code>midi_clock_beat</code> will therefore schedule for 24 clock ticks to be sent linearly spread over duration beats. This fn will automatically take into account the current BPM and any <code>time_warp</code>s.</p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi clock tick messages from being sent out. (Ensures all opts are evaluated in this call to `midi_clock_beat` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_clock_beat</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_clock_beat #=> Send 24 clock ticks over a period of 1 beat to all connected MIDI devices</code></pre>
          
            <pre><code>midi_clock_beat 0.5 #=> Send 24 clock ticks over a period of 0.5 beats to all connected MIDI devices</code></pre>
          
            <pre><code>midi_clock_beat port: "moog_subphatty" #=> Send 24 clock ticks over a period of 1 beat to just the MIDI port with name moog_subphatty</code></pre>
          
            <pre><code>
live_loop :clock do  # Create a live loop which continually sends out MIDI clock
  midi_clock_beat    # events at the current BPM
  sleep 1
end</code></pre>
          
            <pre><code># Ensuring Clock Phase is Correct
live_loop :clock do
  midi_start if tick == 0 # Send a midi_start event the first time round the live loop only
  midi_clock_beat         # this will not just send a steady clock beat, but also ensure
  sleep 1                 # the clock phase of the MIDI device matches Sonic Pi.
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_clock_tick">Send an individual MIDI clock tick</h2>
        <code><span class="function">midi_clock_tick</span> </code>
        <p>Typical MIDI devices expect the clock to send 24 ticks per quarter note (typically a beat). See <code>midi_clock_beat</code> for a simple way of sending all the ticks for a given beat.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - System Real-Time Messages - Timing Clock</a></p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi clock tick message from being sent out. (Ensures all opts are evaluated in this call to `midi_clock_tick` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_clock_tick</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_clock_tick #=> Send an individual clock tick to all connected MIDI devices on all ports.</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_continue">Send MIDI system message - continue</h2>
        <code><span class="function">midi_continue</span> </code>
        <p>Upon receiving the MIDI continue event, the MIDI device(s) will continue at the point the sequence was stopped.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - System Real-Time Messages - Continue</a></p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI Port(s) to send the continue message to</td>
            </tr>
          
            <caption>Options for midi_continue</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_continue #=> Send continue message to all connected MIDI devices</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_local_control_off">Disable local control on MIDI devices</h2>
        <code><span class="function">midi_local_control_off</span> </code>
        <p>All devices on a given channel will respond only to data received over MIDI. Played data, etc. will be ignored. See <code>midi_local_control_on</code> to enable local control.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - Local Control Off</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the local control off message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi local control off message from being sent out. (Ensures all opts are evaluated in this call to `midi_local_control_off` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_local_control_off</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_local_control_off #=> Disable local control on MIDI devices on all channels (and ports)</code></pre>
          
            <pre><code>midi_local_control_off channel: 2 #=> Disable local control on MIDI devices on channel 2</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_local_control_on">Enable local control on MIDI devices</h2>
        <code><span class="function">midi_local_control_on</span> </code>
        <p>All devices on a given channel will respond both to data received over MIDI and played data, etc. See <code>midi_local_control_off</code> to disable local control.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - Local Control On</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the local control on message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi local control on message from being sent out. (Ensures all opts are evaluated in this call to `midi_local_control_on` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_local_control_on</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_local_control_on #=> Enable local control on MIDI devices on all channels (and ports)</code></pre>
          
            <pre><code>midi_local_control_on channel: 2 #=> Enable local control on MIDI devices on channel 2</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_mode">Set Omni/Mono/Poly mode</h2>
        <code><span class="function">midi_mode</span> mode <span class="arg_type">(mode_keyword)</span></code>
        <p>Valid modes are:</p>
<ul>
<li>:omni_off - Omni Mode Off</li>
<li>:omni_on  - Omni Mode On</li>
<li>:mono     - Mono Mode On (Poly Off). Set num<em>chans: to be the number of channels to use (Omni Off) or 0 (Omni On). Default for num</em>chans: is 16.</li>
<li>:poly     - Poly Mode On (Mono Off)</li>
</ul>
<p>Note that this fn also includes the behaviour of <code>midi_all_notes_off</code>.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - Omni Mode Off &#47; Omni Mode On &#47; Mono Mode On (Poly Off) &#47; Poly Mode On</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the MIDI mode message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>mode</code></th>
              <td>Mode keyword - one of :omni_off, :omni_on, :mono or :poly</td>
            </tr>
          
            <tr>
              <th><code>num_chans</code></th>
              <td>Used in mono mode only - Number of channels (defaults to 16)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi local control off message from being sent out. (Ensures all opts are evaluated in this call to `midi_local_control_off` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_mode</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_mode :omni_on #=> Turn Omni Mode On on all ports and channels</code></pre>
          
            <pre><code>midi_mode :mono, num_chans: 5 #=> Mono Mode On, Omni off using 5 channels.</code></pre>
          
            <pre><code>midi_mode :mono, num_chans: 0 #=> Mono Mode On, Omni on.</code></pre>
          
            <pre><code>midi_mode :mono #=> Mono Mode On, Omni off using 16 channels (the default) .</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_note_off">Send MIDI note off message</h2>
        <code><span class="function">midi_note_off</span> note <span class="arg_type">(midi)</span>, release_velocity <span class="arg_type">(midi)</span></code>
        <p>Note and release velocity values can be passed as a note symbol such as <code>:e3</code> or a number. Decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3. These values will also be clipped within the range 0-&#62;127 so all values lower then 0 will be increased to 0 and all values greater than 127 will be reduced to 127.</p>
<p>The <code>release_velocity</code> param may be omitted - in which case it will default to 127 unless you supply it as a named opt via the keys <code>velocity:</code> or <code>vel_f:</code>.</p>
<p>You may also optionally pass the release velocity value as a floating point value between 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between 0 and 127) using the <code>vel_f:</code> opt.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Note off event</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on as a number or list of numbers.</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to as a string or list of strings.</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Release velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Release velocity as a value between 0 and 1 (will be converted to a MIDI velocity)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note off message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_off` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_note_off</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_note_off :e3 #=> Sends MIDI note off for note :e3 with the default release velocity of 127 to all ports and channels</code></pre>
          
            <pre><code>midi_note_off :e3, 12  #=> Sends MIDI note off for note :e3 with velocity 12 on all channels</code></pre>
          
            <pre><code>midi_note_off :e3, 12, channel: 3  #=> Sends MIDI note off for note :e3 with velocity 12 to channel 3</code></pre>
          
            <pre><code>midi_note_off :e3, velocity: 100 #=> Sends MIDI note off for note :e3 with release velocity 100</code></pre>
          
            <pre><code>midi_note_off :e3, vel_f: 0.8 #=> Scales release velocity 0.8 to MIDI value 102 and sends MIDI note off for note :e3 with release velocity 102</code></pre>
          
            <pre><code>midi_note_off 60.3, 50.5 #=> Rounds params up or down to the nearest whole number and sends MIDI note off for note 60 with release velocity 51</code></pre>
          
            <pre><code>midi_note_off :e3, channel: [1, 3, 5] #=> Send MIDI note off for note :e3 to channels 1, 3, 5 on all connected ports</code></pre>
          
            <pre><code>midi_note_off :e3, port: ["foo", "bar"] #=> Send MIDI note off for note :e3 to all channels on ports named "foo" and "bar"</code></pre>
          
            <pre><code>midi_note_off :e3, channel: 1, port: "foo" #=> Send MIDI note off for note :e3 only on channel 1 on port "foo"</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_note_on">Send MIDI note on message</h2>
        <code><span class="function">midi_note_on</span> note <span class="arg_type">(midi)</span>, velocity <span class="arg_type">(midi)</span></code>
        <p>Note and velocity values can be passed as a note symbol such as <code>:e3</code> or a MIDI number such as 52. Decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3. These values will also be clipped within the range 0-&#62;127 so all values lower than 0 will be increased to 0 and all values greater than 127 will be reduced to 127.</p>
<p>The <code>velocity</code> param may be omitted - in which case it will default to 127 unless you supply it as an opt via the keys <code>velocity:</code> or <code>vel_f:</code>.</p>
<p>You may also optionally pass the velocity value as a floating point value between 0 and 1 such as 0.2 or 0.785 (which will be linearly mapped to MIDI values between 0 and 127) using the vel_f: opt.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Note on event</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Note velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Velocity as a value between 0 and 1 (will be converted to a MIDI velocity between 0 and 127)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note on message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_on` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_note_on</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_note_on :e3  #=> Sends MIDI note on for note :e3 with the default velocity of 12 to all ports and channels</code></pre>
          
            <pre><code>midi_note_on :e3, 12  #=> Sends MIDI note on for note :e3 with velocity 12 to all channels</code></pre>
          
            <pre><code>midi_note_on :e3, 12, channel: 3  #=> Sends MIDI note on for note :e3 with velocity 12 on channel 3</code></pre>
          
            <pre><code>midi_note_on :e3, velocity: 100 #=> Sends MIDI note on for note :e3 with velocity 100</code></pre>
          
            <pre><code>midi_note_on :e3, vel_f: 0.8 #=> Scales velocity 0.8 to MIDI value 102 and sends MIDI note on for note :e3 with velocity 102</code></pre>
          
            <pre><code>midi_note_on 60.3, 50.5 #=> Rounds params up or down to the nearest whole number and sends MIDI note on for note 60 with velocity 51</code></pre>
          
            <pre><code>midi_note_on :e3, channel: [1, 3, 5] #=> Send MIDI note on for note :e3 to channels 1, 3, 5 on all connected ports</code></pre>
          
            <pre><code>midi_note_on :e3, port: ["foo", "bar"] #=> Send MIDI note on for note :e3 to all channels on ports named "foo" and "bar"</code></pre>
          
            <pre><code>midi_note_on :e3, channel: 1, port: "foo" #=> Send MIDI note on for note :e3 only on channel 1 on port "foo"</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_notes">Create a ring buffer of midi note numbers</h2>
        <code><span class="function">midi_notes</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new immutable ring buffer of notes from args. Indexes wrap around positively and negatively. Final ring consists only of MIDI numbers and nil.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(midi_notes :d3, :d4, :d5) #=> (ring 50, 62, 74)</code></pre>
          
            <pre><code>(midi_notes :d3, 62,  nil) #=> (ring 50, 62, nil)</code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="midi_pc">Send MIDI program change message</h2>
        <code><span class="function">midi_pc</span> program_num <span class="arg_type">(midi)</span></code>
        <p>Program number can be passed as a note such as <code>:e3</code> and decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Program change</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi pc message from being sent out. (Ensures all opts are evaluated in this call to `midi_pc` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_pc</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_pc 100  #=> Sends MIDI pc message to all ports and channels</code></pre>
          
            <pre><code>midi_pc :e7  #=> Sends MIDI pc message to all ports and channels</code></pre>
          
            <pre><code>midi_pc 100, channel: 5  #=> Sends MIDI pc message on channel 5 to all ports</code></pre>
          
            <pre><code>midi_pc 100, port: ["foo", "bar"], channel: 5  #=> Sends MIDI pc message on channel 5 to ports named "foo" and "bar"</code></pre>
          
            <pre><code>midi_pc 100, channel: [1, 5]  #=> Sends MIDI pc message on channel 1 and 5 to all ports</code></pre>
          
          </details>
        
        <p>Introduced in 3.1.0</p>
      </section>
    
      <section>
        <h2 id="midi_pitch_bend">Send MIDI pitch bend message</h2>
        <code><span class="function">midi_pitch_bend</span> delta <span class="arg_type">(float01)</span></code>
        <p>Delta value is between 0 and 1 with 0.5 representing no pitch bend, 1 max pitch bend and 0 minimum pitch bend.</p>
<p>Typical MIDI values such as note or cc are represented with 7 bit numbers which translates to the range 0-127. This makes sense for keyboards which have at most 88 keys. However, it translates to a poor resolution when working with pitch bend. Therefore, pitch bend is unlike most MIDI values in that it has a much greater range: 0 - 16383 (by virtue of being represented by 14 bits).</p>
<ul>
<li>It is also possible to specify the delta value as a (14 bit) MIDI pitch bend value between 0 and 16383 using the <code>delta_midi:</code> opt.</li>
<li>When using the <code>delta_midi:</code> opt no pitch bend is the value 8192</li>
</ul>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Pitch Bend Change</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>delta</code></th>
              <td>Pitch bend value as a number between 0 and 1 (will be converted to a value between 0 and 16383). No bend is the central value 0.5</td>
            </tr>
          
            <tr>
              <th><code>delta_midi</code></th>
              <td>Pitch bend value as a number between 0 and 16383 inclusively. No bend is central value 8192.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi pitch bend message from being sent out. (Ensures all opts are evaluated in this call to `midi_pitch_bend` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_pitch_bend</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_pitch_bend 0  #=> Sends MIDI pitch bend message with value 0 to all ports and channels</code></pre>
          
            <pre><code>midi_pitch_bend 1  #=> Sends MIDI pitch bend message with value 16383 to all ports and channels</code></pre>
          
            <pre><code>midi_pitch_bend 0.5  #=> Sends MIDI pitch bend message with value 8192 to all ports and channels</code></pre>
          
            <pre><code>midi_pitch_bend delta_midi: 8192  #=> Sends MIDI pitch bend message with value 8192 to all ports and channels</code></pre>
          
            <pre><code>midi_pitch_bend 0, channel: [1, 5]  #=> Sends MIDI pitch bend message with value 0 on channel 1 and 5 to all ports</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_poly_pressure">Send a MIDI polyphonic key pressure message</h2>
        <code><span class="function">midi_poly_pressure</span> note <span class="arg_type">(midi)</span>, value <span class="arg_type">(midi)</span></code>
        <p>Note number and pressure value can be passed as a note such as <code>:e3</code> and decimal values will be rounded down or up to the nearest whole number - so values between 3.5 and 4 will be rounded up to 4 and values between 3.49999&#8230; and 3 will be rounded down to 3.</p>
<p>You may also optionally pass the pressure value as a floating point value between 0 and 1 such as 0.2 or 0.785 (which will be mapped to MIDI values between 0 and 127) using the <code>val_f:</code> opt.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Voice Messages - Polyphonic Key Pressure (Aftertouch)</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>value</code></th>
              <td>Pressure value as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>val_f</code></th>
              <td>Pressure value as a value between 0 and 1 (will be converted to a MIDI value)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi poly pressure message from being sent out. (Ensures all opts are evaluated in this call to `midi_poly_pressure` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_poly_pressure</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_poly_pressure 100, 32  #=> Sends a MIDI poly key pressure message to control note 100 with value 32 to all ports and channels</code></pre>
          
            <pre><code>midi_poly_pressure :e7, 32  #=> Sends a MIDI poly key pressure message to control note 100 with value 32 to all ports and channels</code></pre>
          
            <pre><code>midi_poly_pressure 100, 32, channel: 5  #=> Sends MIDI poly key pressure message to control note 100 with value 32 on channel 5 to all ports</code></pre>
          
            <pre><code>midi_poly_pressure 100, val_f: 0.8, channel: 5  #=> Sends a MIDI poly key pressure message to control note 100 with value 102 on channel 5 to all ports</code></pre>
          
            <pre><code>midi_poly_pressure 100, value: 102, channel: [1, 5]  #=> Sends MIDI poly key pressure message to control note 100 with value 102 on channel 1 and 5 to all ports</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_raw">Send raw MIDI message</h2>
        <code><span class="function">midi_raw</span> </code>
        <p>Sends the raw MIDI message to <em>all</em> connected MIDI devices. Gives you direct access to sending the individual bytes of a MIDI message. Typically this should be rarely used - prefer the other <code>midi_</code> fns where possible.</p>
<p>A raw MIDI message consists of multiple bytes as numbers in decimal notation (i.e. 176), hex (0xb0) or binary (0b10110000).</p>
<p>See <a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">https:&#47;&#47;www.midi.org&#47;specifications-old&#47;item&#47;table-1-summary-of-midi-message</a> for a summary of MIDI messages and their corresponding byte structures.</p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>Port(s) to send the raw MIDI message events to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the raw midi message from being sent out. (Ensures all opts are evaluated in this call to `midi_raw` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_raw</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_raw 176, 121, 0  #=> Sends the MIDI reset command</code></pre>
          
            <pre><code>midi_raw 176.1, 120.5, 0.49  #=> Sends the MIDI reset command (values are rounded down, up and down respectively)</code></pre>
          
            <pre><code>midi_raw 0xb0, 0x79, 0x0  #=> Sends the MIDI reset command</code></pre>
          
            <pre><code>midi_raw 0b10110000, 0b01111001, 0b00000000  #=> Sends the MIDI reset command</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_reset">Reset MIDI devices</h2>
        <code><span class="function">midi_reset</span> value <span class="arg_type">(number)</span></code>
        <p>All controller values are reset to their defaults.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - Reset All Controllers</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the midi reset message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>value</code></th>
              <td>Value must only be zero (the default) unless otherwise allowed in a specific Recommended Practice</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi reset message from being sent out. (Ensures all opts are evaluated in this call to `midi_reset` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_reset</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_reset #=> Reset MIDI devices on all channels (and ports)</code></pre>
          
            <pre><code>midi_reset channel: 2 #=> Reset MIDI devices on channel 2</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_sound_off">Silence all MIDI devices</h2>
        <code><span class="function">midi_sound_off</span> </code>
        <p>All oscillators will turn off, and their volume envelopes are set to zero as soon as possible.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - Channel Mode Messages - All Sound Off</a></p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>Channel to send the sound off message to</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port to send to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi sound off on message from being sent out. (Ensures all opts are evaluated in this call to `midi_sound_off` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_sound_off</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_sound_off #=> Silence MIDI devices on all ports and channels</code></pre>
          
            <pre><code>midi_sound_off channel: 2 #=> Silence MIDI devices on channel 2</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_start">Send MIDI system message - start</h2>
        <code><span class="function">midi_start</span> </code>
        <p>Start the current sequence playing. (This message should be followed with calls to <code>midi_clock_tick</code> or <code>midi_clock_beat</code>).</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - System Real-Time Messages - Start</a></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_start #=> Send start message to all connected MIDI devices</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_stop">Send MIDI system message - stop</h2>
        <code><span class="function">midi_stop</span> </code>
        <p>Stops the current sequence.</p>
<p><a href="https://www.midi.org/specifications-old/item/table-1-summary-of-midi-message">MIDI 1.0 Specification - System Real-Time Messages - Start</a></p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI Port(s) to send the stop message to</td>
            </tr>
          
            <caption>Options for midi_stop</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_stop #=> Send stop message to all connected MIDI devices</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="midi_sysex">Send MIDI System Exclusive (SysEx) message</h2>
        <code><span class="function">midi_sysex</span> </code>
        <p>Sends the MIDI SysEx message to <em>all</em> connected MIDI devices.</p>
<p>MIDI SysEx messages, unlike all other MIDI messages, are variable in length. They allow MIDI device manufacturers to define device-specific messages, for example loading&#47;saving patches, or programming device features such as illuminated buttons.</p>
<p>Floats will be rounded up or down to the nearest whole number e.g. 176.1 -&#62; 176, 120.5 -&#62; 121, 0.49 -&#62; 0.</p>
<p>Non-number values will be automatically turned into numbers prior to sending the event if possible (if this conversion does not work an Error will be thrown).</p>

        
          <table>
          
            <tr>
              <th><code>port</code></th>
              <td>Port(s) to send the MIDI SysEx message events to</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi SysEx message from being sent out. (Ensures all opts are evaluated in this call to `midi_sysex` regardless of value).</td>
            </tr>
          
            <caption>Options for midi_sysex</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_sysex 0xf0, 0x00, 0x20, 0x6b, 0x7f, 0x42, 0x02, 0x00, 0x10, 0x77, 0x11, 0xf7  #=> Program an Arturia Beatstep controller to turn the eighth pad pink</code></pre>
          
          </details>
        
        <p>Introduced in 3.2.0</p>
      </section>
    
      <section>
        <h2 id="midi_to_hz">MIDI to Hz conversion</h2>
        <code><span class="function">midi_to_hz</span> note <span class="arg_type">(symbol_or_number)</span></code>
        <p>Convert a midi note to hz</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>midi_to_hz(60) #=> 261.6256</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="ndefine">Define a new function</h2>
        <code><span class="function">ndefine</span> name <span class="arg_type">(symbol)</span></code>
        <p>Does nothing. Use to stop a define from actually defining. Simpler than wrapping whole define in a comment block or commenting each individual line out.</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="note">Describe note</h2>
        <code><span class="function">note</span> note <span class="arg_type">(symbol_or_number)</span></code>
        <p>Takes a midi note, a symbol (e.g. <code>:C</code>) or a string (e.g. <code>"C"</code>) and resolves it to a midi note. You can also pass an optional <code>octave:</code> parameter to get the midi note for a given octave. Please note - <code>octave:</code> param overrides any octave specified in a symbol i.e. <code>:c3</code>. If the note is <code>nil</code>, <code>:r</code> or <code>:rest</code>, then <code>nil</code> is returned (<code>nil</code> represents a rest)</p>

        
          <table>
          
            <tr>
              <th><code>octave</code></th>
              <td>The octave of the note. Overrides any octave declaration in the note symbol such as :c2. Default is 4</td>
            </tr>
          
            <caption>Options for note</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# These all return 60 which is the midi number for middle C (octave 4)
puts note(60)
puts note(:C)
puts note(:C4)
puts note('C')</code></pre>
          
            <pre><code># returns 60 - octave param has no effect if we pass in a number
puts note(60, octave: 2)

# These all return 36 which is the midi number for C2 (two octaves below middle C)
puts note(:C, octave: 2)
puts note(:C4, octave: 2) # note the octave param overrides any octaves specified in a symbol
puts note('C', octave: 2)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="note_info">Get note info</h2>
        <code><span class="function">note_info</span> note <span class="arg_type">(symbol_or_number)</span></code>
        <p>Returns an instance of <code>Note</code>. Please note - <code>octave:</code> param overrides any octave specified in a symbol i.e. <code>:c3</code></p>

        
          <table>
          
            <tr>
              <th><code>octave</code></th>
              <td>The octave of the note. Overrides any octave declaration in the note symbol such as :c2. Default is 4</td>
            </tr>
          
            <caption>Options for note_info</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts note_info(:C, octave: 2)
# returns #<Note :C2></code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="note_range">Get a range of notes</h2>
        <code><span class="function">note_range</span> start_note <span class="arg_type">(note)</span>, end_note <span class="arg_type">(note)</span></code>
        <p>Produces a ring of all the notes between a start note and an end note. By default this is chromatic (all the notes) but can be filtered with a pitches: argument. This opens the door to arpeggiator style sequences and other useful patterns. If you try to specify only pitches which aren&#8217;t in the range it will raise an error - you have been warned!</p>

        
          <table>
          
            <tr>
              <th><code>pitches</code></th>
              <td>An array of notes (symbols or ints) to filter on. Octave information is ignored.</td>
            </tr>
          
            <caption>Options for note_range</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(note_range :c4, :c5) # => (ring 60,61,62,63,64,65,66,67,68,69,70,71,72)</code></pre>
          
            <pre><code>(note_range :c5, :c4) # => (ring 72,71,70,69,68,67,66,65,64,63,62,61,60)</code></pre>
          
            <pre><code>(note_range :c4, :c5, pitches: (chord :c, :major)) # => (ring 60,64,67,72)</code></pre>
          
            <pre><code>(note_range :c4, :c6, pitches: (chord :c, :major)) # => (ring 60,64,67,72,76,79,84)</code></pre>
          
            <pre><code>(note_range :c4, :c5, pitches: (scale :c, :major)) # => (ring 60,62,64,65,67,69,71,72)</code></pre>
          
            <pre><code>(note_range :c4, :c5, pitches: [:c4, :g2]) # => (ring 60,67,72)</code></pre>
          
            <pre><code>live_loop :arpeggiator do
  # try changing the chord
  play (note_range :c4, :c5, pitches: (chord :c, :major)).tick
  sleep 0.125
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="octs">Create a ring of octaves</h2>
        <code><span class="function">octs</span> start <span class="arg_type">(note)</span>, num_octaves <span class="arg_type">(pos_int)</span></code>
        <p>Create a ring of successive octaves starting at <code>start</code> for <code>num_octaves</code>. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(octs 60, 2)  #=> (ring 60, 72)</code></pre>
          
            <pre><code>(octs :e3, 3) #=> (ring 52, 64, 76)</code></pre>
          
          </details>
        
        <p>Introduced in 2.8.0</p>
      </section>
    
      <section>
        <h2 id="on">Optionally evaluate block</h2>
        <code><span class="function">on</span> condition <span class="arg_type">(truthy)</span></code>
        <p>Optionally evaluate the block depending on the truthiness of the supplied condition. The truthiness rules are as follows: all values are seen as true except for: false, nil and 0. Lambdas will be automatically called and the truthiness of their results used.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
on true do
  play 70     #=> will play 70 as true is truthy
end</code></pre>
          
            <pre><code>
on 1 do
  play 70     #=> will play 70 as 1 is truthy
end</code></pre>
          
            <pre><code>
on 0 do
  play 70     #=> will *not* play 70 as 0 is not truthy
end</code></pre>
          
            <pre><code>
on false do
  play 70     #=> will *not* play 70 as false is not truthy
end</code></pre>
          
            <pre><code>
on nil do
  play 70     #=> will *not* play 70 as nil is not truthy
end</code></pre>
          
            <pre><code>
on lambda{true} do
  play 70     #=> will play 70 as the lambda returns a truthy value
end</code></pre>
          
            <pre><code>
on lambda{false} do
  play 70     #=> will *not* play 70 as the lambda does not return a truthy value
end</code></pre>
          
            <pre><code>
on lambda{[true, false].choose} do
  play 70     #=> will maybe play 70 depending on the choice in the lambda
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="one_in">Random true value with specified probability</h2>
        <code><span class="function">one_in</span> num <span class="arg_type">(number)</span></code>
        <p>Returns <code>true</code> or <code>false</code> with a specified probability - it will return true every one in num times where num is the param you specify</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  one_in 2 # will return true with a probability of 1/2, false with probability 1/2</code></pre>
          
            <pre><code>
  one_in 3 # will return true with a probability of 1/3, false with a probability of 2/3</code></pre>
          
            <pre><code>
  one_in 100 # will return true with a probability of 1/100, false with a probability of 99/100</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="osc">Send an OSC message (Open Sound Control)</h2>
        <code><span class="function">osc</span> path <span class="arg_type">(arguments)</span></code>
        <p>Sends an OSC message to the current host and port specified by <code>use_osc</code> or <code>with_osc</code>.</p>
<p>OSC (Open Sound Control) is a simple way of passing messages between two separate programs on the same computer or even on different computers via a local network or even the internet. <code>osc</code> enables you to send well-timed OSC messages from within Sonic Pi. <code>osc</code> will ensure that the OSC message is sent at the correct time using the same timing system shared with the synthesis functionality via <code>sample</code>, <code>synth</code> and friends. <code>osc</code> even works seamlessly within <code>time_warp</code> - see examples.</p>
<p>A typical OSC message has two parts: a descriptive <code>path</code> which looks similar to a URL (website address), and an optional list of <code>arguments</code> that are either numbers or strings.</p>
<p>For example, a hypothetical synth program might accept this OSC message:</p>
<p><code>&#47;set&#47;filter lowpass 80 0.5</code></p>
<p>where <code>&#47;set&#47;filter</code> is the path, and <code>lowpass</code>, <code>80</code>, and <code>0.5</code> are three
arguments. This can be sent from within Sonic Pi by writing:</p>
<p><code>osc "&#47;set&#47;filter", "lowpass", 80, 0.5</code></p>
<p>However, in order to send the OSC message you must first specify where to send it to. This is achieved by specifying both the host (the machine&#8217;s internet address) and the port that the remote OSC server is listening on. This is configured using <code>use_osc</code> or <code>with_osc</code>. So, if our synth program was running on a machine on the local network with IP address <code>10.0.1.5</code> on port <code>5100</code> we could send our OSC message to it with the following:</p>
<p><code>use_osc "10.0.1.5", 5100</code></p>
<p><code>osc "&#47;set&#47;filter", "lowpass", 80, 0.5</code></p>
<p>Note, by default, Sonic Pi listens for OSC messages on port <code>4560</code>, so you may send messages to an external machine running Sonic Pi if you know the IP address of that external machine. Any OSC messages received on port <code>4560</code> are automatically converted to standard cue events and displayed in the GUI&#8217;s cue log. This also means that you can use <code>sync</code> to wait for the next incoming OSC message with a given path (see example).</p>
<p>Finally, it is also very useful to send OSC messages to other programs on the same computer. This can be achieved by specifying &#8220;localhost&#8221; as the hostname and the port as normal (depending on which port the other program is listening on).</p>
<p>See <code>osc_send</code> for a version which allows you to specify the hostname and port directly (ignoring any values set via <code>use_osc</code> or <code>with_osc</code>).</p>
<p>For further information see the OSC spec: <a href="https://opensoundcontrol.stanford.edu/spec-1_0.html">https:&#47;&#47;opensoundcontrol.stanford.edu&#47;spec-1_0.html</a></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code> # Send a simple OSC message to another program on the same machine

use_osc "localhost", 7000  # Specify port 7000 on this machine
osc "/foo/bar"             # Send an OSC message with path "/foo/bar"
                             # and no arguments</code></pre>
          
            <pre><code> # Send an OSC message with arguments to another program on the same machine

use_osc "localhost", 7000        # Specify port 7000 on this machine
osc "/foo/bar", 1, 3.89, "baz" # Send an OSC message with path "/foo/bar"
                                   # and three arguments:
                                   # 1) The whole number (integer) 1
                                   # 2) The fractional number (float) 3.89
                                   # 3) The string "baz"</code></pre>
          
            <pre><code> # Send an OSC message with arguments to another program on a different machine

use_osc "10.0.1.5", 7000         # Specify port 7000 on the machine with address 10.0.1.5
osc "/foo/bar", 1, 3.89, "baz" # Send an OSC message with path "/foo/bar"
                                   # and three arguments:
                                   # 1) The whole number (integer) 1
                                   # 2) The fractional number (float) 3.89
                                   # 3) The string "baz"</code></pre>
          
            <pre><code> # OSC messages honour the timing system

osc "/foo/bar"       # Send an OSC message with path /foo/bar at *exactly* the
play 60                # same time as note 60 is played

sleep 1                # Wait for 1 beat

osc "/baz/quux"       # Send an OSC message with path /baz/quux at *exactly* the
play 72                 # same time as note 72 is played</code></pre>
          
            <pre><code> # Send a incrementing OSC counter

live_loop :foo do             # Start a live loop called :foo
  osc "/counter", tick      # Send an OSC message with the path /counter
                              # with successive whole numbers (0, 1, 2, 3.. etc.)
                              # each time round the live loop
  sleep 1                     # Repeat the live loop every 1 beat
end</code></pre>
          
            <pre><code> # OSC messages can be sent from within time_warp

time_warp 0.5 do
  osc "/foo/bar"       # Send an OSC message with path /foo/bar at 0.5 beats
end

sleep 1                  # Wait for 1 beat

time_warp -0.1 do
  osc "/baz/quux"      # Send an OSC message with path /baz/quux at 0.9 beats
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="osc_send">Send an OSC message to a specific host and port</h2>
        <code><span class="function">osc_send</span> hostname <span class="arg_type">(string)</span>, port <span class="arg_type">(number)</span>, path <span class="arg_type">(osc_path)</span>, args <span class="arg_type">(list)</span></code>
        <p>Similar to <code>osc</code> except ignores any <code>use_osc</code> settings and sends the OSC message directly to the specified <code>hostname</code> and <code>port</code>.</p>
<p>See <code>osc</code> for more information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
osc_send "localhost", 7000, "/foo/baz"  # Send an OSC message to port 7000 on the same machine</code></pre>
          
            <pre><code>
use_osc "localhost", 7010                 # set hostname and port
osc "/foo/baz"                            # Send an OSC message to port 7010

osc_send "localhost", 7000, "/foo/baz"  # Send an OSC message to port 7000
                                            # (ignores use_osc settings)
</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="pick">Randomly pick from list (with duplicates)</h2>
        <code><span class="function">pick</span> list <span class="arg_type">(array)</span>, n <span class="arg_type">(number_or_nil)</span></code>
        <p>Pick n elements from list or ring. Unlike shuffle, after each element has been picked, it is &#8216;returned&#8217; to the list so it may be picked again. This means there may be duplicates in the result. If n is greater than the size of the ring&#47;list then duplicates are guaranteed to be in the result.</p>
<p>If <code>n</code> isn&#8217;t supplied it defaults to a size of 1.</p>
<p>If no arguments are given, will return a lambda function which when called takes an argument which will be a list to be picked from. This is useful for choosing random <code>onset:</code> vals for samples.</p>
<p>Always returns a list-like thing (either an array or ring)</p>

        
          <table>
          
            <tr>
              <th><code>skip</code></th>
              <td>Number of rands to skip over with each successive pick</td>
            </tr>
          
            <caption>Options for pick</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts [1, 2, 3, 4, 5].pick(3) #=> [4, 4, 3]</code></pre>
          
            <pre><code>
puts (ring 1, 2, 3, 4, 5).pick(3) #=> (ring 4, 4, 3)</code></pre>
          
            <pre><code>
puts (ring 1, 2).pick(5) #=> (ring 2, 2, 1, 1, 1)</code></pre>
          
            <pre><code>
puts (ring 1, 2, 3).pick #=> (ring 3)</code></pre>
          
            <pre><code>
# Using pick for random sample onsets
live_loop :foo do
  sample :loop_amen, onset: pick   # pick a random onset value each time
  sleep 0.125
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="pitch_to_ratio">relative MIDI pitch to frequency ratio</h2>
        <code><span class="function">pitch_to_ratio</span> pitch <span class="arg_type">(midi_number)</span></code>
        <p>Convert a midi note to a ratio which when applied to a frequency will scale the frequency by the number of semitones. Useful for changing the pitch of a sample by using it as a way of generating the rate.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>pitch_to_ratio 12 #=> 2.0</code></pre>
          
            <pre><code>pitch_to_ratio 1 #=> 1.05946</code></pre>
          
            <pre><code>pitch_to_ratio -12 #=> 0.5</code></pre>
          
            <pre><code>sample :ambi_choir, rate: pitch_to_ratio(3) # Plays :ambi_choir 3 semitones above default.</code></pre>
          
            <pre><code>
# Play a chromatic scale of semitones
(range 0, 16).each do |n|                  # For each note in the range 0->16
  sample :ambi_choir, rate: pitch_to_ratio(n) # play :ambi_choir at the relative pitch
  sleep 0.5                                # and wait between notes
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="play">Play current synth</h2>
        <code><span class="function">play</span> note <span class="arg_type">(symbol_or_number)</span></code>
        <p>If <code>duration:</code> is supplied and <code>sustain:</code> isn&#8217;t, it causes <code>sustain:</code> to be set so that all four phases add up to the duration.</p>
<p>Accepts optional args for modification of the synth being played. See each synth&#8217;s documentation for synth-specific opts. See <code>use_synth</code> and <code>with_synth</code> for changing the current synth.</p>
<p>If note is <code>nil</code>, <code>:r</code> or <code>:rest</code>, play is ignored and treated as a rest. Also, if the <code>on:</code> opt is specified and returns <code>false</code>, or <code>nil</code> then play is similarly ignored and treated as a rest.</p>
<p>Note that the default opts listed are only a guide to the most common opts across all the synths. Not all synths support all the default opts and each synth typically supports many more opts specific to that synth. For example, the <code>:tb303</code> synth supports 45 unique opts. For a full list of a synth&#8217;s opts see its documentation in the Help system.</p>

        
          <table>
          
            <tr>
              <th><code>amp</code></th>
              <td>The amplitude of the note</td>
            </tr>
          
            <tr>
              <th><code>amp_slide</code></th>
              <td>The duration in beats for amplitude changes to take place</td>
            </tr>
          
            <tr>
              <th><code>pan</code></th>
              <td>The stereo position of the sound. -1 is left, 0 is in the middle and 1 is on the right. You may use a value in between -1 and 1 such as 0.25</td>
            </tr>
          
            <tr>
              <th><code>pan_slide</code></th>
              <td>The duration in beats for the pan value to change</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Amount of time (in beats) for sound to reach full amplitude (attack_level). A short attack (i.e. 0.01) makes the initial part of the sound very percussive like a sharp tap. A longer attack (i.e 1) fades the sound in gently.</td>
            </tr>
          
            <tr>
              <th><code>decay</code></th>
              <td>Amount of time (in beats) for the sound to move from full amplitude (attack_level) to the sustain amplitude (sustain_level).</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Amount of time (in beats) for sound to remain at sustain level amplitude. Longer sustain values result in longer sounds. Full length of sound is attack + decay + sustain + release.</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Amount of time (in beats) for sound to move from sustain level amplitude to silent. A short release (i.e. 0.01) makes the final part of the sound very percussive (potentially resulting in a click). A longer release (i.e 1) fades the sound out gently.</td>
            </tr>
          
            <tr>
              <th><code>attack_level</code></th>
              <td>Amplitude level reached after attack phase and immediately before decay phase</td>
            </tr>
          
            <tr>
              <th><code>decay_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before sustain phase. Defaults to sustain_level unless explicitly set</td>
            </tr>
          
            <tr>
              <th><code>sustain_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before release phase.</td>
            </tr>
          
            <tr>
              <th><code>env_curve</code></th>
              <td>Select the shape of the curve between levels in the envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed</td>
            </tr>
          
            <tr>
              <th><code>slide</code></th>
              <td>Default slide time in beats for all slide opts. Individually specified slide opts will override this value</td>
            </tr>
          
            <tr>
              <th><code>pitch</code></th>
              <td>Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc.  Decimal numbers can be used for fine tuning.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the synth from being played. Ensures all opts are evaluated.</td>
            </tr>
          
            <caption>Options for play</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50 on the current synth</code></pre>
          
            <pre><code>play 50, attack: 1 # Plays note 50 with a fade-in time of 1s</code></pre>
          
            <pre><code>play 62, pan: -1, release: 3 # Play note 62 in the left ear with a fade-out time of 3s.</code></pre>
          
            <pre><code> # controlling a synth synchronously
s = play :e3, release: 4
sleep 1
control s, note: :e5
sleep 0.5
use_synth :dsaw
play :e3   # This is triggered after 1.5s from start</code></pre>
          
            <pre><code> # Controlling a synth asynchronously
play :e3, release: 4 do |s|
  sleep 1                                               # This block is run in an implicit in_thread
  control s, note: :e5                                  # and therefore is asynchronous
end

sleep 0.5
use_synth :dsaw
play :e3 # This is triggered after 0.5s from start</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="play_chord">Play notes simultaneously</h2>
        <code><span class="function">play_chord</span> notes <span class="arg_type">(list)</span></code>
        <p>Play a list of notes at the same time.</p>
<p>Accepts optional args for modification of the synth being played. See each synth&#8217;s documentation for synth-specific opts. See <code>use_synth</code> and <code>with_synth</code> for changing the current synth.</p>

        
          <table>
          
            <tr>
              <th><code>amp</code></th>
              <td>The amplitude of the note</td>
            </tr>
          
            <tr>
              <th><code>amp_slide</code></th>
              <td>The duration in beats for amplitude changes to take place</td>
            </tr>
          
            <tr>
              <th><code>pan</code></th>
              <td>The stereo position of the sound. -1 is left, 0 is in the middle and 1 is on the right. You may use a value in between -1 and 1 such as 0.25</td>
            </tr>
          
            <tr>
              <th><code>pan_slide</code></th>
              <td>The duration in beats for the pan value to change</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Amount of time (in beats) for sound to reach full amplitude (attack_level). A short attack (i.e. 0.01) makes the initial part of the sound very percussive like a sharp tap. A longer attack (i.e 1) fades the sound in gently.</td>
            </tr>
          
            <tr>
              <th><code>decay</code></th>
              <td>Amount of time (in beats) for the sound to move from full amplitude (attack_level) to the sustain amplitude (sustain_level).</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Amount of time (in beats) for sound to remain at sustain level amplitude. Longer sustain values result in longer sounds. Full length of sound is attack + decay + sustain + release.</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Amount of time (in beats) for sound to move from sustain level amplitude to silent. A short release (i.e. 0.01) makes the final part of the sound very percussive (potentially resulting in a click). A longer release (i.e 1) fades the sound out gently.</td>
            </tr>
          
            <tr>
              <th><code>attack_level</code></th>
              <td>Amplitude level reached after attack phase and immediately before decay phase</td>
            </tr>
          
            <tr>
              <th><code>decay_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before sustain phase. Defaults to sustain_level unless explicitly set</td>
            </tr>
          
            <tr>
              <th><code>sustain_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before release phase.</td>
            </tr>
          
            <tr>
              <th><code>env_curve</code></th>
              <td>Select the shape of the curve between levels in the envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed</td>
            </tr>
          
            <tr>
              <th><code>slide</code></th>
              <td>Default slide time in beats for all slide opts. Individually specified slide opts will override this value</td>
            </tr>
          
            <tr>
              <th><code>pitch</code></th>
              <td>Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc.  Decimal numbers can be used for fine tuning.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the synth from being played. Ensures all opts are evaluated.</td>
            </tr>
          
            <caption>Options for play_chord</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play_chord [40, 45, 47]

# same as:

play 40
play 45
play 47</code></pre>
          
            <pre><code>play_chord [40, 45, 47], amp: 0.5

# same as:

play 40, amp: 0.5
play 45, amp: 0.5
play 47, amp: 0.5</code></pre>
          
            <pre><code>play_chord chord(:e3, :minor)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="play_pattern">Play pattern of notes</h2>
        <code><span class="function">play_pattern</span> notes <span class="arg_type">(list)</span></code>
        <p>Play list of notes with the current synth one after another with a sleep of 1</p>
<p>Accepts optional args for modification of the synth being played. See each synth&#8217;s documentation for synth-specific opts. See use<em>synth and with</em>synth for changing the current synth.</p>

        
          <table>
          
            <caption>Options for play_pattern</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play_pattern [40, 41, 42] # Same as:
                          #   play 40, sustain: 1
                          #   sleep 1
                          #   play 41, sustain: 1
                          #   sleep 1
                          #   play 42, sustain: 1
                          #   sleep 1</code></pre>
          
            <pre><code>play_pattern [:d3, :c1, :Eb5] # You can use keyword notes</code></pre>
          
            <pre><code>play_pattern [:d3, :c1, :Eb5], amp: 0.5, cutoff: 90 # Supports the same arguments as play:</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="play_pattern_timed">Play pattern of notes with specific times</h2>
        <code><span class="function">play_pattern_timed</span> notes <span class="arg_type">(list)</span>, times <span class="arg_type">(list_or_number)</span></code>
        <p>If the list of times is smaller than the number of notes, the list is repeated again. If the list of times is longer than the number of notes, then some of the times are ignored. See examples for more detail.</p>
<p>Accepts optional args for modification of the synth being played. See each synth&#8217;s documentation for synth-specific opts. See <code>use_synth</code> and <code>with_synth</code> for changing the current synth.</p>

        
          <table>
          
            <tr>
              <th><code>amp</code></th>
              <td>The amplitude of the note</td>
            </tr>
          
            <tr>
              <th><code>amp_slide</code></th>
              <td>The duration in beats for amplitude changes to take place</td>
            </tr>
          
            <tr>
              <th><code>pan</code></th>
              <td>The stereo position of the sound. -1 is left, 0 is in the middle and 1 is on the right. You may use a value in between -1 and 1 such as 0.25</td>
            </tr>
          
            <tr>
              <th><code>pan_slide</code></th>
              <td>The duration in beats for the pan value to change</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Amount of time (in beats) for sound to reach full amplitude (attack_level). A short attack (i.e. 0.01) makes the initial part of the sound very percussive like a sharp tap. A longer attack (i.e 1) fades the sound in gently.</td>
            </tr>
          
            <tr>
              <th><code>decay</code></th>
              <td>Amount of time (in beats) for the sound to move from full amplitude (attack_level) to the sustain amplitude (sustain_level).</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Amount of time (in beats) for sound to remain at sustain level amplitude. Longer sustain values result in longer sounds. Full length of sound is attack + decay + sustain + release.</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Amount of time (in beats) for sound to move from sustain level amplitude to silent. A short release (i.e. 0.01) makes the final part of the sound very percussive (potentially resulting in a click). A longer release (i.e 1) fades the sound out gently.</td>
            </tr>
          
            <tr>
              <th><code>attack_level</code></th>
              <td>Amplitude level reached after attack phase and immediately before decay phase</td>
            </tr>
          
            <tr>
              <th><code>decay_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before sustain phase. Defaults to sustain_level unless explicitly set</td>
            </tr>
          
            <tr>
              <th><code>sustain_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before release phase.</td>
            </tr>
          
            <tr>
              <th><code>env_curve</code></th>
              <td>Select the shape of the curve between levels in the envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed</td>
            </tr>
          
            <tr>
              <th><code>slide</code></th>
              <td>Default slide time in beats for all slide opts. Individually specified slide opts will override this value</td>
            </tr>
          
            <tr>
              <th><code>pitch</code></th>
              <td>Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc.  Decimal numbers can be used for fine tuning.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the synth from being played. Ensures all opts are evaluated.</td>
            </tr>
          
            <caption>Options for play_pattern_timed</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play_pattern_timed [40, 42, 44], [1, 2, 3]

# same as:

play 40, sustain: 1
sleep 1
play 42, sustain: 2
sleep 2
play 44, sustain: 3
sleep 3</code></pre>
          
            <pre><code>play_pattern_timed [40, 42, 44, 46, 49], [1, 0.5]

# same as:

play 40, sustain: 1
sleep 1
play 42, sustain: 0.5
sleep 0.5
play 44, sustain: 1
sleep 1
play 46, sustain: 0.5
sleep 0.5
play 49, sustain: 1
sleep 1</code></pre>
          
            <pre><code>play_pattern_timed [40, 42, 44, 46], [0.5]

# same as:

play 40, sustain: 0.5
sleep 0.5
play 42, sustain: 0.5
sleep 0.5
play 44, sustain: 0.5
sleep 0.5
play 46, sustain: 0.5
sleep 0.5</code></pre>
          
            <pre><code>play_pattern_timed [40, 42, 44], [1, 2, 3, 4, 5]

# same as:

play 40, sustain: 1
sleep 1
play 42, sustain: 2
sleep 2
play 44, sustain: 3
sleep 3</code></pre>
          
            <pre><code>play_pattern_timed [40, 42, 44], [1, 2, 3], sustain: 0

# effectively same as:

play 40
sleep 1
play 42
sleep 2
play 44
sleep 3</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="print">Display a message in the output pane</h2>
        <code><span class="function">print</span> output <span class="arg_type">(anything)</span></code>
        <p>Displays the information you specify as a string inside the output pane. This can be a number, symbol, or a string itself. Useful for debugging. Synonym for <code>puts</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>print "hello there"   #=> will print the string "hello there" to the output pane</code></pre>
          
            <pre><code>print 5               #=> will print the number 5 to the output pane</code></pre>
          
            <pre><code>print foo             #=> will print the contents of foo to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="puts">Display a message in the output pane</h2>
        <code><span class="function">puts</span> output <span class="arg_type">(anything)</span></code>
        <p>Displays the information you specify as a string inside the output pane. This can be a number, symbol, or a string itself. Useful for debugging. Synonym for <code>print</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>print "hello there"   #=> will print the string "hello there" to the output pane</code></pre>
          
            <pre><code>print 5               #=> will print the number 5 to the output pane</code></pre>
          
            <pre><code>print foo             #=> will print the contents of foo to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="quantise">Quantise a value to resolution</h2>
        <code><span class="function">quantise</span> n <span class="arg_type">(number)</span>, step <span class="arg_type">(positive_number)</span></code>
        <p>Round value to the nearest multiple of step resolution.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  quantise(10, 1) # 10 is already a multiple of 1, so returns 10</code></pre>
          
            <pre><code>
  quantise(10, 1.1) # Returns 9.9 which is 1.1 * 9</code></pre>
          
            <pre><code>
  quantise(13.3212, 0.1) # 13.3</code></pre>
          
            <pre><code>
  quantise(13.3212, 0.2) # 13.4</code></pre>
          
            <pre><code>
  quantise(13.3212, 0.3) # 13.2</code></pre>
          
            <pre><code>
  quantise(13.3212, 0.5) # 13.5</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="ramp">Create a ramp vector</h2>
        <code><span class="function">ramp</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new immutable ramp vector from args. Indexes always return first or last value if out of bounds.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(ramp 1, 2, 3)[0] #=> 1</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[1] #=> 2</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[2] #=> 3</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[3] #=> 3</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[1000] #=> 3</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[-1] #=> 1</code></pre>
          
            <pre><code>(ramp 1, 2, 3)[-1000] #=> 1</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="rand">Generate a random float below a value</h2>
        <code><span class="function">rand</span> max <span class="arg_type">(number_or_range)</span></code>
        <p>Given a max number, produces a float between <code>0</code> and the supplied max value. If max is a range, produces a float within the range. With no args returns a random value between <code>0</code> and <code>1</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  print rand(0.5) #=> will print a number like 0.375030517578125 to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="rand_back">Roll back random generator</h2>
        <code><span class="function">rand_back</span> amount <span class="arg_type">(number)</span></code>
        <p>Roll the random generator back essentially &#8216;undoing&#8217; the last call to <code>rand</code>. You may specify an amount to roll back allowing you to skip back n calls to <code>rand</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Basic rand stream rollback

  puts rand # prints 0.75006103515625

  rand_back # roll random stream back one
            # the result of the next call to rand will be
            # exactly the same as the previous call

  puts rand # prints 0.75006103515625 again!
  puts rand # prints 0.733917236328125</code></pre>
          
            <pre><code>
  # Jumping back multiple places in the rand stream

  puts rand # prints 0.75006103515625
  puts rand # prints 0.733917236328125
  puts rand # prints 0.464202880859375
  puts rand # prints 0.24249267578125

  rand_back(3) # roll random stream back three places
               # the result of the next call to rand will be
               # exactly the same as the result 3 calls to
               # rand ago.

  puts rand # prints  0.733917236328125 again!
  puts rand # prints  0.464202880859375</code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="rand_i">Generate a random whole number below a value (exclusive)</h2>
        <code><span class="function">rand_i</span> max <span class="arg_type">(number_or_range)</span></code>
        <p>Given a max number, produces a whole number between <code>0</code> and the supplied max value exclusively. If max is a range produces an int within the range. With no args returns either <code>0</code> or <code>1</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  print rand_i(5) #=> will print either 0, 1, 2, 3, or 4 to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="rand_i_look">Generate a random whole number without consuming a rand</h2>
        <code><span class="function">rand_i_look</span> max <span class="arg_type">(number_or_range)</span></code>
        <p>Given a max number, produces a whole number between <code>0</code> and the supplied max value exclusively. If max is a range produces an int within the range. With no args returns either <code>0</code> or <code>1</code>.</p>
<p>Does not consume a random value from the stream. Therefore, multiple sequential calls to <code>rand_i_look</code> will all return the same value.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
print rand_i_look(5) # will print either 0, 1, 2, 3, or 4 to the output pane</code></pre>
          
            <pre><code>
print rand_i_look(5) # will print either 0, 1, 2, 3, or 4 to the output pane
print rand_i_look(5) # will print the same number again
print rand_i_look(5) # will print the same number again
print rand_i(5) # will still print the same number again
                # (this is the number rand_i_look was 'looking ahead' at)
                # the number is now consumed
print rand_i_look(5) # will print either 0, 1, 2, 3, or 4 to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="rand_look">Generate a random number without consuming a rand</h2>
        <code><span class="function">rand_look</span> max <span class="arg_type">(number_or_range)</span></code>
        <p>Given a max number, produces a number between <code>0</code> and the supplied max value exclusively. If max is a range produces an int within the range. With no args returns a value between <code>0</code> and <code>1</code>.</p>
<p>Does not consume a random value from the stream. Therefore, multiple sequential calls to <code>rand_look</code> will all return the same value.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
print rand_look(0.5) # will print a number like 0.375030517578125 to the output pane</code></pre>
          
            <pre><code>
print rand_look(0.5) # will print a number like 0.375030517578125 to the output pane
print rand_look(0.5) # will print the same number again
print rand_look(0.5) # will print the same number again
print rand(0.5) # will still print the same number again
                # (this is the number rand_look was 'looking ahead' at)
                # the number is now consumed
print rand_look(0.5) # will print a new number like 0.3669586181640625 to the output pane</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="rand_reset">Reset rand generator to last seed</h2>
        <code><span class="function">rand_reset</span> </code>
        <p>Resets the random stream to the last specified seed. See <code>use_random_seed</code> for changing the seed.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts rand # prints 0.75006103515625
  puts rand # prints 0.733917236328125
  puts rand # prints 0.464202880859375
  puts rand # prints 0.24249267578125
  rand_reset  # reset the random stream
  puts rand # prints 0.75006103515625
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="rand_skip">Jump forward random generator</h2>
        <code><span class="function">rand_skip</span> amount <span class="arg_type">(number)</span></code>
        <p>Jump the random generator forward essentially skipping the next call to <code>rand</code>. You may specify an amount to jump allowing you to skip n calls to <code>rand</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Basic rand stream skip

  puts rand # prints 0.75006103515625

  rand_skip # jump random stream forward one
            # typically the next rand is 0.733917236328125

  puts rand # prints 0.464202880859375</code></pre>
          
            <pre><code>
  # Jumping forward multiple places in the rand stream

  puts rand # prints 0.75006103515625
  puts rand # prints 0.733917236328125
  puts rand # prints 0.464202880859375
  puts rand # prints 0.24249267578125

  rand_reset  # reset the random stream

  puts rand # prints 0.75006103515625

  rand_skip(2) # jump random stream forward three places
               # the result of the next call to rand will be
               # exactly the same as if rand had been called
               # three times

  puts rand 0.24249267578125</code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="range">Create a ring buffer with the specified start, finish and step size</h2>
        <code><span class="function">range</span> start <span class="arg_type">(number)</span>, finish <span class="arg_type">(number)</span>, step_size <span class="arg_type">(number)</span></code>
        <p>Create a new ring buffer from the range arguments (start, finish and step size). Step size defaults to <code>1</code>. Indexes wrap around positively and negatively</p>

        
          <table>
          
            <tr>
              <th><code>step</code></th>
              <td>Size of increment between steps; step size.</td>
            </tr>
          
            <tr>
              <th><code>inclusive</code></th>
              <td>If set to true, range is inclusive of finish value</td>
            </tr>
          
            <caption>Options for range</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(range 1, 5)    #=> (ring 1, 2, 3, 4)</code></pre>
          
            <pre><code>(range 1, 5, inclusive: true) #=> (ring 1, 2, 3, 4, 5)</code></pre>
          
            <pre><code>(range 1, 5, step: 2) #=> (ring 1, 3)</code></pre>
          
            <pre><code>(range 1, -5, step: 2) #=> (ring 1, -1, -3)</code></pre>
          
            <pre><code>(range 1, -5, step: 2)[-1] #=> -3</code></pre>
          
          </details>
        
        <p>Introduced in 2.2.0</p>
      </section>
    
      <section>
        <h2 id="ratio_to_pitch">relative frequency ratio to MIDI pitch</h2>
        <code><span class="function">ratio_to_pitch</span> ratio <span class="arg_type">(number)</span></code>
        <p>Convert a frequency ratio to a midi note which when added to a note will transpose the note to match the frequency ratio.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>ratio_to_pitch 2 #=> 12.0</code></pre>
          
            <pre><code>ratio_to_pitch 0.5 #=> -12.0</code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="rdist">Random number in centred distribution</h2>
        <code><span class="function">rdist</span> width <span class="arg_type">(number)</span>, centre <span class="arg_type">(number)</span></code>
        <p>Returns a random number within the range with width around centre. If optional arg <code>step:</code> is used, the result is quantised by step.</p>

        
          <table>
          
            <tr>
              <th><code>step</code></th>
              <td>Step size of value to quantise to.</td>
            </tr>
          
            <caption>Options for rdist</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  print rdist(1, 0) #=> will print a number between -1 and 1
  </code></pre>
          
            <pre><code>
  print rdist(1) #=> centre defaults to 0 so this is the same as rdist(1, 0)
  </code></pre>
          
            <pre><code>
  loop do
    play :c3, pan: rdist(1) #=> Will play :c3 with random L/R panning
    sleep 0.125
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.3.0</p>
      </section>
    
      <section>
        <h2 id="reset">Reset all thread locals</h2>
        <code><span class="function">reset</span> </code>
        <p>All settings such as the current synth, BPM, random stream and tick values will be reset to the values inherited from the parent thread. Consider using <code>clear</code> to reset all these values to their defaults.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Basic Reset
use_synth :blade
use_octave 3

puts "before"         #=> "before"
puts current_synth      #=> :blade
puts current_octave     #=> 3
puts rand               #=> 0.75006103515625
puts tick               #=> 0

reset

puts "after"          #=> "after"
puts current_synth      #=> :beep
puts current_octave     #=> 0
puts rand               #=> 0.75006103515625
puts tick               #=> 0</code></pre>
          
            <pre><code>Reset remembers defaults from when the thread was created:
use_synth :blade
use_octave 3

puts "before"         #=> "before"
puts current_synth      #=> :blade
puts current_octave     #=> 3
puts rand               #=> 0.75006103515625
puts tick               #=> 0

at do
  use_synth :tb303
  puts rand               #=> 0.9287109375
  reset
  puts "thread"          #=> "thread"


                          # The call to reset ensured that the current
                          # synth was returned to the the state at the
                          # time this thread was started. Thus any calls
                          # to use_synth between this line and the start
                          # of the thread are ignored
  puts current_synth      #=> :blade
  puts current_octave     #=> 3

                          # The call to reset ensured
                          # that the random stream was reset
                          # to the same state as it was when
                          # the current thread was started
  puts rand               #=> 0.9287109375
  puts tick               #=> 0
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="reset_mixer!">Reset main mixer</h2>
        <code><span class="function">reset_mixer!</span> </code>
        <p>The main mixer is the final mixer that all sound passes through. This fn resets it to its default set - undoing any changes made via set<em>mixer</em>control!</p>

        
          <table>
          
            <caption>Options for reset_mixer!</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_mixer_control! lpf: 70 # LPF cutoff value of main mixer is now 70
sample :loop_amen          # :loop_amen sample is played with low cutoff
sleep 3
reset_mixer!               # mixer is now reset to default values
sample :loop_amen          # :loop_amen sample is played with normal cutoff</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="rest?">Determine if note or args is a rest</h2>
        <code><span class="function">rest?</span> note_or_args <span class="arg_type">(number_symbol_or_map)</span></code>
        <p>Given a note or an args map, returns true if it represents a rest and false if otherwise</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts rest? nil # true</code></pre>
          
            <pre><code>puts rest? :r # true</code></pre>
          
            <pre><code>puts rest? :rest # true</code></pre>
          
            <pre><code>puts rest? 60 # false</code></pre>
          
            <pre><code>puts rest? {} # false</code></pre>
          
            <pre><code>puts rest? {note: :rest} # true</code></pre>
          
            <pre><code>puts rest? {note: nil} # true</code></pre>
          
            <pre><code>puts rest? {note: 50} # false</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="ring">Create a ring buffer</h2>
        <code><span class="function">ring</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new immutable ring buffer from args. Indexes wrap around positively and negatively</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(ring 1, 2, 3)[0] #=> 1</code></pre>
          
            <pre><code>(ring 1, 2, 3)[1] #=> 2</code></pre>
          
            <pre><code>(ring 1, 2, 3)[3] #=> 1</code></pre>
          
            <pre><code>(ring 1, 2, 3)[-1] #=> 3</code></pre>
          
          </details>
        
        <p>Introduced in 2.2.0</p>
      </section>
    
      <section>
        <h2 id="rrand">Generate a random float between two numbers</h2>
        <code><span class="function">rrand</span> min <span class="arg_type">(number)</span>, max <span class="arg_type">(number)</span></code>
        <p>Given two numbers, this produces a float between the supplied min and max values exclusively. Both min and max need to be supplied. For random integers, see <code>rrand_i</code>. If optional arg <code>step:</code> is used, the result is quantised by step.</p>

        
          <table>
          
            <tr>
              <th><code>step</code></th>
              <td>Step size of value to quantise to.</td>
            </tr>
          
            <caption>Options for rrand</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  print rrand(0, 10) #=> will print a number like 8.917730007820797 to the output pane</code></pre>
          
            <pre><code>
  loop do
    play rrand(60, 72) #=> Will play a random non-integer midi note between C4 (60) and C5 (72) such as 67.3453 or 71.2393
    sleep 0.125
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="rrand_i">Generate a random whole number between two points inclusively</h2>
        <code><span class="function">rrand_i</span> min <span class="arg_type">(number)</span>, max <span class="arg_type">(number)</span></code>
        <p>Given two numbers, this produces a whole number between the min and max you supplied inclusively. Both min and max need to be supplied. For random floats, see <code>rrand</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  print rrand_i(0, 10) #=> will print a random number between 0 and 10 (e.g. 4, 0 or 10) to the output pane</code></pre>
          
            <pre><code>
  loop do
    play rrand_i(60, 72) #=> Will play a random midi note between C4 (60) and C5 (72)
    sleep 0.125
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="rt">Real time conversion</h2>
        <code><span class="function">rt</span> seconds <span class="arg_type">(number)</span></code>
        <p>Real time representation. Returns the amount of beats for the value in real-time seconds. Useful for bypassing any bpm scaling</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 120  # modifies all time to be half
  play 50
  sleep 1      # actually sleeps for half of a second
  play 62
  sleep rt(1)  # bypasses bpm scaling and sleeps for a second
  play 72</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="run_code">Evaluate the code passed as a String as a new Run</h2>
        <code><span class="function">run_code</span> code <span class="arg_type">(string)</span></code>
        <p>Executes the code passed as a string in a new Run. This works as if the code was in a buffer and Run button was pressed.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
run_code "sample :ambi_lunar_land" #=> will play the :ambi_lunar_land sample</code></pre>
          
            <pre><code># Works with any amount of code:
run_code "8.times do
play 60
sleep 1
end" # will play 60 8 times</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="run_file">Evaluate the contents of the file as a new Run</h2>
        <code><span class="function">run_file</span> filename <span class="arg_type">(path)</span></code>
        <p>Reads the full contents of the file with <code>path</code> and executes it in a new Run. This works as if the code in the file was in a buffer and Run button was pressed.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
run_file "~/path/to/sonic-pi-code.rb" #=> will run the contents of this file</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="sample">Trigger sample</h2>
        <code><span class="function">sample</span> name_or_path <span class="arg_type">(symbol_or_string)</span></code>
        <p>There are many opts for manipulating the playback. For example, the <code>rate:</code> opt affects both the speed and the pitch of the playback. To control the rate of the sample in a pitch-meaningful way take a look at the <code>rpitch:</code> opt.</p>
<p>The sampler synth has three separate envelopes - one for amplitude, one for a low pass filter and another for a high pass filter. These work very similar to the standard synth envelopes except for two major differences. Firstly, the envelope times do not stretch or shrink to match the BPM. Secondly, the sustain time by default stretches to make the envelope fit the length of the sample. This is explained in detail in the tutorial.</p>
<p>Samples are loaded on-the-fly when first requested (and subsequently remembered). If the sample loading process takes longer than the schedule ahead time, the sample trigger will be skipped rather than be played late and out of time. To avoid this you may preload any samples you wish to work with using <code>load_sample</code> or <code>load_samples</code>.</p>
<p>It is possible to set the <code>start:</code> and <code>finish:</code> positions within the sample to play only a sub-section of it. These values can be automatically chosen based on an onset detection algorithm which will essentially isolate each individual drum or synth hit in the sample and let you access each one by an integer index (floats will be rounded to the nearest integer value). See the <code>onset:</code> docstring and examples for more information.</p>
<p>Finally, the sampler supports a powerful filtering system to make it easier to work with large folders of samples. The filter commands must be used before the first standard opt. There are six kinds of filter parameters you may use:</p>
<ol>
<li>Folder strings - <code>"&#47;foo&#47;bar"</code> - which will add all samples within the folder to the set of candidates.</li>
<li>Recursive folder strings - <code>"&#47;foo&#47;bar&#47;**"</code> - Folder strings ending with <code>**</code> will add all samples contained within all subfolders (searched recursively).</li>
<li>Sample strings - <code>"&#47;path&#47;to&#47;sample.wav"</code> - which will add the specific sample to the set of candidates.</li>
<li>Other strings - <code>"foobar"</code> - which will filter the candidates based on whether the filename contains the string.</li>
<li>Regular expressions - <code>&#47;b[aA]z.*&#47;</code> - which will filter the candidates based on whether the regular expression matches the filename.</li>
<li>Keywords - <code>:quux</code> - will filter the candidates based on whether the keyword is a direct match of the filename (without extension).</li>
<li>Numbers - <code>0</code> - will select the candidate with that index (wrapping round like a ring if necessary).</li>
<li>Lists of the above - <code>["&#47;foo&#47;bar", "baz", &#47;0-9.*&#47;]</code> - will recurse down and work through the internal filter parameters as if they were in the top level.</li>
<li>Lambdas - <code>lambda {|s| [s.choose] }</code> - the ultimate power tool for filters. Allows you to create a custom fn which receives a list of candidates as an arg and which should return a new list of candidates (this may be smaller, larger, re-ordered it&#8217;s up to you).</li>
</ol>
<p>By combining commands which add to the candidates and then filtering those candidates it is possible to work with folders full of samples in very powerful ways. Note that the specific ordering of filter parameters is irrelevant with the exception of the numbers - in which case the last number is the index. All the candidates will be gathered first before the filters are applied.</p>

        
          <table>
          
            <tr>
              <th><code>rate</code></th>
              <td>Rate with which to play back the sample. Higher rates mean an increase in pitch and a decrease in duration. Default is 1.</td>
            </tr>
          
            <tr>
              <th><code>beat_stretch</code></th>
              <td>Stretch (or shrink) the sample to last for exactly the specified number of beats. Please note - this does *not* keep the pitch constant and is essentially the same as modifying the rate directly.</td>
            </tr>
          
            <tr>
              <th><code>pitch_stretch</code></th>
              <td>Stretch (or shrink) the sample to last for exactly the specified number of beats. This attempts to keep the pitch constant using the `pitch:` opt. Note, it's very likely you'll need to experiment with the `window_size:`, `pitch_dis:` and `time_dis:` opts depending on the sample and the amount you'd like to stretch/shrink from original size.</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Time to reach full volume. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Time to stay at full volume. Default is to stretch to length of sample (minus attack and release times).</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Time (from the end of the sample) to go from full amplitude to 0. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>start</code></th>
              <td>Position in sample as a fraction between 0 and 1 to start playback. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>finish</code></th>
              <td>Position in sample as a fraction between 0 and 1 to end playback. Default is 1.</td>
            </tr>
          
            <tr>
              <th><code>pan</code></th>
              <td>Stereo position of audio. -1 is left ear only, 1 is right ear only, and values in between position the sound accordingly. Default is 0.</td>
            </tr>
          
            <tr>
              <th><code>amp</code></th>
              <td>Amplitude of playback.</td>
            </tr>
          
            <tr>
              <th><code>pre_amp</code></th>
              <td>Amplitude multiplier which takes place immediately before any internal FX such as the low pass filter, compressor or pitch modification. Use this opt if you want to overload the compressor.</td>
            </tr>
          
            <tr>
              <th><code>onset</code></th>
              <td>Analyse the sample with an onset detection algorithm and automatically set or override the `start:` and `finish:` opts to play the nth onset only. Allows you to treat a rhythm sample as a palette of individual drum/synth hits. If `start:` or `finish:` opts are used in addition to `onset:` then they will work within the onset rather than the whole sample. Floats are rounded to the nearest whole number.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the sample from being played. Ensures all opts are evaluated.</td>
            </tr>
          
            <tr>
              <th><code>slice</code></th>
              <td>Divides the sample duration evenly into `num_slices:` sections (defaults to 16) and set the `start:` and `finish:` opts to play the nth slice only. If `start:` or `finish:` opts are used in addition to `slice:` then they will work within the slice rather than the whole sample. Use the envelope opts to remove any clicks introduced if the slice boundary is in the middle of a sound. Also consider `onset:` as an alternative to `slice:`. If `onset:` is also used then the slices will be within the onset rather than the whole sample. Floats are rounded to the nearest whole number.</td>
            </tr>
          
            <tr>
              <th><code>num_slices</code></th>
              <td>Number of slices to divide the sample into when using the `slice:` opt. Defaults to 16. Floats are rounded to the nearest whole number.</td>
            </tr>
          
            <tr>
              <th><code>norm</code></th>
              <td>Normalise the audio (make quieter parts of the sample louder and louder parts quieter) - this is similar to the normaliser FX. This may emphasise any clicks caused by clipping.</td>
            </tr>
          
            <tr>
              <th><code>lpf</code></th>
              <td>Cutoff value of the built-in low pass filter (lpf) in MIDI notes. Unless specified, the lpf is *not* added to the signal chain.</td>
            </tr>
          
            <tr>
              <th><code>lpf_init_level</code></th>
              <td>The initial low pass filter envelope value as a MIDI note. This envelope is bypassed if no lpf env opts are specified. Default value is to match the `lpf_min:` opt.</td>
            </tr>
          
            <tr>
              <th><code>lpf_attack_level</code></th>
              <td>The peak lpf cutoff (value of cutoff at peak of attack) as a MIDI note. Default value is to match the `lpf_decay_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>lpf_decay_level</code></th>
              <td>The level of lpf cutoff after the decay phase as a MIDI note. Default value is to match the `lpf_sustain_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>lpf_sustain_level</code></th>
              <td>The sustain cutoff (value of lpf cutoff at sustain time) as a MIDI note. Default value is to match the `lpf_release_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>lpf_release_level</code></th>
              <td>The final value of the low pass filter envelope as a MIDI note. This envelope is bypassed if no lpf env opts are specified. Default value is to match the `lpf:` opt.</td>
            </tr>
          
            <tr>
              <th><code>lpf_attack</code></th>
              <td>Attack time for lpf cutoff filter. Amount of time (in beats) for sound to reach full cutoff value. Default value is set to match amp envelope's attack value.</td>
            </tr>
          
            <tr>
              <th><code>lpf_decay</code></th>
              <td>Decay time for lpf cutoff filter. Amount of time (in beats) for sound to move from full cutoff value (cutoff attack level) to the cutoff sustain level. Default value is set to match amp envelope's decay value.</td>
            </tr>
          
            <tr>
              <th><code>lpf_sustain</code></th>
              <td>Amount of time for lpf cutoff value to remain at sustain level in beats. When -1 (the default) will auto-stretch.</td>
            </tr>
          
            <tr>
              <th><code>lpf_release</code></th>
              <td>Amount of time (in beats) for sound to move from lpf cutoff sustain value to lpf cutoff min value. Default value is set to match amp envelope's release value.</td>
            </tr>
          
            <tr>
              <th><code>lpf_min</code></th>
              <td>Starting value of the lpf cutoff envelope. Default is 30.</td>
            </tr>
          
            <tr>
              <th><code>lpf_env_curve</code></th>
              <td>Select the shape of the curve between levels in the lpf cutoff envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed.</td>
            </tr>
          
            <tr>
              <th><code>hpf</code></th>
              <td>Cutoff value of the built-in high pass filter (hpf) in MIDI notes. Unless specified, the hpf is *not* added to the signal chain.</td>
            </tr>
          
            <tr>
              <th><code>hpf_init_level</code></th>
              <td>The initial high pass filter envelope value as a MIDI note. This envelope is bypassed if no hpf env opts are specified. Default value is set to 130.</td>
            </tr>
          
            <tr>
              <th><code>hpf_attack_level</code></th>
              <td>The peak hpf cutoff (value of cutoff at peak of attack) as a MIDI note. Default value is to match the `hpf_decay_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>hpf_decay_level</code></th>
              <td>The level of hpf cutoff after the decay phase as a MIDI note. Default value is to match the `hpf_sustain_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>hpf_sustain_level</code></th>
              <td>The sustain cutoff (value of hpf cutoff at sustain time) as a MIDI note. Default value is to match the `hpf_release_level:` opt.</td>
            </tr>
          
            <tr>
              <th><code>hpf_release_level</code></th>
              <td>The sustain hpf cutoff (value of hpf cutoff at sustain time) as a MIDI note. Default value is to match the `hpf:` opt.</td>
            </tr>
          
            <tr>
              <th><code>hpf_attack</code></th>
              <td>Attack time for hpf cutoff filter. Amount of time (in beats) for sound to reach full cutoff value. Default value is set to match amp envelope's attack value.</td>
            </tr>
          
            <tr>
              <th><code>hpf_decay</code></th>
              <td>Decay time for hpf cutoff filter. Amount of time (in beats) for sound to move from full cutoff value (cutoff attack level) to the cutoff sustain level. Default value is set to match amp envelope's decay value.</td>
            </tr>
          
            <tr>
              <th><code>hpf_sustain</code></th>
              <td>Amount of time for hpf cutoff value to remain at sustain level in beats. When -1 (the default) will auto-stretch.</td>
            </tr>
          
            <tr>
              <th><code>hpf_release</code></th>
              <td>Amount of time (in beats) for sound to move from hpf cutoff sustain value to hpf cutoff min value. Default value is set to match amp envelope's release value.</td>
            </tr>
          
            <tr>
              <th><code>hpf_env_curve</code></th>
              <td>Select the shape of the curve between levels in the hpf cutoff envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed.</td>
            </tr>
          
            <tr>
              <th><code>hpf_max</code></th>
              <td>Maximum value of the high pass filter envelope. Default is 200.</td>
            </tr>
          
            <tr>
              <th><code>rpitch</code></th>
              <td>Rate modified pitch. Multiplies the rate by the appropriate ratio to shift up or down the specified amount in MIDI notes. Please note - this does *not* keep the duration and rhythmical rate constant and is essentially the same as modifying the rate directly.</td>
            </tr>
          
            <tr>
              <th><code>pitch</code></th>
              <td>Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc. Maximum upper limit of 24 (up 2 octaves). Lower limit of -72 (down 6 octaves). Decimal numbers can be used for fine tuning.</td>
            </tr>
          
            <tr>
              <th><code>window_size</code></th>
              <td>Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Pitch shift works by chopping the input into tiny slices, then playing these slices at a higher or lower rate. If we make the slices small enough and overlap them, it sounds like the original sound with the pitch changed. The window_size is the length of the slices and is measured in seconds. It needs to be around 0.2 (200ms) or greater for pitched sounds like guitar or bass, and needs to be around 0.02 (20ms) or lower for percussive sounds like drum loops. You can experiment with this to get the best sound for your input.</td>
            </tr>
          
            <tr>
              <th><code>pitch_dis</code></th>
              <td>Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Pitch dispersion - how much random variation in pitch to add. Using a low value like 0.001 can help to "soften up" the metallic sounds, especially on drum loops. To be really technical, pitch_dispersion is the maximum random deviation of the pitch from the pitch ratio (which is set by the `pitch:` opt).</td>
            </tr>
          
            <tr>
              <th><code>time_dis</code></th>
              <td>Pitch shift-specific opt - only honoured if the `pitch:` opt is used. Time dispersion - how much random delay before playing each grain (measured in seconds). Again, low values here like 0.001 can help to soften up metallic sounds introduced by the effect. Large values are also fun as they can make soundscapes and textures from the input, although you will most likely lose the rhythm of the original. NB - This won't have an effect if it's larger than window_size.</td>
            </tr>
          
            <tr>
              <th><code>compress</code></th>
              <td>Enable the compressor. This sits at the end of the internal FX chain immediately before the `amp:` opt. Therefore to drive the compressor use the `pre_amp:` opt which will amplify the signal before it hits any internal FX. The compressor compresses the dynamic range of the incoming signal. Equivalent to automatically turning the amp down when the signal gets too loud and then back up again when it's quiet. Useful for ensuring the containing signal doesn't overwhelm other aspects of the sound. Also a general purpose hard-knee dynamic range processor which can be tuned via the opts to both expand and compress the signal.</td>
            </tr>
          
            <tr>
              <th><code>threshold</code></th>
              <td>Threshold value determining the break point between slope_below and slope_above. Only valid if the compressor is enabled by turning on the `compress:` opt.</td>
            </tr>
          
            <tr>
              <th><code>slope_below</code></th>
              <td>Slope of the amplitude curve below the threshold. A value of 1 means that the output of signals with amplitude below the threshold will be unaffected. Greater values will magnify and smaller values will attenuate the signal. Only valid if the compressor is enabled by turning on the `compress:` opt.</td>
            </tr>
          
            <tr>
              <th><code>slope_above</code></th>
              <td>Slope of the amplitude curve above the threshold. A value of 1 means that the output of signals with amplitude above the threshold will be unaffected. Greater values will magnify and smaller values will attenuate the signal. Only valid if the compressor is enabled by turning on the `compress:` opt.</td>
            </tr>
          
            <tr>
              <th><code>clamp_time</code></th>
              <td>Time taken for the amplitude adjustments to kick in fully (in seconds). This is usually pretty small (not much more than 10 milliseconds). Also known as the time of the attack phase. Only valid if the compressor is enabled by turning on the `compress:` opt.</td>
            </tr>
          
            <tr>
              <th><code>relax_time</code></th>
              <td>Time taken for the amplitude adjustments to be released. Usually a little longer than clamp_time. If both times are too short, you can get some (possibly unwanted) artefacts. Also known as the time of the release phase. Only valid if the compressor is enabled by turning on the `compress:` opt.</td>
            </tr>
          
            <tr>
              <th><code>slide</code></th>
              <td>Default slide time in beats for all slide opts. Individually specified slide opts will override this value.</td>
            </tr>
          
            <tr>
              <th><code>path</code></th>
              <td>Path of the sample to play. Typically this opt is rarely used instead of the more powerful source/filter system. However it can be useful when working with pre-made opt maps.</td>
            </tr>
          
            <caption>Options for sample</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Play a built-in sample
sample :loop_amen # Plays the Amen break</code></pre>
          
            <pre><code>
# Play two samples at the same time
# with incredible timing accuracy
sample :loop_amen
sample :ambi_lunar_land # Note, for timing guarantees select the pref:
                        #   Studio -> Synths and FX -> Enforce timing guarantees</code></pre>
          
            <pre><code>
# Create a simple repeating bass drum
live_loop :bass do
  sample :bd_haus
  sleep 0.5
end</code></pre>
          
            <pre><code>
# Create a more complex rhythm with multiple live loops:
live_loop :rhythm do
  sample :tabla_ghe3 if (spread 5, 7).tick
  sleep 0.125
end
live_loop :bd, sync: :rhythm do
  sample :bd_haus, lpf: 90, amp: 2
  sleep 0.5
end</code></pre>
          
            <pre><code>
# Change the playback speed of the sample using rate:
sample :loop_amen, rate: 0.5 # Play the Amen break at half speed
                             # for old school hip-hop</code></pre>
          
            <pre><code>
# Speed things up
sample :loop_amen, rate: 1.5 # Play the Amen break at 1.5x speed
                             # for a jungle/gabba sound</code></pre>
          
            <pre><code>
# Go backwards
sample :loop_amen, rate: -1 # Negative rates play the sample backwards</code></pre>
          
            <pre><code>
# Fast rewind
sample :loop_amen, rate: -3 # Play backwards at 3x speed for a fast rewind effect</code></pre>
          
            <pre><code>
# Start mid sample
sample :loop_amen, start: 0.5 # Start playback half way through</code></pre>
          
            <pre><code>
# Finish mid sample
sample :loop_amen, finish: 0.5 # Finish playback half way through</code></pre>
          
            <pre><code>
# Play part of a sample
sample :loop_amen, start: 0.125, finish: 0.25 # Play the second eighth of the sample</code></pre>
          
            <pre><code>
# Finishing before the start plays backwards
sample :loop_amen, start: 0.25, finish: 0.125 # Play the second eighth of the sample backwards</code></pre>
          
            <pre><code>
# Play a section of a sample at quarter speed backwards
sample :loop_amen, start: 0.125, finish: 0.25, rate: -0.25 # Play the second eighth of the
                                                           # amen break backwards at a
                                                           # quarter speed</code></pre>
          
            <pre><code>
# Control a sample synchronously
s = sample :loop_amen, lpf: 70
sleep 0.5
control s, lpf: 130
sleep 0.5
synth :dsaw, note: :e3 # This is triggered 1s from start</code></pre>
          
            <pre><code> # Controlling a sample asynchronously
sample :loop_amen, lpf: 70 do |s|
  sleep 1                                # This block is run in an implicit in_thread
  control s, lpf: 130                    # and therefore is asynchronous
end
sleep 0.5
synth :dsaw, note: :e3 # This is triggered 0.5s from start</code></pre>
          
            <pre><code>
# Play with slices
sample :loop_garzul, slice: 0      # => play the first 16th of the sample
sleep 0.5
4.times do
  sample :loop_garzul, slice: 1    # => play the second 16th of the sample 4 times
  sleep 0.125
end
sample :loop_garzul, slice: 4, num_slices: 4, rate: -1      # => play the final quarter backwards</code></pre>
          
            <pre><code>
# Build a simple beat slicer
use_sample_bpm :loop_amen                    # Set the BPM to match the amen break sample
live_loop :beat_slicer do
  n = 8                                      # Specify number of slices
                                             # (try changing to 2, 4, 6, 16 or 32)
  s = rand_i n                               # Choose a random slice within range
  sample :loop_amen, slice: s, num_slices: n # Play the specific part of the sample
  sleep 1.0/n                                # Sleep for the duration of the slice
end</code></pre>
          
            <pre><code>
# Play with the built-in low pass filter, high pass filter and compressor
sample :loop_amen, lpf: 80, hpf: 70, compress: 1, pre_amp: 10 # Make the amen break sound punchy.</code></pre>
          
            <pre><code>
# Use the cutoff filter envelopes
sample :loop_garzul, lpf_attack: 8 # Sweep the low pass filter up over 8 beats
sleep 8
sample :loop_garzul, hpf_attack: 8 # Sweep the high pass filter down over 8 beats</code></pre>
          
            <pre><code>
# Sample stretching
puts sample_duration :loop_industrial                   # => 0.88347
puts sample_duration :loop_industrial, beat_stretch: 1  # => 1
live_loop :industrial do
  sample :loop_industrial, beat_stretch: 1              # Stretch the sample to make it 1 beat long
  sleep 1                                               # This now loops perfectly.
                                                        # However, note that stretching/shrinking
                                                        # also modifies the pitch.
end</code></pre>
          
            <pre><code>
# Sample shrinking
puts sample_duration :loop_garzul                       # => 8
puts sample_duration :loop_garzul, beat_stretch: 6      # => 6
live_loop :garzul do
  sample :loop_garzul, beat_stretch: 6                  # As :loop_garzul is longer than 6 beats
                                                        # it is shrunk to fit. This increases the
                                                        # pitch.
  sleep 6
end</code></pre>
          
            <pre><code>
# Sample stretching matches the BPM
use_bpm 30                                              # Set the BPM to 30
puts sample_duration :loop_garzul                       # => 4.0 (at 30 BPM the sample lasts for 4 beats)
puts sample_duration :loop_garzul, beat_stretch: 6      # => 6.0
live_loop :garzul do
  sample :loop_garzul, beat_stretch: 6                  # The sample is stretched to match 6 beats at 30 BPM
  sleep 6
end</code></pre>
          
            <pre><code>
# External samples
sample "/path/to/sample.wav"                          # Play any Wav, Aif, Ogg, Oga, or FLAC sample on your computer
                                                        # by simply passing a string representing the full
                                                        # path</code></pre>
          
            <pre><code>
# Sample pack filtering
dir = "/path/to/dir/of/samples"                       # You can easily work with a directory of samples
sample dir                                              # Play the first sample in the directory
                                                        # (it is sorted alphabetically)
sample dir, 1                                           # Play the second sample in the directory
sample dir, 99                                          # Play the 100th sample in the directory, or if there
                                                        # are fewer, treat the directory like a ring and keep
                                                        # wrapping the index round until a sample is found.
                                                        # For example, if there are 90 samples, the 10th sample
                                                        # is played (index 9).
sample dir, "120"                                     # Play the first sample in the directory that contains
                                                        # the substring "120".
                                                        # For example, this may be "beat1_120_rave.wav"
sample dir, "120", 1                                  # Play the second sample in the directory that contains
                                                        # the substring "120".
                                                        # For example, this may be "beat2_120_rave.wav"
sample dir, /beat[0-9]/                                 # Play the first sample in the directory that matches
                                                        # the regular expression /beat[0-9]/.
                                                        # For example, this may be "beat0_100_trance.wav"
                                                        # You may use the full power of Ruby's regular expression
                                                        # system here: http://ruby-doc.org/core-2.1.1/Regexp.html
sample dir, /beat[0-9]0/, "100"                       # Play the first sample in the directory that both matches
                                                        # the regular expression /beat[0-9]0/ and contains the
                                                        # the substring "100".
                                                        # For example, this may be "beat10_100_rave.wav"</code></pre>
          
            <pre><code>
# Filtering built-in samples
                                                        # If you don't pass a directory source, you can filter over
                                                        # the built-in samples.
sample "tabla_"                                       # Play the first built-in sample that contains the substring
                                                        # "tabla"
sample "tabla_", 2                                    # Play the third built-in sample that contains the substring
                                                        # "tabla"</code></pre>
          
            <pre><code>
# Play with whole directories of samples
load_samples "tabla_"                                 # You may pass any of the source/filter options to load_samples
                                                        # to load all matching samples. This will load all the built-in
                                                        # samples containing the substring "tabla_"
live_loop :tabla do
  sample "tabla_", tick                               # Treat the matching samples as a ring and tick through them
  sleep 0.125
end</code></pre>
          
            <pre><code>
# Specify multiple sources
dir1 = "/path/to/sample/directory"
dir2 = "/path/to/other/sample/directory"
sample dir1, dir2, "foo"                              # Match the first sample that contains the string "foo" out of
                                                        # all the samples in dir1 and dir2 combined.
                                                        # Note that the sources must be listed before any filters.</code></pre>
          
            <pre><code>
# List contents recursively
dir = "/path/to/sample/directory"                     # By default the list of all top-level samples within the directory
                                                        # is considered.
dir_recursive = "/path/to/sample/directory/**"        # However, if you finish your directory string with ** then if that
                                                        # directory contains other directories then the samples within the
                                                        # subdirectories and their subsubdirectories in turn are considered.
sample dir, 0                                           # Play the first top-level sample in the directory
sample dir_recursive, 0                                 # Play the first sample found after combining all samples found in
                                                        # the directory and all directories within it recursively.
                                                        # Note that if there are many sub directories this may take some time
                                                        # to execute. However, the result is cached so subsequent calls will
                                                        # be fast.</code></pre>
          
            <pre><code>
# Bespoke filters
filter = lambda do |candidates|                         # If the built-in String, Regexp and index filters are not sufficient
  [candidates.choose]                                   # you may write your own. They need to be a function which takes a list
end                                                     # of paths to samples and return a list of samples. This one returns a
                                                        # list of a single randomly selected sample.
8.times do
  sample "drum_", filter                              # Play 8 randomly selected samples from the built-in sample set that also
  sleep 0.25                                            # contain the substring "drum_"
end</code></pre>
          
            <pre><code>
# Basic Onset Detection

sample :loop_tabla, start: 0, finish: 0.00763           # If you know the right start: and finish: values, you can extract a
                                                        # single drum hit from a longer sample. However, finding these values
                                                        # can be very time consuming.
sleep 1
                                                        # Instead of specifying the start: and finish: values manually you can
                                                        # use the onset: option to find them for you using an integer index.
sample :loop_tabla, onset: 0                            # onset: 0 will set the start: and finish: values so that the first
                                                        # percussive sound (something that shifts from quiet to loud quickly)
                                                        # is picked out.
sleep 1

sample :loop_tabla, onset: 1                            # We can easily find the second percussive sound in the sample with
                                                        # onset: 1</code></pre>
          
            <pre><code>

# Ticking through onsets

                                                        # The onsets are actually a ring so the index will wrap around. This
                                                        # means that if there are only 8 onsets in a sample, specifying an
                                                        # onset of 100 will still return one of the 8 onsets. This means we
                                                        # can use tick to work through each onset in sequence. This allows us
                                                        # to redefine the rhythm and tempo of a sample


live_loop :tabla do
  use_bpm 50                                            # We can choose our own BPM here - it doesn't need to match the sample
  sample :loop_tabla, onset: tick                       # tick through each onset in sequence
  sleep [0.125, 0.25].choose                            # randomly choose a delay between onset triggers
end</code></pre>
          
            <pre><code>
# Random Onset Triggering
                                                        # We can easily pick a random onset using the pick fn
use_bpm 50
live_loop :tabla do
  sample :loop_tabla, onset: pick                       # Each time round the live loop we now trigger a random onset
  sleep [0.125, 0.25].choose                            # creating an infinite stream of randomly selected drums
end


        </code></pre>
          
            <pre><code>
# Repeatable Random Onsets
                                                        # Instead of an infinite stream of choices, we can combine iteration
                                                        # and use_random_seed to create repeatable riffs:
live_loop :tabla do
  use_random_seed 30000                                 # every 8 times, reset the random seed, this resets the riff
  8.times do
    sample :loop_tabla, onset: pick
    sleep [0.125, 0.25].choose
  end
end
</code></pre>
          
            <pre><code>
#  Random Onset Duration
                                                            # Each onset has a variable length (determined by the sample contents).
                                                            # Therefore, if you wish to ensure each onset has a specific length it
                                                            # is necessary to use the sample's amplitude envelope.
                                                            # As the sample's envelope automatically changes the sustain: value to
                                                            # match the duration - you also need to override this with a value of 0.
live_loop :tabla do
  sample :loop_tabla, onset: pick, sustain: 0, release: 0.1 # Each drum onset will now be no longer than 0.1. Note that the envelope
                                                            # for a sample only determines the maximum duration of a sample trigger.
                                                            # If the actual audible duration of the onset is smaller than 0.1 then
                                                            # it will *not* be extended.
  sleep [0.125, 0.25].choose
end
</code></pre>
          
            <pre><code>
# Onset lambdas

                                                        # The onset index can be a lambda as well as an integer. If a lambda is
                                                        # given, it will be passed a ring of all of the onsets as an argument.
                                                        # This will be a ring of maps:

l = lambda {|c| puts c ; c[0]}                          # define a lambda which accepts a single argument, prints it and
                                                        # returns the first value. This particular example is essentially
                                                        # the same as using onset: 0 with the side effect of also printing out
                                                        # the full ring of onsets:

sample :loop_tabla, onset: l                            # (ring {:start=>0.0, :finish=>0.015110842894865981, :index=>0}, {:start=>0.015110842894865981, :finish=>0.030374580804422135, :index=>1}...)

                                                        # We are therefore free to define this lambda to do anything we want.
                                                        # This gives us very powerful control over the choice of onset. It is
                                                        # unlikely you will use this frequently, but it is a powerful tool
                                                        # that's there when you need it.
</code></pre>
          
            <pre><code>
sample :loop_tabla, onset: 1                                         # Plays the 2nd onset (the first onset would have index 0)

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0304}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)
</code></pre>
          
            <pre><code>
sample :loop_tabla, onset: 1, slice: 0, num_slices: 1                # Plays the 2nd onset. This behaves the same as not specifying
                                                                     # a slice as we select the first of one slices.

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0304}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)
</code></pre>
          
            <pre><code>
sample :loop_tabla, onset: 1, slice: 0, num_slices: 2                # This plays the first half of the 2nd onset.
                                                                     # This is because  we split that onset into two slices and
                                                                     # play just the first slice (with index 0).

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0227}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)</code></pre>
          
            <pre><code>
sample :loop_tabla, onset: 1, slice: 0, num_slices: 4                # This plays the first quarter of the 2nd onset.
                                                                     # This is because we split that onset into four slices and
                                                                     # play just the first slice (with index 0).

                                                                     # Will override opts with: {start: 0.0151, finish: 0.0189}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)

sample :loop_tabla, onset: 1, slice: 0, num_slices: 4, finish: 0.5   # Will play the first 1/8th of the 2nd onset.
                                                                     # This is because we split that specific onset into 4 slices
                                                                     # and then only play the first half of the first slice.

                                                                     # Will override opts with: {start: 0.0151, finish: 0.017}
                                                                     # (these values are specific to the :loop_tabla sample and
                                                                     # will vary for different samples)

sample :loop_tabla, onset: 1, slice: 0, num_slices: 4, finish: 0.0, start: 0.5   # Will play the first 1/8th of the 2nd onset backwards..
                                                                                 # This is because we split that specific onset into 4 slices
                                                                                 # and then only play from the first half of the first slice
                                                                                 # back to the beginning.

                                                                                 # Will override opts with: {start: 0.017, finish: 0.0151}
                                                                                 # (these values are specific to the :loop_tabla sample and
                                                                                 # will vary for different samples)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_buffer">Get sample data</h2>
        <code><span class="function">sample_buffer</span> path <span class="arg_type">(string)</span></code>
        <p>Alias for the <code>load_sample</code> method. Loads sample if necessary and returns buffer information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>see load_sample</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_duration">Get duration of sample in beats</h2>
        <code><span class="function">sample_duration</span> path <span class="arg_type">(string)</span></code>
        <p><em>Note:</em> avoid using <code>sample_duration</code> to set the sleep time in <code>live_loop</code>s, prefer stretching the sample with the <code>beat_stretch:</code> opt or changing the BPM instead. See the examples below for details.</p>

        
          <table>
          
            <tr>
              <th><code>rate</code></th>
              <td>Rate modifier. For example, doubling the rate will halve the duration.</td>
            </tr>
          
            <tr>
              <th><code>start</code></th>
              <td>Start position of sample playback as a value from 0 to 1</td>
            </tr>
          
            <tr>
              <th><code>finish</code></th>
              <td>Finish position of sample playback as a value from 0 to 1</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Duration of the attack phase of the envelope.</td>
            </tr>
          
            <tr>
              <th><code>decay</code></th>
              <td>Duration of the decay phase of the envelope.</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Duration of the sustain phase of the envelope.</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Duration of the release phase of the envelope.</td>
            </tr>
          
            <tr>
              <th><code>beat_stretch</code></th>
              <td>Change the rate of the sample so that its new duration matches the specified number of beats.</td>
            </tr>
          
            <tr>
              <th><code>pitch_stretch</code></th>
              <td>Change the rate of the sample so that its new duration matches the specified number of beats but attempt to preserve pitch.</td>
            </tr>
          
            <tr>
              <th><code>rpitch</code></th>
              <td>Change the rate to shift the pitch up or down the specified number of MIDI notes.</td>
            </tr>
          
            <caption>Options for sample_duration</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Simple use
puts sample_duration(:loop_garzul) # returns 8.0 because this sample is 8 seconds long</code></pre>
          
            <pre><code>
# The result is scaled to the current BPM
use_bpm 120
puts sample_duration(:loop_garzul) # => 16.0
use_bpm 90
puts sample_duration(:loop_garzul) # => 12.0
use_bpm 21
puts sample_duration(:loop_garzul) # => 2.8</code></pre>
          
            <pre><code>
# Avoid using sample_duration to set the sleep time in live_loops

live_loop :avoid_this do               # It is possible to use sample_duration to drive the frequency of a live loop.
  with_fx :slicer do                   # However, if you're using a rhythmical sample such as a drum beat and it isn't
    sample :loop_amen                  # in the same BPM as the current BPM, then the FX such as this slicer will be
    sleep sample_duration(:loop_amen)  # badly out of sync. This is because the slicer slices at the current BPM and
  end                                  # this live_loop is looping at a different BPM (that of the sample)
end

live_loop :prefer_this do              # Instead prefer to set the BPM of the live_loop to match the sample. It has
  use_sample_bpm :loop_amen            # two benefits. Now our sleep is a nice and simple 1 (as it's one beat).
  with_fx :slicer do                   # Also, our slicer now works with the beat and sounds much better.
    sample :loop_amen
    sleep 1
  end
end

live_loop :or_this do                  # Alternatively we can beat_stretch the sample to match the current BPM. This has the
  with_fx :slicer do                   # side effect of changing the rate of the sample (and hence the pitch). However, the
    sample :loop_amen, beat_stretch: 1 # FX works nicely in time and the sleep time is also a simple 1.
    sleep 1
  end
end</code></pre>
          
            <pre><code>
# The standard sample opts are also honoured

                                                                  # Playing a sample at standard speed will return standard length
sample_duration :loop_garzul, rate: 1                             # => 8.0

                                                                  # Playing a sample at half speed will double duration
sample_duration :loop_garzul, rate: 0.5                           # => 16.0

                                                                  # Playing a sample at double speed will halve duration
sample_duration :loop_garzul, rate: 2                             # => 4.0

                                                                  # Playing a sample backwards at double speed will halve duration
sample_duration :loop_garzul, rate: -2                            # => 4.0

                                                                  # Without an explicit sustain: opt attack: just affects amplitude not duration
sample_duration :loop_garzul, attack: 1                           # => 8.0
sample_duration :loop_garzul, attack: 100                         # => 8.0
sample_duration :loop_garzul, attack: 0                           # => 8.0

                                                                  # Without an explicit sustain: opt release: just affects amplitude not duration
sample_duration :loop_garzul, release: 1                          # => 8.0
sample_duration :loop_garzul, release: 100                        # => 8.0
sample_duration :loop_garzul, release: 0                          # => 8.0

                                                                  # Without an explicit sustain: opt decay: just affects amplitude not duration
sample_duration :loop_garzul, decay: 1                            # => 8.0
sample_duration :loop_garzul, decay: 100                          # => 8.0
sample_duration :loop_garzul, decay: 0                            # => 8.0

                                                                  # With an explicit sustain: opt, if the attack + decay + sustain + release envelope
                                                                  # duration is less than the sample duration time, the envelope will shorten the
                                                                  # sample time.
sample_duration :loop_garzul, sustain: 0, attack: 0.5             # => 0.5
sample_duration :loop_garzul, sustain: 0, decay: 0.1              # => 0.1
sample_duration :loop_garzul, sustain: 0, release: 1              # => 1.0
sample_duration :loop_garzul, sustain: 2, attack: 0.5, release: 1 # => 3.5

                                                                  # If the envelope duration is longer than the sample it will not affect the
                                                                  # sample duration
sample_duration :loop_garzul, sustain: 0, attack: 8, release: 3   # => 8


                                                                  # All other opts are taken into account before the comparison with the envelope opts.
sample_duration :loop_garzul, rate: 10                            # => 0.8
sample_duration :loop_garzul, sustain: 0, attack: 0.9, rate: 10   # => 0.8 (The duration of the sample is less than the envelope length so wins)


                                                                  # The rpitch: opt will modify the rate to shift the pitch of the sample up and down
                                                                  # and therefore affects duration.
sample_duration :loop_garzul, rpitch: 12                          # => 4.0
sample_duration :loop_garzul, rpitch: -12                         # => 16

                                                                  # The rpitch: and rate: opts combine together.
sample_duration :loop_garzul, rpitch: 12, rate: 2                 # => 2.0

                                                                  # The beat_stretch: opt stretches the sample so that its duration matches the value.
                                                                  # It also combines with rate:
sample_duration :loop_garzul, beat_stretch: 3                     # => 3.0
sample_duration :loop_garzul, beat_stretch: 3, rate: 0.5          # => 6.0

                                                                  # The pitch_stretch: opt acts identically to beat_stretch when just considering sample
                                                                  # duration.
sample_duration :loop_garzul, pitch_stretch: 3                    # => 3.0
sample_duration :loop_garzul, pitch_stretch: 3, rate: 0.5         # => 6.0

                                                                  # The start: and finish: opts can also shorten the sample duration and also combine
                                                                  # with other opts such as rate:
sample_duration :loop_garzul, start: 0.5                          # => 4.0
sample_duration :loop_garzul, start: 0.5, finish: 0.75            # => 2.0
sample_duration :loop_garzul, finish: 0.5, start: 0.75            # => 2.0
sample_duration :loop_garzul, rate: 2, finish: 0.5, start: 0.75 # => 1.0</code></pre>
          
            <pre><code>
# Triggering samples one after another

sample :loop_amen                    # start the :loop_amen sample
sleep sample_duration(:loop_amen)    # wait for the duration of :loop_amen before
sample :loop_amen                    # starting it again</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_free">Free a sample on the synth server</h2>
        <code><span class="function">sample_free</span> path <span class="arg_type">(string)</span></code>
        <p>Frees the memory and resources consumed by loading the sample on the server. Subsequent calls to <code>sample</code> and friends will re-load the sample on the server.</p>
<p>You may also specify the same set of source and filter pre-args available to <code>sample</code> itself. <code>sample_free</code> will then free all matching samples. See <code>sample</code>&#8217;s docs for more information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen # The Amen break is now loaded into memory and played
sleep 2
sample :loop_amen # The Amen break is not loaded but played from memory
sleep 2
sample_free :loop_amen # The Amen break is freed from memory
sample :loop_amen # the Amen break is re-loaded and played</code></pre>
          
            <pre><code>
puts sample_info(:loop_amen).to_i # This returns the buffer id of the sample i.e. 1
puts sample_info(:loop_amen).to_i # The buffer id remains constant whilst the sample
                                  # is loaded in memory
sample_free :loop_amen
puts sample_info(:loop_amen).to_i # The Amen break is re-loaded and gets a *new* id.</code></pre>
          
            <pre><code>
sample :loop_amen
sample :ambi_lunar_land
sleep 2
sample_free :loop_amen, :ambi_lunar_land
sample :loop_amen                        # re-loads and plays amen
sample :ambi_lunar_land                  # re-loads and plays lunar land</code></pre>
          
            <pre><code># Using source and filter pre-args
dir = "/path/to/sample/dir"
sample_free dir # frees any loaded samples in "/path/to/sample/dir"
sample_free dir, 1 # frees sample with index 1 in "/path/to/sample/dir"
sample_free dir, :foo # frees sample with name "foo" in "/path/to/sample/dir"
sample_free dir, /[Bb]ar/ # frees sample which matches regex /[Bb]ar/ in "/path/to/sample/dir"
</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="sample_free_all">Free all loaded samples on the synth server</h2>
        <code><span class="function">sample_free_all</span> </code>
        <p>Unloads all samples therefore freeing the memory and resources consumed. Subsequent calls to <code>sample</code> and friends will re-load the sample on the server.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen        # load and play :loop_amen
sample :ambi_lunar_land  # load and play :ambi_lunar_land
sleep 2
sample_free_all
sample :loop_amen        # re-loads and plays amen</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="sample_groups">Get all sample groups</h2>
        <code><span class="function">sample_groups</span> </code>
        <p>Return a list of all the sample groups available</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_info">Get sample information</h2>
        <code><span class="function">sample_info</span> path <span class="arg_type">(string)</span></code>
        <p>Alias for the <code>load_sample</code> method. Loads sample if necessary and returns sample information.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>see load_sample</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_loaded?">Test if sample was pre-loaded</h2>
        <code><span class="function">sample_loaded?</span> path <span class="arg_type">(string)</span></code>
        <p>Given a path to a <code>.wav</code>, <code>.wave</code>, <code>.aif</code>, <code>.aiff</code>, <code>.ogg</code>, <code>.oga</code> or <code>.flac</code> file, returns <code>true</code> if the sample has already been loaded.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
load_sample :elec_blip # :elec_blip is now loaded and ready to play as a sample
puts sample_loaded? :elec_blip # prints true because it has been pre-loaded
puts sample_loaded? :misc_burp # prints false because it has not been loaded</code></pre>
          
          </details>
        
        <p>Introduced in 2.2.0</p>
      </section>
    
      <section>
        <h2 id="sample_names">Get sample names</h2>
        <code><span class="function">sample_names</span> group <span class="arg_type">(symbol)</span></code>
        <p>Return a ring of sample names for the specified group</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sample_paths">Sample Pack Filter Resolution</h2>
        <code><span class="function">sample_paths</span> pre_args <span class="arg_type">(source_and_filter_types)</span></code>
        <p>Accepts the same pre-args and opts as <code>sample</code> and returns a ring of matched sample paths.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample_paths "/path/to/samples/" #=> ring of all top-level samples in /path/to/samples</code></pre>
          
            <pre><code>
sample_paths "/path/to/samples/**" #=> ring of all nested samples in /path/to/samples</code></pre>
          
            <pre><code>
sample_paths "/path/to/samples/", "foo" #=> ring of all samples in /path/to/samples
                                                containing the string "foo" in their filename.</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="scale">Create scale</h2>
        <code><span class="function">scale</span> tonic <span class="arg_type">(symbol)</span>, name <span class="arg_type">(symbol)</span></code>
        <p>Creates a ring of MIDI note numbers when given a tonic note and a scale name. Also takes an optional <code>num_octaves:</code> parameter (octave <code>1</code> is the default). If only passed the scale name, the tonic defaults to 0. See examples.</p>

        
          <table>
          
            <tr>
              <th><code>num_octaves</code></th>
              <td>The number of octaves you'd like the scale to consist of. More octaves means a larger scale. Default is 1.</td>
            </tr>
          
            <caption>Options for scale</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts (scale :C, :major) # returns the following ring of MIDI note numbers: (ring 60, 62, 64, 65, 67, 69, 71, 72)</code></pre>
          
            <pre><code># anywhere you can use a list or ring of notes, you can also use scale
play_pattern (scale :C, :major)</code></pre>
          
            <pre><code># you can use the :num_octaves parameter to get more notes
play_pattern (scale :C, :major, num_octaves: 2)</code></pre>
          
            <pre><code># Scales can start with any note:
puts (scale 50, :minor) #=> (ring 50, 52, 53, 55, 57, 58, 60, 62)
puts (scale 50.1, :minor) #=> (ring 50.1, 52.1, 53.1, 55.1, 57.1, 58.1, 60.1, 62.1)
puts (scale :minor) #=> (ring 0, 2, 3, 5, 7, 8, 10, 12)</code></pre>
          
            <pre><code> # scales are also rings
live_loop :scale_player do
  play (scale :Eb3, :super_locrian).tick, release: 0.1
  sleep 0.125
end</code></pre>
          
            <pre><code> # scales starting with 0 are useful in combination with sample's rpitch:
live_loop :scaled_sample do
  sample :bass_trance_c, rpitch: (scale 0, :minor).tick
  sleep 1
end</code></pre>
          
            <pre><code># Sonic Pi supports a large range of scales:

(scale :C, :diatonic)
(scale :C, :ionian)
(scale :C, :major)
(scale :C, :dorian)
(scale :C, :phrygian)
(scale :C, :lydian)
(scale :C, :mixolydian)
(scale :C, :aeolian)
(scale :C, :minor)
(scale :C, :locrian)
(scale :C, :hex_major6)
(scale :C, :hex_dorian)
(scale :C, :hex_phrygian)
(scale :C, :hex_major7)
(scale :C, :hex_sus)
(scale :C, :hex_aeolian)
(scale :C, :minor_pentatonic)
(scale :C, :yu)
(scale :C, :major_pentatonic)
(scale :C, :gong)
(scale :C, :egyptian)
(scale :C, :shang)
(scale :C, :jiao)
(scale :C, :zhi)
(scale :C, :ritusen)
(scale :C, :whole_tone)
(scale :C, :whole)
(scale :C, :chromatic)
(scale :C, :harmonic_minor)
(scale :C, :melodic_minor_asc)
(scale :C, :hungarian_minor)
(scale :C, :octatonic)
(scale :C, :messiaen1)
(scale :C, :messiaen2)
(scale :C, :messiaen3)
(scale :C, :messiaen4)
(scale :C, :messiaen5)
(scale :C, :messiaen6)
(scale :C, :messiaen7)
(scale :C, :super_locrian)
(scale :C, :hirajoshi)
(scale :C, :kumoi)
(scale :C, :neapolitan_major)
(scale :C, :bartok)
(scale :C, :bhairav)
(scale :C, :locrian_major)
(scale :C, :ahirbhairav)
(scale :C, :enigmatic)
(scale :C, :neapolitan_minor)
(scale :C, :pelog)
(scale :C, :augmented2)
(scale :C, :scriabin)
(scale :C, :harmonic_major)
(scale :C, :melodic_minor_desc)
(scale :C, :romanian_minor)
(scale :C, :hindu)
(scale :C, :iwato)
(scale :C, :melodic_minor)
(scale :C, :diminished2)
(scale :C, :marva)
(scale :C, :melodic_major)
(scale :C, :indian)
(scale :C, :spanish)
(scale :C, :prometheus)
(scale :C, :diminished)
(scale :C, :todi)
(scale :C, :leading_whole)
(scale :C, :augmented)
(scale :C, :purvi)
(scale :C, :chinese)
(scale :C, :lydian_minor)
(scale :C, :blues_major)
(scale :C, :blues_minor)
(scale :C, :cargah)
(scale :C, :buselik)
(scale :C, :buselik_2)
(scale :C, :kurdi)
(scale :C, :rast)
(scale :C, :acemli_rast)
(scale :C, :ussak)
(scale :C, :bayati)
(scale :C, :bayati_2)
(scale :C, :isfahan)
(scale :C, :isfahan_2)
(scale :C, :hicaz_humayun)
(scale :C, :hicaz_humayun_2)
(scale :C, :hicaz)
(scale :C, :hicaz_2)
(scale :C, :uzzal)
(scale :C, :uzzal_2)
(scale :C, :zirguleli_hicaz)
(scale :C, :zirguleli_hicaz_2)
(scale :C, :huseyni)
(scale :C, :huseyni_2)
(scale :C, :muhayyer)
(scale :C, :gulizar)
(scale :C, :neva)
(scale :C, :neva_2)
(scale :C, :tahir)
(scale :C, :tahir_2)
(scale :C, :karcigar)
(scale :C, :suznak)
(scale :C, :suznak_2)
(scale :C, :mahur)
(scale :C, :acem_asiran)
(scale :C, :nihavend)
(scale :C, :nihavend_2)
(scale :C, :sultani_yegah)
(scale :C, :sultani_yegah_2)
(scale :C, :kurdili_hicazkar)
(scale :C, :kurdili_hicazkar_2)
(scale :C, :kurdili_hicazkar_3)
(scale :C, :kurdili_hicazkar_4)
(scale :C, :kurdili_hicazkar_5)
(scale :C, :zirguleli_suznak)
(scale :C, :zirguleli_suznak_2)
(scale :C, :zirguleli_suznak_3)
(scale :C, :hicazkar)
(scale :C, :hicazkar_2)
(scale :C, :evcara)
(scale :C, :evcara_2)
(scale :C, :evcara_3)
(scale :C, :evcara_4)
(scale :C, :suzidil)
(scale :C, :suzidil_2)
(scale :C, :sedaraban)
(scale :C, :sedaraban_2)
(scale :C, :segah)
(scale :C, :segah_2)
(scale :C, :huzzam)
(scale :C, :huzzam_2)
(scale :C, :bayati_araban)
(scale :C, :acem_kurdi)
(scale :C, :sehnaz)
(scale :C, :sehnaz_2)
(scale :C, :sehnaz_3)
(scale :C, :sehnaz_4)
(scale :C, :saba)
(scale :C, :dugah)
(scale :C, :dugah_2)
(scale :C, :evic)
(scale :C, :evic_2)
(scale :C, :bestenigar)
(scale :C, :ferahnak)
(scale :C, :sevkefza)
(scale :C, :sevkefza_2)
(scale :C, :sevkefza_3)
(scale :C, :ferahfeza)
(scale :C, :ferahfeza_2)
(scale :C, :yegah)
(scale :C, :yegah_2)</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="scale_names">All scale names</h2>
        <code><span class="function">scale_names</span> </code>
        <p>Returns a ring containing all scale names known to Sonic Pi</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts scale_names #=>  prints a list of all the scales</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="scsynth_info">Return information about the internal SuperCollider sound server</h2>
        <code><span class="function">scsynth_info</span> </code>
        <p>Create a map of information about the running audio synthesiser SuperCollider. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts scsynth_info  #=>  (map sample_rate: 44100.0,
                            #         sample_dur: 2.2675736545352265e-05,
                            #         radians_per_sample: 0.00014247585204429924,
                            #         control_rate: 689.0625,
                            #         control_dur: 0.001451247138902545,
                            #         subsample_offset: 0.0,
                            #         num_output_busses: 16.0,
                            #         num_input_busses: 16.0,
                            #         num_audio_busses: 1024.0,
                            #         num_control_busses: 4096.0,
                            #         num_buffers: 4096.0)</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="set">Store information in the Time State</h2>
        <code><span class="function">set</span> time_state_key <span class="arg_type">(default)</span>, value <span class="arg_type">(anything)</span></code>
        <p>Store information in the Time State for the current time for either the current or any other thread. If called multiple times without an intervening call to <code>sleep</code>, <code>sync</code>, <code>set</code> or <code>cue</code>, the last value set will prevail. The value will remain in the Time State until overwritten by another call to <code>set</code>, or until Sonic Pi quits.</p>
<p>May be used within a <code>time_warp</code> to set past&#47;future events. Does not affect time.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  set :foo, 1 #=> Stores the value 1 with key :foo</code></pre>
          
            <pre><code>
set :foo, 3  # Set :foo to 3
get[:foo] #=> returns 3</code></pre>
          
            <pre><code>
in_thread do
  set :foo, 3  # Set :foo to 3
end

in_thread do
  puts get[:foo]  #=> always returns 3 (no race conditions here!)
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="set_audio_latency!">Globally modify audio latency</h2>
        <code><span class="function">set_audio_latency!</span> milliseconds <span class="arg_type">(number)</span></code>
        <p>On some systems with certain configurations (such as wireless speakers, and even a typical Windows environment with the default audio drivers) the audio latency can be large. If all the user is doing is generating audio via calls such as <code>play</code>, <code>synth</code> and <code>sample</code>, then this latency essentially adds to the schedule ahead time and for the most part can be ignored. However, if the user is combining audio with external MIDI&#47;OSC triggered events, this latency can result in a noticeable offset. This function allows you to address this offset by moving the audio events forwards and backwards in time.</p>
<p>So, for example, if your audio system has an audio latency of 150ms, you can compensate for this by setting Sonic Pi&#8217;s latency to be a negative value: <code>set_audio_latency! -150</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>set_audio_latency! 100 # Audio events will now be scheduled 100ms
                                                  # after the schedule ahead time</code></pre>
          
            <pre><code>set_audio_latency! -200 # Audio events will now be scheduled 200ms
                                                  # before the schedule ahead time</code></pre>
          
          </details>
        
        <p>Introduced in 3.1.0</p>
      </section>
    
      <section>
        <h2 id="set_cent_tuning!">Global Cent tuning</h2>
        <code><span class="function">set_cent_tuning!</span> cent_shift <span class="arg_type">(number)</span></code>
        <p>Globally tune Sonic Pi to play with another external instrument.</p>
<p>Uniformly tunes your music by shifting all notes played by the specified number of cents. To shift up by a cent use a cent tuning of 1. To shift down use negative numbers. One semitone consists of 100 cents.</p>
<p>See <code>use_cent_tuning</code> for setting the cent tuning value locally for a specific thread or <code>live_loop</code>. This is a global value and will shift the tuning for <em>all</em> notes. It will also persist for the entire session.</p>
<p>Important note: the cent tuning set by <code>set_cent_tuning!</code> is independent of any thread-local cent tuning values set by <code>use_cent_tuning</code> or <code>with_cent_tuning</code>. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50
set_cent_tuning! 1
play 50 # Plays note 50.01</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="set_control_delta!">Set control delta globally</h2>
        <code><span class="function">set_control_delta!</span> time <span class="arg_type">(number)</span></code>
        <p>Specify how many seconds between successive modifications (i.e. trigger then controls) of a specific node on a specific thread. Set larger if you are missing control messages sent extremely close together in time.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_control_delta! 0.1                 # Set control delta to 0.1

s = play 70, release: 8, note_slide: 8 # Play a note and set the slide time
control s, note: 82                    # immediately start sliding note.
                                       # This control message might not be
                                       # correctly handled as it is sent at the
                                       # same virtual time as the trigger.
                                       # If you don't hear a slide, try increasing the
                                       # control delta until you do.</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="set_link_bpm!">Set the tempo for the link metronome.</h2>
        <code><span class="function">set_link_bpm!</span> bpm <span class="arg_type">(number)</span></code>
        <p>Set the tempo for the link metronome in BPM. This is &#8216;global&#8217; in that the BPM of all threads&#47;live_loops in Link BPM mode will be affected.</p>
<p>Note that this will <em>also</em> change the tempo of <em>all link metronomes</em> connected to the local network. This includes other instances of Sonic Pi, Music Production tools like Ableton Live, VJ tools like Resolume, DJ hardware like the MPC and many iPad music apps.</p>
<p>For a full list of link-compatible apps and devices see:  <a href="https://www.ableton.com/en/link/products/">https:&#47;&#47;www.ableton.com&#47;en&#47;link&#47;products&#47;</a></p>
<p>Also note that the current thread does not have to be in Link BPM mode for this function to affect the Link clock&#8217;s BPM.</p>
<p>To change the current thread&#47;live_loop to Link BPM mode see: <code>use_bpm :link</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_bpm :link                                 # Switch to Link BPM mode
set_link_bpm! 30                              # Change Link BPM to 30

8.times do
  bpm += 10
  set_link_bpm! bpm                           # Gradually increase the Link BPM
  sample :loop_amen, beat_stretch: 2
  sleep 2
end</code></pre>
          
          </details>
        
        <p>Introduced in 4.0.0</p>
      </section>
    
      <section>
        <h2 id="set_mixer_control!">Control main mixer</h2>
        <code><span class="function">set_mixer_control!</span> </code>
        <p>The main mixer is the final mixer that all sound passes through. This fn gives you control over the main mixer allowing you to manipulate all the sound playing through Sonic Pi at once. For example, you can sweep a lpf or hpf over the entire sound. You can reset the controls back to their defaults with <code>reset_mixer!</code>.</p>

        
          <table>
          
            <tr>
              <th><code>pre_amp</code></th>
              <td>Controls the amplitude of the signal prior to the FX stage of the mixer (prior to lpf/hpf stages). Has slide opts. Default 1.</td>
            </tr>
          
            <tr>
              <th><code>amp</code></th>
              <td>Controls the amplitude of the signal after the FX stage. Has slide opts. Default 1.</td>
            </tr>
          
            <tr>
              <th><code>hpf</code></th>
              <td>Global hpf FX. Has slide opts. Default 0.</td>
            </tr>
          
            <tr>
              <th><code>lpf</code></th>
              <td>Global lpf FX. Has slide opts. Default 135.5.</td>
            </tr>
          
            <tr>
              <th><code>hpf_bypass</code></th>
              <td>Bypass the global hpf. 0=no bypass, 1=bypass. Default 0.</td>
            </tr>
          
            <tr>
              <th><code>lpf_bypass</code></th>
              <td>Bypass the global lpf. 0=no bypass, 1=bypass. Default 0.</td>
            </tr>
          
            <tr>
              <th><code>limiter_bypass</code></th>
              <td>Bypass the final limiter. 0=no bypass, 1=bypass. Default 0.</td>
            </tr>
          
            <tr>
              <th><code>leak_dc_bypass</code></th>
              <td>Bypass the final DC leak correction FX. 0=no bypass, 1=bypass. Default 0.</td>
            </tr>
          
            <caption>Options for set_mixer_control!</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_mixer_control! lpf: 30, lpf_slide: 16 # slide the global lpf to 30 over 16 beats.</code></pre>
          
          </details>
        
        <p>Introduced in 2.7.0</p>
      </section>
    
      <section>
        <h2 id="set_recording_bit_depth!">Set the bit depth for recording wav files</h2>
        <code><span class="function">set_recording_bit_depth!</span> bit_depth <span class="arg_type">(number)</span></code>
        <p>When you hit the record button, Sonic Pi saves all the audio you can hear into a wav file. By default, this file uses a resolution of 16 bits which is the same as CD audio and good enough for most use cases. However, when working with professional equipment, it is common to want to work with even higher quality files such as 24 bits and even 32 bits. This function allows you to switch the default from 16 to one of 8, 16, 24 or 32.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_recording_bit_depth! 24                 # Set recording bit depth to 24</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="set_sched_ahead_time!">Set sched ahead time globally</h2>
        <code><span class="function">set_sched_ahead_time!</span> time <span class="arg_type">(number)</span></code>
        <p>Specify how many seconds ahead of time the synths should be triggered. This represents the amount of time between pressing &#8216;Run&#8217; and hearing audio. A larger time gives the system more room to work with and can reduce performance issues in playing fast sections on slower platforms. However, a larger time also increases latency between modifying code and hearing the result whilst live coding.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>set_sched_ahead_time! 1 # Code will now run approximately 1 second ahead of audio.</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="set_volume!">Set Volume globally</h2>
        <code><span class="function">set_volume!</span> vol <span class="arg_type">(number)</span></code>
        <p>Set the main system volume to <code>vol</code>. Accepts a value between <code>0</code> and <code>5</code> inclusive. Vols greater or smaller than the allowed values are trimmed to keep them within range. Default is <code>1</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
set_volume! 2 # Set the main system volume to 2</code></pre>
          
            <pre><code>set_volume! -1 # Out of range, so sets main system volume to 0</code></pre>
          
            <pre><code>set_volume! 7 # Out of range, so sets main system volume to 5</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="shuffle">Randomise order of a list</h2>
        <code><span class="function">shuffle</span> list <span class="arg_type">(array)</span></code>
        <p>Returns a new list with the same elements as the original but with their order shuffled. Also works for strings</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  shuffle [1, 2, 3, 4] #=> Would return something like: [3, 4, 2, 1] </code></pre>
          
            <pre><code>
  shuffle "foobar"  #=> Would return something like: "roobfa"</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="sleep">Wait for beat duration</h2>
        <code><span class="function">sleep</span> beats <span class="arg_type">(number)</span></code>
        <p>Wait for a number of beats before triggering the next command. Beats are converted to seconds by scaling to the current bpm setting.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Without calls to sleep, all sounds would happen at once:

  play 50  # This is actually a chord with all notes played simultaneously
  play 55
  play 62

  sleep 1  # Create a gap, to allow a moment's pause for reflection...

  play 50  # Let's try the chord again, but this time with sleeps:
  sleep 0.5 # With the sleeps, we turn a chord into an arpeggio
  play 55
  sleep 0.5
  play 62</code></pre>
          
            <pre><code>
  # The amount of time sleep pauses for is scaled to match the current bpm. The default bpm is 60. Let's double it:

  use_bpm 120
  play 50
  sleep 1 # This actually sleeps for 0.5 seconds as we're now at double speed
  play 55
  sleep 1
  play 62

  # Let's go down to half speed:

  use_bpm 30
  play 50
  sleep 1 # This now sleeps for 2 seconds as we're now at half speed.
  play 55
  sleep 1
  play 62
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="spark">Print a string representing a list of numeric values as a spark graph/bar chart</h2>
        <code><span class="function">spark</span> </code>
        <p>Given a list of numeric values, this method turns them into a string of bar heights and prints them out. Useful for quickly graphing the shape of an array.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>spark (range 1, 5)    #=> ▁▃▅█</code></pre>
          
            <pre><code>spark (range 1, 5).shuffle #=> ▃█▅▁</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="spark_graph">Returns a string representing a list of numeric values as a spark graph/bar chart</h2>
        <code><span class="function">spark_graph</span> </code>
        <p>Given a list of numeric values, this method turns them into a string of bar heights. Useful for quickly graphing the shape of an array. Remember to use puts so you can see the output. See <code>spark</code> for a simple way of printing a spark graph.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>puts (spark_graph (range 1, 5))    #=> ▁▃▅█</code></pre>
          
            <pre><code>puts (spark_graph (range 1, 5).shuffle) #=> ▃█▅▁</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="spread">Euclidean distribution for beats</h2>
        <code><span class="function">spread</span> num_accents <span class="arg_type">(number)</span>, size <span class="arg_type">(number)</span></code>
        <p>Creates a new ring of boolean values which space a given number of accents as evenly as possible throughout a bar. This is an implementation of the process described in &#8216;The Euclidean Algorithm Generates Traditional Musical Rhythms&#8217; (Toussaint 2005).</p>

        
          <table>
          
            <tr>
              <th><code>rotate</code></th>
              <td>rotate to the next strong beat allowing for easy permutations of the original rhythmic grouping (see example)</td>
            </tr>
          
            <caption>Options for spread</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(spread 3, 8)    #=> (ring true, false, false, true, false, false, true, false) a spacing of 332</code></pre>
          
            <pre><code>(spread 3, 8, rotate: 1) #=> (ring true, false, false, true, false, true, false, false) a spacing of 323</code></pre>
          
            <pre><code>
  # Easily create interesting polyrhythmic beats
  live_loop :euclid_beat do
    sample :elec_bong, amp: 1.5 if (spread 3, 8).tick # Spread 3 bongs over 8
    sample :perc_snap, amp: 0.8 if (spread 7, 11).look # Spread 7 snaps over 11
    sample :bd_haus, amp: 2 if (spread 1, 4).look # Spread 1 bd over 4
    sleep 0.125
  end
  </code></pre>
          
            <pre><code>
  # Spread descriptions from
  # 'The Euclidean Algorithm Generates Traditional Musical Rhythms' (Toussaint 2005).
  (spread 2, 5)  # A thirteenth century Persian rhythm called Khafif-e-ramal.

  (spread 3, 4)  # The archetypal pattern of the Cumbria from Columbia, as well
                 # as a Calypso rhythm from Trinidad

  (spread 3, 5)  # When started on the second onset, is another thirteenth
                 # century Persian rhythm by the name of Khafif-e-ramal, as well
                 # as a Romanian folk-dance rhythm.

  (spread 3, 7)  # A ruchenitza rhythm used in a Bulgarian folk-dance.

  (spread 3, 8)  # The Cuban tresillo pattern

  (spread 4, 7)  # Another Ruchenitza Bulgarian folk-dance rhythm

  (spread 4, 9)  # The Aksak rhythm of Turkey.

  (spread 4, 11) # The metric pattern used by Frank Zappa in his piece Outside Now

  (spread 5, 6)  # Yields the York-Samai pattern, a popular Arab rhythm, when
                 # started on the second onset.

  (spread 5, 7)  # The Nawakhat pattern, another popular Arab rhythm.

  (spread 5, 8)  # The Cuban cinquillo pattern.

  (spread 5, 9)  # A popular Arab rhythm called Agsag-Samai.

  (spread 5, 11) # The metric pattern used by Moussorgsky in Pictures at an
                 # Exhibition

  (spread 5, 12) # The Venda clapping pattern of a South African children's
                 # song.

  (spread 5, 16) # The Bossa-Nova rhythm necklace of Brazil.

  (spread 7, 8)  # A typical rhythm played on the Bendir (frame drum)

  (spread 7, 12) # A common West African bell pattern.

  (spread 7, 16) # A Samba rhythm necklace from Brazil.

  (spread 9, 16) # A rhythm necklace used in the Central African Republic.

  (spread 11, 24) # A rhythm necklace of the Aka Pygmies of Central Africa.

  (spread 13, 24) # Another rhythm necklace of the Aka Pygmies of the upper
                  # Sangha.
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.4.0</p>
      </section>
    
      <section>
        <h2 id="status">Get server status</h2>
        <code><span class="function">status</span> </code>
        <p>This returns a Hash of information about the synthesis environment. Mostly used for debugging purposes.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
puts status # Returns something similar to:
            # {
            #   :ugens=>10,
            #   :synths=>1,
            #   :groups=>7,
            #   :sdefs=>61,
            #   :avg_cpu=>0.20156468451023102,
            #   :peak_cpu=>0.36655542254447937,
            #   :nom_samp_rate=>44100.0,
            #   :act_samp_rate=>44099.9998411752,
            #   :audio_busses=>2,
            #   :control_busses=>0
            # }</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="stop">Stop current thread or run</h2>
        <code><span class="function">stop</span> </code>
        <p>Stops the current thread or if not in a thread, stops the current run. Does not stop any running synths triggered previously in the run&#47;thread or kill any existing sub-threads.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  sample :loop_amen #=> this sample is played until completion
  sleep 0.5
  stop                #=> signal to stop executing this run
  sample :loop_garzul #=> this never executes
  </code></pre>
          
            <pre><code>
  in_thread do
    play 60      #=> this note plays
    stop
    sleep 0.5    #=> this sleep never happens
    play 72      #=> this play never happens
  end

  play 80  #=> this plays as the stop only affected the above thread</code></pre>
          
            <pre><code>
  # Stopping live loops
  live_loop :foo
    sample :bd_haus
    sleep 1
    stop               # live loop :foo will now stop and no longer loop
  end

  live_loop :bar       # live loop :bar will continue looping
    sample :elec_blip
    sleep 0.25
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="stretch">Stretch a sequence of values</h2>
        <code><span class="function">stretch</span> list <span class="arg_type">(anything)</span>, count <span class="arg_type">(number)</span></code>
        <p>Stretches a list of values each value repeated count times. Always returns a ring regardless of the type of the list that is stretched. To preserve type, consider using <code>.stretch</code> i.e. <code>(ramp 1, 2, 3).stretch(2) #=&#62; (ramp 1, 1, 2, 2, 3, 3)</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(stretch [1,2], 3)    #=> (ring 1, 1, 1, 2, 2, 2)</code></pre>
          
            <pre><code>(stretch [:e2, :c3], 1, [:c2, :d3], 2) #=> (ring :e2, :c3, :c2, :c2, :d3, :d3)</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="sync">Sync with other threads</h2>
        <code><span class="function">sync</span> cue_id <span class="arg_type">(symbol)</span></code>
        <p>Pause&#47;block the current thread until a <code>cue</code> heartbeat with a matching <code>cue_id</code> is received. When a matching <code>cue</code> message is received, unblock the current thread, and continue execution with the virtual time set to match the thread that sent the <code>cue</code> heartbeat. The current thread is therefore synced to the <code>cue</code> thread. If multiple cue ids are passed as arguments, it will <code>sync</code> on the first matching <code>cue_id</code>. The BPM of the cueing thread can optionally be inherited by using the bpm_sync: opt.</p>

        
          <table>
          
            <tr>
              <th><code>bpm_sync</code></th>
              <td>Inherit the BPM of the cueing thread. Default is false</td>
            </tr>
          
            <caption>Options for sync</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  in_thread do
    sync :foo # this parks the current thread waiting for a foo sync message to be received.
    sample :ambi_lunar_land
  end

  sleep 5

  cue :foo # We send a sync message from the main thread.
            # This then unblocks the thread above and we then hear the sample</code></pre>
          
            <pre><code>
  in_thread do   # Start a metronome thread
    loop do      # Loop forever:
      cue :tick # sending tick heartbeat messages
      sleep 0.5  # and sleeping for 0.5 beats between ticks
    end
  end

  # We can now play sounds using the metronome.
  loop do                    # In the main thread, just loop
    sync :tick               # waiting for :tick sync messages
    sample :drum_heavy_kick  # after which play the drum kick sample
  end</code></pre>
          
            <pre><code>
  sync :foo, :bar # Wait for either a :foo or :bar cue </code></pre>
          
            <pre><code>
  in_thread do   # Start a metronome thread
    loop do      # Loop forever:
      cue [:foo, :bar, :baz].choose # sending one of three tick heartbeat messages randomly
      sleep 0.5  # and sleeping for 0.5 beats between ticks
    end
  end

  # We can now play sounds using the metronome:

  in_thread do
    loop do                    # In the main thread, just loop
      sync :foo               # waiting for :foo sync messages
      sample :elec_beep  # after which play the elec beep sample
    end
  end

  in_thread do
    loop do                    # In the main thread, just loop
      sync :bar               # waiting for :bar sync messages
      sample :elec_flip  # after which play the elec flip sample
    end
  end

  in_thread do
    loop do                    # In the main thread, just loop
      sync :baz               # waiting for :baz sync messages
      sample :elec_blup  # after which play the elec blup sample
    end
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="sync_bpm">Sync and inherit BPM from other threads </h2>
        <code><span class="function">sync_bpm</span> cue_id <span class="arg_type">(symbol)</span></code>
        <p>An alias for <code>sync</code> with the <code>bpm_sync:</code> opt set to true.</p>

        
          <table>
          
            <caption>Options for sync_bpm</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>See examples for sync</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="synth">Trigger specific synth</h2>
        <code><span class="function">synth</span> synth_name <span class="arg_type">(symbol)</span></code>
        <p>If note: opt is <code>nil</code>, <code>:r</code> or <code>:rest</code>, play is ignored and treated as a rest. Also, if the <code>on:</code> opt is specified and returns <code>false</code>, or <code>nil</code> then play is similarly ignored and treated as a rest.</p>
<p>If the synth name is <code>nil</code> behaviour is identical to that of <code>play</code> in that the <code>current_synth</code> will determine the actual synth triggered.</p>
<p>If a block is given, it is assumed to take one arg which will be the controllable synth node and the body of the block is run in an implicit <code>in_thread</code>. This allows for asynchronous control of the synth without interfering with time. For synchronous control capture the result of <code>synth</code> as a variable and use that.</p>
<p>Note that the default opts listed are only a guide to the most common opts across all the synths. Not all synths support all the default opts and each synth typically supports many more opts specific to that synth. For example, the <code>:tb303</code> synth supports 45 unique opts. For a full list of a synth&#8217;s opts see its documentation in the Help system. This can be accessed directly by clicking on the name of the synth and using the shortcut <code>C-i</code></p>

        
          <table>
          
            <tr>
              <th><code>amp</code></th>
              <td>The amplitude of the note</td>
            </tr>
          
            <tr>
              <th><code>amp_slide</code></th>
              <td>The duration in beats for amplitude changes to take place</td>
            </tr>
          
            <tr>
              <th><code>pan</code></th>
              <td>The stereo position of the sound. -1 is left, 0 is in the middle and 1 is on the right. You may use a value in between -1 and 1 such as 0.25</td>
            </tr>
          
            <tr>
              <th><code>pan_slide</code></th>
              <td>The duration in beats for the pan value to change</td>
            </tr>
          
            <tr>
              <th><code>attack</code></th>
              <td>Amount of time (in beats) for sound to reach full amplitude (attack_level). A short attack (i.e. 0.01) makes the initial part of the sound very percussive like a sharp tap. A longer attack (i.e 1) fades the sound in gently.</td>
            </tr>
          
            <tr>
              <th><code>decay</code></th>
              <td>Amount of time (in beats) for the sound to move from full amplitude (attack_level) to the sustain amplitude (sustain_level).</td>
            </tr>
          
            <tr>
              <th><code>sustain</code></th>
              <td>Amount of time (in beats) for sound to remain at sustain level amplitude. Longer sustain values result in longer sounds. Full length of sound is attack + decay + sustain + release.</td>
            </tr>
          
            <tr>
              <th><code>release</code></th>
              <td>Amount of time (in beats) for sound to move from sustain level amplitude to silent. A short release (i.e. 0.01) makes the final part of the sound very percussive (potentially resulting in a click). A longer release (i.e 1) fades the sound out gently.</td>
            </tr>
          
            <tr>
              <th><code>attack_level</code></th>
              <td>Amplitude level reached after attack phase and immediately before decay phase</td>
            </tr>
          
            <tr>
              <th><code>decay_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before sustain phase. Defaults to sustain_level unless explicitly set</td>
            </tr>
          
            <tr>
              <th><code>sustain_level</code></th>
              <td>Amplitude level reached after decay phase and immediately before release phase.</td>
            </tr>
          
            <tr>
              <th><code>env_curve</code></th>
              <td>Select the shape of the curve between levels in the envelope. 1=linear, 2=exponential, 3=sine, 4=welch, 6=squared, 7=cubed</td>
            </tr>
          
            <tr>
              <th><code>slide</code></th>
              <td>Default slide time in beats for all slide opts. Individually specified slide opts will override this value</td>
            </tr>
          
            <tr>
              <th><code>pitch</code></th>
              <td>Pitch adjustment in semitones. 1 is up a semitone, 12 is up an octave, -12 is down an octave etc.  Decimal numbers can be used for fine tuning.</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the synth from being played. Ensures all opts are evaluated.</td>
            </tr>
          
            <caption>Options for synth</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_synth :beep            # Set current synth to :beep
play 60                    # Play note 60 with opt defaults

synth :dsaw, note: 60    # Bypass current synth and play :dsaw
                         # with note 60 and opt defaults </code></pre>
          
            <pre><code>
synth :fm, note: 60, amp: 0.5 # Play note 60 of the :fm synth with an amplitude of 0.5</code></pre>
          
            <pre><code>
use_synth_defaults release: 5
synth :dsaw, note: 50 # Play note 50 of the :dsaw synth with a release of 5</code></pre>
          
            <pre><code># You can play chords with the notes: opt:
synth :dsaw, notes: (chord :e3, :minor)</code></pre>
          
            <pre><code>
# on: vs if
notes = (scale :e3, :minor_pentatonic, num_octaves: 2)

live_loop :rhyth do
  8.times do
    trig = (spread 3, 7).tick(:rhyth)
    synth :tri, on: trig, note: notes.tick, release: 0.1  # Here, we're calling notes.tick
                                                          # every time we attempt to play the synth
                                                          # so the notes rise faster than rhyth2
    sleep 0.125
  end
end


live_loop :rhyth2 do
  8.times do
    trig = (spread 3, 7).tick(:rhyth)
    synth :saw, note: notes.tick, release: 0.1 if trig  # Here, we're calling notes.tick
                                                        # only when the spread says to play
                                                        # so the notes rise slower than rhyth
    sleep 0.125
  end
end</code></pre>
          
            <pre><code> # controlling a synth synchronously
s = synth :beep, note: :e3, release: 4
sleep 1
control s, note: :e5
sleep 0.5
synth :dsaw, note: :e3   # This is triggered after 1.5s from start</code></pre>
          
            <pre><code> # Controlling a synth asynchronously
synth :beep, note: :e3, release: 4 do |s|
  sleep 1                                               # This block is run in an implicit in_thread
  control s, note: :e5                                  # and therefore is asynchronous
end

sleep 0.5
synth :dsaw, note: :e3 # This is triggered after 0.5s from start</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="synth_names">Get all synth names</h2>
        <code><span class="function">synth_names</span> </code>
        <p>Return a list of all the synths available</p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="tick">Increment a tick and return value</h2>
        <code><span class="function">tick</span> key <span class="arg_type">(symbol)</span></code>
        <p>Increment the default tick by 1 and return value. Successive calls to <code>tick</code> will continue to increment the default tick. If a <code>key</code> is specified, increment that specific tick. If an increment <code>value</code> is specified, increment key by that value rather than 1. Ticks are <code>in_thread</code> and <code>live_loop</code> local, so incrementing a tick only affects the current thread&#8217;s version of that tick. See <code>tick_reset</code> and <code>tick_set</code> for directly manipulating the tick vals.</p>

        
          <table>
          
            <tr>
              <th><code>step</code></th>
              <td>The amount to tick up by. Default is 1.</td>
            </tr>
          
            <tr>
              <th><code>offset</code></th>
              <td>Offset to add to index returned. Useful when calling tick on lists, rings and vectors to offset the returned value. Default is 0.</td>
            </tr>
          
            <caption>Options for tick</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts tick #=> 0
  puts tick #=> 1
  puts tick #=> 2
  puts tick #=> 3
  </code></pre>
          
            <pre><code>
  puts tick(:foo) #=> 0 # named ticks have their own counts
  puts tick(:foo) #=> 1
  puts tick(:foo) #=> 2
  puts tick(:bar) #=> 0 # tick :bar is independent of tick :foo
  </code></pre>
          
            <pre><code>
  # You can tick by more than increments of 1
  # using the step: opt

  puts tick             #=> 0
  puts tick             #=> 1
  puts tick             #=> 2
  puts tick(step: 2)    #=> 4
  puts tick(step: 2)    #=> 6
  puts tick(step: 10)   #=> 16
  puts tick             #=> 17
  </code></pre>
          
            <pre><code> # Each_live loop has its own separate ticks
  live_loop :fast_tick do
    puts tick   # the fast_tick live_loop's tick will
    sleep 2     # be updated every 2 seconds
  end

  live_loop :slow_tick do
    puts tick   # the slow_tick live_loop's tick is
    sleep 4     # totally independent from the fast_tick
                # live loop and will be updated every 4
                # seconds
  end
  </code></pre>
          
            <pre><code>
  live_loop :regular_tick do
    puts tick   # the regular_tick live_loop's tick will
    sleep 1     # be updated every second
  end

  live_loop :random_reset_tick do
    if one_in 3 # randomly reset tick
      tick_reset
      puts "reset tick!"
    end
    puts tick   # this live_loop's tick is totally
    sleep 1     # independent and the reset only affects
                # this tick.
  end
  </code></pre>
          
            <pre><code>
  # Ticks work directly on lists, and will tick through each element
  # However, once they get to the end, they'll return nil
  live_loop :scale do
    play [:c, :d, :e, :f, :g].tick   # play all notes just once, then rests
    sleep 1
  end
  </code></pre>
          
            <pre><code>
  # Normal ticks interact directly with list ticks
  live_loop :odd_scale do
    tick  # Increment the default tick
    play [:c, :d, :e, :f, :g, :a].tick   # this now play every *other* note just once,
                                         # then rests
    sleep 1
  end
  </code></pre>
          
            <pre><code>
  # Ticks work wonderfully with rings
  # as the ring ensures the tick wraps
  # round internally always returning a
  # value
  live_loop :looped_scale do
    play (ring :c, :d, :e, :f, :g).tick   # play all notes just once, then repeats
    sleep 1
  end
  </code></pre>
          
            <pre><code>
  # Ticks work wonderfully with scales
  # which are also rings
  live_loop :looped_scale do
    play (scale :e3, :minor_pentatonic).tick   # play all notes just once, then repeats
    sleep 0.25
  end
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="tick_reset">Reset tick to 0</h2>
        <code><span class="function">tick_reset</span> </code>
        <p>Reset default tick to 0. If a <code>key</code> is referenced, set that tick to 0 instead. Same as calling tick_set(0)</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
           # increment default tick a few times
  tick
  tick
  tick
  puts look #=> 2 (default tick is now 2)
  tick_set 0 # default tick is now 0
  puts look #=> 0 (default tick is now 0
  </code></pre>
          
            <pre><code>
                  # increment tick :foo a few times
  tick :foo
  tick :foo
  tick :foo
  puts look(:foo) #=> 2 (tick :foo is now 2)
  tick_set 0 # default tick is now 0
  puts look(:foo) #=> 2 (tick :foo is still 2)
  tick_set :foo, 0 #  reset tick :foo
  puts look(:foo) #=> 0 (tick :foo is now 0)</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="tick_reset_all">Reset all ticks</h2>
        <code><span class="function">tick_reset_all</span> </code>
        <p>Reset all ticks - default and keyed</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  tick      # increment default tick and tick :foo
  tick
  tick :foo
  tick :foo
  tick :foo
  puts look #=> 1
  puts look(:foo) #=> 2
  tick_reset_all
  puts look #=> 0
  puts look(:foo) #=> 0
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="tick_set">Set tick to a specific value</h2>
        <code><span class="function">tick_set</span> value <span class="arg_type">(number)</span></code>
        <p>Set the default tick to the specified <code>value</code>. If a <code>key</code> is referenced, set that tick to <code>value</code> instead. Next call to <code>look</code> will return <code>value</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  tick_set 40 # set default tick to 40
  puts look   #=> 40</code></pre>
          
            <pre><code>
  tick_set :foo, 40 # set tick :foo to 40
  puts look(:foo)   #=> 40 (tick :foo is now 40)
  puts look         #=> 0 (default tick is unaffected)

  </code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="time_warp">Shift time forwards or backwards for the given block</h2>
        <code><span class="function">time_warp</span> delta_time <span class="arg_type">(number)</span></code>
        <p>The code within the given block is executed with the specified delta time shift specified in beats. For example, if the delta value is 0.1 then all code within the block is executed with a 0.1 beat delay. Negative values are allowed which means you can move a block of code <em>backwards in time</em>. For example a delta value of -0.1 will execute the code in the block 0.1 beats ahead of time. The time before the block started is restored after the execution of the block.</p>
<p>Given a list of times, run the block once after waiting each given time. If passed an optional params list, will pass each param individually to each block call. If size of params list is smaller than the times list, the param values will act as rings (rotate through). If the block is given 1 arg, the times are fed through. If the block is given 2 args, both the times and the params are fed through. A third block arg will receive the index of the time.</p>
<p>Note that the code within the block is executed synchronously with the code before and after, so all thread locals will be modified inline - as is the case for <code>with_fx</code>. However, as time is always restored to the value before <code>time_warp</code> started, you can use it to schedule events for the future in a similar fashion to a thread (via <code>at</code> or <code>in_thread</code>) without having to use an entirely fresh and distinct set of thread locals - see examples.</p>
<p>Also, note that you cannot travel backwards in time beyond the <code>current_sched_ahead_time</code>.</p>
<p>If the <code>time_warp</code> block is within a <code>density</code> block, the delta time is not affected (although all the other times such as sleep and phase durations will be affected) - see example.</p>
<p><code>time_warp</code> is ahead-of-time scheduling within the current thread. See <code>at</code> for just-in-time scheduling using multiple isolated threads.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code># shift forwards in time
play 70            #=> plays at time 0
sleep 1
play 75            #=> plays at time 1

time_warp 0.1 do
                   # time shifts forward by 0.1 beats
  play 80          #=> plays at 1.1
  sleep 0.5
  play 80          #=> plays at 1.6

end                # time shifts back by 0.6 beats

                   # we now honour the original sleep 1 and the
                   # sleep 0.5 within the time_warp block is
                   # ignored including the 0.1 shift offset

play 70            #=> plays at 1</code></pre>
          
            <pre><code># shift backwards in time

play 70            #=> plays at time 0
sleep 1
play 75            #=> plays at time 1

time_warp -0.1 do
                   # time shifts backwards by 0.1 beats
  play 80          #=> plays at 0.9
  sleep 0.5
  play 80          #=> plays at 1.4
                   # time shifts forward by 0.1 beats
end
                   # we now honour the original sleep 1 and the
                   # sleep 0.5 within the time_warp block is
                   # ignored, including the -0.1 offset
play 70            #=> plays at 1</code></pre>
          
            <pre><code># Ticks count linearly through time_warp

puts tick          #=> prints 0 (at time 0)

sleep 1

time_warp 2 do
  puts tick        #=> prints 1 (at time 3)
end

sleep 0.5

puts tick          #=> prints 2 (at time 1.5)</code></pre>
          
            <pre><code># Comparing time_warp with at

puts tick          #=> prints 0 (at time 0)
sleep 0.5
puts tick          #=> prints 1 (at time 0.5)

time_warp 2 do
  puts tick        #=> prints 2 (at time 2.5)
  sleep 0.5
  puts tick        #=> prints 3 (at time 3)
end

at 3 do            # the at will reset all thread locals
  puts tick        #=> prints 0 (At time 3.5)
  sleep 0.5
  puts tick        #=> prints 1 (At time 4)
end

sleep 0.5

puts tick          #=> prints 4 (at time 1)</code></pre>
          
            <pre><code># Time Warp within Density
density 2 do                        # Typically this will double the BPM and affect all times
                                    # in addition to looping the internal block twice
  time_warp 0.5 do                  # However, this time is *not* affected and will remain 0.5
    with_fx :slicer, phase: 0.5 do  # This phase duration *is* affected and will be 0.25
      play 60
      sleep 1                       # This time *will* be affected by the density and be 0.5
    end
  end

end
</code></pre>
          
            <pre><code> # Time Warp with lists of times

time_warp [0, 1, 2, 3] do
  puts "hello"                # Will print "hello" at 0, 1, 2, and 3 seconds
end
                                # Notice that the run completes before all the
                                # messages have been delivered. This is because it
                                # schedules all the messages at once so the program
                                # can complete immediately. This is unlike at which
                                # would appear to behave similarly, but would wait
                                # for all messages to be delivered (on time) before
                                # allowing the program to complete. </code></pre>
          
            <pre><code>time_warp [1, 2, 4] do  # plays a note after waiting 1 beat,
    play 75                # then after 1 more beat,
  end                      # then after 2 more beats (4 beats total)
  </code></pre>
          
            <pre><code>
  time_warp [1, 2, 3], [75, 76, 77] do |n|  # plays 3 different notes
    play n
  end
  </code></pre>
          
            <pre><code>
  time_warp [1, 2, 3],
      [{:amp=>0.5}, {:amp=> 0.8}] do |p| # alternate soft and loud
    sample :drum_cymbal_open, p          # cymbal hits three times
  end
  </code></pre>
          
            <pre><code>
  time_warp [0, 1, 2] do |t| # when no params are given to at, the times are fed through to the block
    puts t #=> prints 0, 1, then 2
  end
  </code></pre>
          
            <pre><code>
  time_warp [0, 1, 2], [:a, :b] do |t, b|  # If you specify the block with 2 args, it will pass through both the time and the param
    puts [t, b] #=> prints out [0, :a], [1, :b], then [2, :a]
  end
  </code></pre>
          
            <pre><code>
  time_warp [0, 0.5, 2] do |t, idx|  # If you specify the block with 2 args, and no param list to at, it will pass through both the time and the index
    puts [t, idx] #=> prints out [0, 0], [0.5, 1], then [2, 2]
  end
  </code></pre>
          
            <pre><code>
  time_warp [0, 0.5, 2], [:a, :b] do |t, b, idx|  # If you specify the block with 3 args, it will pass through the time, the param and the index
    puts [t, b, idx] #=> prints out [0, :a, 0], [0.5, :b, 1], then [2, :a, 2]
  end
  </code></pre>
          
            <pre><code> # time_warp consumes & interferes with the outer random stream
puts "main: ", rand  # 0.75006103515625
rand_back
time_warp 1 do         # the random stream inside the at block is the
                       # same as the one in the outer block
  puts "time_warp:", rand # 0.75006103515625
  puts "time_warp:", rand # 0.733917236328125
  rand_back           # undo last call to rand
end

sleep 2
puts "main: ", rand # value is now 0.733917236328125 again</code></pre>
          
            <pre><code>
            # Each block run inherits the same thread locals from the previous one.
            # This means things like the thread local counters can flow through
            # time warp iterations:
time_warp [0, 2] do
            # first time round (after 1 beat) prints:
  puts tick # 0
  puts tick # 1
end
            # second time round (after 2 beats) prints:
            # 2
            # 3</code></pre>
          
          </details>
        
        <p>Introduced in 2.11.0</p>
      </section>
    
      <section>
        <h2 id="uncomment">Block level comment ignoring</h2>
        <code><span class="function">uncomment</span> </code>
        <p>Evaluates all of the code within the block. Use to reverse the effect of the comment without having to explicitly remove it.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  uncomment do # starting a block level comment:
    play 50 # played
    sleep 1 # sleep happens
    play 62 # played
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_arg_bpm_scaling">Enable and disable BPM scaling</h2>
        <code><span class="function">use_arg_bpm_scaling</span> bool <span class="arg_type">(boolean)</span></code>
        <p>Turn synth argument bpm scaling on or off for the current thread. This is on by default. Note, using <code>rt</code> for args will result in incorrect times when used after turning arg bpm scaling off.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_bpm 120
play 50, release: 2 # release is actually 1 due to bpm scaling
sleep 2             # actually sleeps for 1 second
use_arg_bpm_scaling false
play 50, release: 2 # release is now 2
sleep 2             # still sleeps for 1 second</code></pre>
          
            <pre><code>                       # Interaction with rt
use_bpm 120
play 50, release: rt(2) # release is 2 seconds
sleep rt(2)             # sleeps for 2 seconds
use_arg_bpm_scaling false
play 50, release: rt(2) # ** Warning: release is NOT 2 seconds! **
sleep rt(2)             # still sleeps for 2 seconds</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_arg_checks">Enable and disable arg checks</h2>
        <code><span class="function">use_arg_checks</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>When triggering synths, each argument is checked to see if it is sensible. When argument checking is enabled and an argument isn&#8217;t sensible, you&#8217;ll see an error in the debug pane. This setting allows you to explicitly enable and disable the checking mechanism. See with<em>arg</em>checks for enabling&#47;disabling argument checking only for a specific <code>do</code>&#47;<code>end</code> block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50, release: 5 # Args are checked
use_arg_checks false
play 50, release: 5 # Args are not checked</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_bpm">Set the tempo</h2>
        <code><span class="function">use_bpm</span> bpm <span class="arg_type">(number)</span></code>
        <p>Sets the tempo in bpm (beats per minute) for everything afterwards. Affects all subsequent calls to <code>sleep</code> and all temporal synth arguments which will be scaled to match the new bpm. If you wish to bypass scaling in calls to sleep, see the fn <code>rt</code>. Also, if you wish to bypass time scaling in synth args see <code>use_arg_bpm_scaling</code>. See also <code>with_bpm</code> for a block scoped version of <code>use_bpm</code>.</p>
<p>For dance music here&#8217;s a rough guide for which BPM to aim for depending on your genre:</p>
<ul>
<li>Dub: 60-90 bpm</li>
<li>Hip-hop: 60-100 bpm</li>
<li>Downtempo: 90-120 bpm</li>
<li>House: 115-130 bpm</li>
<li>Techno&#47;trance: 120-140 bpm</li>
<li>Dubstep: 135-145 bpm</li>
<li>Drum and bass: 160-180 bpm</li>
</ul>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # default tempo is 60 bpm
  4.times do
    play 50, attack: 0.5, release: 0.25 # attack is 0.5s and release is 0.25s
    sleep 1 # sleep for 1 second
  end

  sleep 2  # sleep for 2 seconds

  # Let's make it go faster...
  use_bpm 120  # double the bpm
  4.times do
    play 62, attack: 0.5, release: 0.25 # attack is scaled to 0.25s and release is now 0.125s
    sleep 1 # actually sleeps for 0.5 seconds
  end

  sleep 2 # sleep for 1 second

  # Let's make it go even faster...
  use_bpm 240  #  bpm is 4x original speed!
  8.times do
    play 62, attack: 0.5, release: 0.25 # attack is scaled to 0.125s and release is now 0.0625s
    sleep 1 # actually sleeps for 0.25 seconds
  end

  </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_bpm_mul">Set new tempo as a multiple of current tempo</h2>
        <code><span class="function">use_bpm_mul</span> mul <span class="arg_type">(number)</span></code>
        <p>Sets the tempo in bpm (beats per minute) as a multiplication of the current tempo. Affects all containing calls to <code>sleep</code> and all temporal synth arguments which will be scaled to match the new bpm. See also <code>use_bpm</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60   # Set the BPM to 60
  play 50
  sleep 1      # Sleeps for 1 seconds
  play 62
  sleep 2      # Sleeps for 2 seconds
  use_bpm_mul 0.5 # BPM is now (60 * 0.5) == 30
  play 50
  sleep 1           # Sleeps for 2 seconds
  play 62
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.3.0</p>
      </section>
    
      <section>
        <h2 id="use_cent_tuning">Cent tuning</h2>
        <code><span class="function">use_cent_tuning</span> cent_shift <span class="arg_type">(number)</span></code>
        <p>Uniformly tunes your music by shifting all notes played by the specified number of cents. To shift up by a cent use a cent tuning of 1. To shift down use negative numbers. One semitone consists of 100 cents.</p>
<p>See <code>with_cent_tuning</code> for setting the cent tuning value only for a specific <code>do</code>&#47;<code>end</code> block. To transpose entire semitones see <code>use_transpose</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50
use_cent_tuning 1
play 50 # Plays note 50.01</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="use_cue_logging">Enable and disable cue logging</h2>
        <code><span class="function">use_cue_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Enable or disable log messages created on cues. This does not disable the cues themselves, it just stops them from being printed to the log</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_cue_logging true # Turn on cue messages</code></pre>
          
            <pre><code>use_cue_logging false # Disable cue messages</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="use_debug">Enable and disable debug</h2>
        <code><span class="function">use_debug</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Enable or disable messages created on synth triggers. If this is set to false, the synths will be silent until debug is turned back on. Silencing debug messages can reduce output noise and also increase performance on slower platforms. See <code>with_debug</code> for setting the debug value only for a specific <code>do</code>&#47;<code>end</code> block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_debug true # Turn on debug messages</code></pre>
          
            <pre><code>use_debug false # Disable debug messages</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_merged_midi_defaults">Merge MIDI defaults</h2>
        <code><span class="function">use_merged_midi_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>midi_*</code> fns. Merges the specified values with any previous defaults, rather than replacing them</p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Note velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Velocity as a value between 0 and 1 (will be converted to a MIDI velocity between 0 and 127)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note on message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_on` regardless of value).</td>
            </tr>
          
            <caption>Options for use_merged_midi_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
midi_note_on :e1 # Sends MIDI :e1 note_on with default opts

use_midi_defaults channel: 3, port: "foo"

midi_note_on :e3 # Sends MIDI :e3 note_on to channel 3 on port "foo"

use_merged_midi_defaults channel: 1

midi_note_on :e2 # Sends MIDI :e2 note_on to channel 1 on port "foo".
                 # This is because the call to use_merged_midi_defaults overrode the
                 # channel but not the port which got merged in.</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_merged_sample_defaults">Merge new sample defaults</h2>
        <code><span class="function">use_merged_sample_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>sample</code>. Merges the specified values with any previous defaults, rather than replacing them.</p>

        
          <table>
          
            <caption>Options for use_merged_sample_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen # plays amen break with default arguments

use_merged_sample_defaults amp: 0.5, cutoff: 70

sample :loop_amen # plays amen break with an amp of 0.5, cutoff of 70 and defaults for rest of args

use_merged_sample_defaults cutoff: 90

sample :loop_amen  # plays amen break with a cutoff of 90 and and an amp of 0.5 with defaults for rest of args</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="use_merged_synth_defaults">Merge synth defaults</h2>
        <code><span class="function">use_merged_synth_defaults</span> </code>
        <p>Specify synth arg values to be used by any following call to play. Merges the specified values with any previous defaults, rather than replacing them.</p>

        
          <table>
          
            <caption>Options for use_merged_synth_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 #=> Plays note 50

use_merged_synth_defaults amp: 0.5
play 50 #=> Plays note 50 with amp 0.5

use_merged_synth_defaults cutoff: 80
play 50 #=> Plays note 50 with amp 0.5 and cutoff 80

use_merged_synth_defaults amp: 0.7
play 50 #=> Plays note 50 with amp 0.7 and cutoff 80</code></pre>
          
            <pre><code>use_synth_defaults amp: 0.5, cutoff: 80, pan: -1
use_merged_synth_defaults amp: 0.7
play 50 #=> Plays note 50 with amp 0.7, cutoff 80 and pan -1</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_midi_defaults">Use new MIDI defaults</h2>
        <code><span class="function">use_midi_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>midi_*</code> fns. Will remove and override any previous defaults.</p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Note velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Velocity as a value between 0 and 1 (will be converted to a MIDI velocity between 0 and 127)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note on message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_on` regardless of value).</td>
            </tr>
          
            <caption>Options for use_midi_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
midi_note_on :e1 # Sends MIDI :e1 note_on with default opts

use_midi_defaults channel: 3, port: "foo"

midi_note_on :e3 # Sends MIDI :e3 note_on to channel 3 on port "foo"

use_midi_defaults channel: 1

midi_note_on :e2 # Sends MIDI :e2 note_on to channel 1. Note that the port is back to the default and no longer "foo".</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_midi_logging">Enable and disable MIDI logging</h2>
        <code><span class="function">use_midi_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Enable or disable log messages created on MIDI functions. This does not disable the MIDI functions themselves, it just stops them from being printed to the log</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_midi_logging true # Turn on MIDI logging</code></pre>
          
            <pre><code>use_midi_logging false # Disable MIDI logging</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_octave">Note octave transposition</h2>
        <code><span class="function">use_octave</span> octave_shift <span class="arg_type">(number)</span></code>
        <p>Transposes your music by shifting all notes played by the specified number of octaves. To shift up by an octave use a transpose of 1. To shift down use negative numbers. See <code>with_octave</code> for setting the octave shift only for a specific <code>do</code>&#47;<code>end</code> block. For transposing the notes within the octave range see <code>use_transpose</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50
use_octave 1
play 50 # Plays note 62</code></pre>
          
            <pre><code>
# You may change the transposition multiple times:
play 62 # Plays note 62
use_octave -1
play 62 # Plays note 50
use_octave 2
play 62 # Plays note 86</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="use_osc">Set the default hostname and port number for outgoing OSC messages.</h2>
        <code><span class="function">use_osc</span> hostname <span class="arg_type">(string)</span>, port <span class="arg_type">(number)</span></code>
        <p>Sets the destination host and port that <code>osc</code> will send messages to. If no port number is specified - will default to port 4560 (Sonic Pi&#8217;s default OSC listening port).</p>
<p>OSC (Open Sound Control) is a simple way of passing messages between two separate programs on the same computer or even on different computers via a local network or even the internet. <code>use_osc</code> allows you to specify which computer (<code>hostname</code>) and program (<code>port</code>) to send messages to.</p>
<p>It is possible to send messages to the same computer by using the host name <code>"localhost"</code>.</p>
<p>This is a thread-local setting - therefore each thread (or live loop) can have their own separate <code>use_osc</code> values.</p>
<p>Note that calls to <code>osc_send</code> will ignore these values.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code> # Send a simple OSC message to another program on the same machine

use_osc "localhost", 7000  # Specify port 7000 on this machine
osc "/foo/bar"             # Send an OSC message with path "/foo/bar"
                             # and no arguments</code></pre>
          
            <pre><code> # Send an OSC message with arguments to another program on the same machine

use_osc "localhost", 7000        # Specify port 7000 on this machine
osc "/foo/bar" 1, 3.89, "baz"  # Send an OSC message with path "/foo/bar"
                                   # and three arguments:
                                   # 1) The whole number (integer) 1
                                   # 2) The fractional number (float) 3.89
                                   # 3) The string "baz"</code></pre>
          
            <pre><code> # Send an OSC message with arguments to another program on a different machine

use_osc "10.0.1.5", 7000         # Specify port 7000 on the machine with address 10.0.1.5
osc "/foo/bar" 1, 3.89, "baz"  # Send an OSC message with path "/foo/bar"
                                   # and three arguments:
                                   # 1) The whole number (integer) 1
                                   # 2) The fractional number (float) 3.89
                                   # 3) The string "baz"</code></pre>
          
            <pre><code> # use_osc only affects calls to osc until the next call to use_osc

use_osc "localhost", 7000  # Specify port 7000 on this machine
osc "/foo/bar"             # Send an OSC message to port 7000
osc "/foo/baz"             # Send another OSC message to port 7000

use_osc "localhost", 7005  # Specify port 7005 on this machine
osc "/foo/bar"             # Send an OSC message to port 7005
osc "/foo/baz"             # Send another OSC message to port 7005</code></pre>
          
            <pre><code> # threads may have their own use_osc value

use_osc "localhost", 7000  # Specify port 7000 on this machine

live_loop :foo do
  osc "/foo/bar"             # Thread inherits outside use_osc values
  sleep 1                      # and therefore sends OSC messages to port 7000
end

live_loop :bar do
  use_osc "localhost", 7005  # Override OSC hostname and port for just this
                               # thread (live loop :bar). Live loop :foo is
                               # unaffected.

  osc "/foo/bar"             # Send OSC messages to port 7005
  sleep 1
end

use_osc "localhost", 7010  # Specify port 7010
osc "/foo/baz"             # Send another OSC message to port 7010
                             # Note that neither live loops :foo or :bar
                             # are affected (their use_osc values are
                             # independent and isolated.

</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_osc_logging">Enable and disable OSC logging</h2>
        <code><span class="function">use_osc_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Enable or disable log messages created on OSC functions. This does not disable the OSC functions themselves, it just stops them from being printed to the log</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_osc_logging true # Turn on OSC logging</code></pre>
          
            <pre><code>use_osc_logging false # Disable OSC logging</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_random_seed">Set random seed generator to known seed</h2>
        <code><span class="function">use_random_seed</span> seed <span class="arg_type">(number)</span></code>
        <p>Resets the random number generator to the specified seed. All subsequently generated random numbers and randomisation functions such as <code>shuffle</code> and <code>choose</code> will use this new generator and the current generator is discarded. Use this to change the sequence of random numbers in your piece in a way that can be reproduced. Especially useful if combined with iteration. See examples.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  ## Basic usage

  use_random_seed 1 # reset random seed to 1
  puts rand # => 0.733917236328125
  use_random_seed 1 # reset random seed back to 1
  puts rand  #=> 0.733917236328125
  </code></pre>
          
            <pre><code>
  ## Generating melodies
  notes = (scale :eb3, :minor_pentatonic)  # Create a set of notes to choose from.
                                           # Scales work well for this

  with_fx :reverb do
    live_loop :repeating_melody do         # Create a live loop

      use_random_seed 300                  # Set the random seed to a known value every
                                           # time around the loop. This seed is the key
                                           # to our melody. Try changing the number to
                                           # something else. Different numbers produce
                                           # different melodies

      8.times do                           # Now iterate a number of times. The size of
                                           # the iteration will be the length of the
                                           # repeating melody.

        play notes.choose, release: 0.1    # 'Randomly' choose a note from our ring of
                                           # notes. See how this isn't actually random
                                           # but uses a reproducible method! These notes
                                           # are therefore repeated over and over...
        sleep 0.125
      end
    end
  end
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_random_source">Change how random numbers are chosen</h2>
        <code><span class="function">use_random_source</span> noise_type <span class="arg_type">(symbol)</span></code>
        <p><code>:white</code> is totally random - between 0 and 1, you can expect an even spread of values around 0.1, 0.2, 0.3 etc. This means that jumping around within the range (including large jumps) is expected.</p>
<p><code>:pink</code> is more likely to produce values in the middle of the range and less likely to produce values at the extremes. Between 0 and 1 you expect to see a concentration of values around 0.5. This can make random melodies a little bit more smooth.</p>
<p><code>:perlin</code> is a special kind of noise which produces gradients, a bit like a mountain landscape. Large jumps are much less likely and you will tend to see lots of smooth motion going either up or down</p>
<p><code>:light_pink</code> is halfway between white noise and pink noise - more random and jumpy</p>
<p><code>:dark_pink</code> is halfway between pink noise and brown noise - less jumpy with smoother slopes</p>
<p>You can see the &#8216;buckets&#8217; that the numbers between 0 and 1 fall into with the following code:</p>
<pre><code>    rand_type :white
    puts 10000.times.collect { rand.round(1) }.tally.sort
    rand_type :pink
    puts 10000.times.collect { rand.round(1) }.tally.sort
    rand_type :perlin
    puts 10000.times.collect { rand.round(1) }.tally.sort
</code></pre>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_random_source :white # use white noise as the distribution (default)
  rand_reset # reset random seed
  puts rand # => 0.75006103515625
  puts rand # => 0.733917236328125
  puts rand # => 0.464202880859375
  rand_reset # reset it again
  use_random_source :pink # use pink noise as the distribution
  puts rand # => 0.47808837890625
  puts rand # => 0.56011962890625
  rand_reset # reset it
  use_random_source :perlin # use perlin noise as the distribution
  puts rand # => 0.546478271484375
  puts rand # => 0.573150634765625

  with_random_source :white do # use white noise just for this block
    puts rand # => 0.464202880859375
  end

  puts rand # => 0.597015380859375
            # notice how the last generator (perlin) is restored</code></pre>
          
          </details>
        
        <p>Introduced in 3.3.0</p>
      </section>
    
      <section>
        <h2 id="use_real_time">Set sched ahead time to 0 for the current thread</h2>
        <code><span class="function">use_real_time</span> </code>
        <p>Set sched ahead time to 0 for the current thread. Shorthand for <code>use_sched_ahead_time 0</code>.</p>
<p>See <code>use_sched_ahead_time</code> for a version of this function which allows you to set the schedule ahead time to any arbitrary value. Note, <code>use_real_time</code> will override any value set with <code>set_sched_ahead_time!</code> for the current thread.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_real_time # Code will now produce sound without a scheduling delay.</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_sample_bpm">Sample-duration-based bpm modification</h2>
        <code><span class="function">use_sample_bpm</span> string_or_number <span class="arg_type">(sample_name_or_duration)</span></code>
        <p>Modify bpm so that sleeping for 1 will sleep for the duration of the sample.</p>

        
          <table>
          
            <tr>
              <th><code>num_beats</code></th>
              <td>The number of beats within the sample. By default this is 1.</td>
            </tr>
          
            <caption>Options for use_sample_bpm</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_sample_bpm :loop_amen  #Set bpm based on :loop_amen duration

live_loop :dnb do
  sample :bass_dnb_f
  sample :loop_amen
  sleep 1                  #`sleep`ing for 1 actually sleeps for duration of :loop_amen
end</code></pre>
          
            <pre><code>
use_sample_bpm :loop_amen, num_beats: 4  # Set bpm based on :loop_amen duration
                                         # but also specify that the sample duration
                                         # is actually 4 beats long.

live_loop :dnb do
  sample :bass_dnb_f
  sample :loop_amen
  sleep 4                  #`sleep`ing for 4 actually sleeps for duration of :loop_amen
                           # as we specified that the sample consisted of
                           # 4 beats
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="use_sample_defaults">Use new sample defaults</h2>
        <code><span class="function">use_sample_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>sample</code>. Will remove and override any previous defaults.</p>

        
          <table>
          
            <caption>Options for use_sample_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen # plays amen break with default arguments

use_sample_defaults amp: 0.5, cutoff: 70

sample :loop_amen # plays amen break with an amp of 0.5, cutoff of 70 and defaults for rest of args

use_sample_defaults cutoff: 90

sample :loop_amen  # plays amen break with a cutoff of 90 and defaults for rest of args - note that amp is no longer 0.5</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="use_sched_ahead_time">Set sched ahead time for the current thread</h2>
        <code><span class="function">use_sched_ahead_time</span> time <span class="arg_type">(number)</span></code>
        <p>Specify how many seconds ahead of time the synths should be triggered. This represents the amount of time between pressing &#8216;Run&#8217; and hearing audio. A larger time gives the system more room to work with and can reduce performance issues in playing fast sections on slower platforms. However, a larger time also increases latency between modifying code and hearing the result whilst live coding.</p>
<p>See <code>set_sched_ahead_time!</code> for a global version of this function. Note, <code>use_sched_ahead_time</code> will override any value set with <code>set_sched_ahead_time!</code> for the current thread.</p>
<p>See <code>use_real_time</code> for a simple way of setting the schedule ahead time to 0.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_sched_ahead_time 1 # Code will now run approximately 1 second ahead of audio.</code></pre>
          
            <pre><code># Each thread can have its own sched ahead time
live_loop :foo do
  use_sched_ahead_time 1
  play 70                 # Note 70 will be played with 1 second latency
  sleep 1
end

live_loop :foo do
  use_sched_ahead_time 0.5 # Note 70 will be played with 0.5 second latency
  play 82
  sleep 1
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="use_synth">Switch current synth</h2>
        <code><span class="function">use_synth</span> synth_name <span class="arg_type">(symbol)</span></code>
        <p>Switch the current synth to <code>synth_name</code>. Affects all further calls to <code>play</code>. See <code>with_synth</code> for changing the current synth only for a specific <code>do</code>&#47;<code>end</code> block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays with default synth
use_synth :mod_sine
play 50 # Plays with mod_sine synth</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_synth_defaults">Use new synth defaults</h2>
        <code><span class="function">use_synth_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>play</code>. Will remove and override any previous defaults.</p>

        
          <table>
          
            <caption>Options for use_synth_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # plays note 50 with default arguments

use_synth_defaults amp: 0.5, cutoff: 70

play 50 # plays note 50 with an amp of 0.5, cutoff of 70 and defaults for rest of args

use_synth_defaults cutoff: 90

play 50 # plays note 50 with a cutoff of 90 and defaults for rest of args - note that amp is no longer 0.5</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_timing_guarantees">Inhibit synth triggers if too late</h2>
        <code><span class="function">use_timing_guarantees</span> bool <span class="arg_type">(true_or_false)</span></code>
        <p>If set to true, synths will not trigger if it is too late. If false, some synth triggers may be late.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_timing_guarantees true

sample :loop_amen  #=> if time is behind by any margin, this will not trigger</code></pre>
          
            <pre><code>
use_timing_guarantees false

sample :loop_amen  #=> unless time is too far behind, this will trigger even when late.</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="use_transpose">Note transposition</h2>
        <code><span class="function">use_transpose</span> note_shift <span class="arg_type">(number)</span></code>
        <p>Transposes your music by shifting all notes played by the specified amount. To shift up by a semitone use a transpose of 1. To shift down use negative numbers. See <code>with_transpose</code> for setting the transpose value only for a specific <code>do</code>&#47;<code>end</code> block. To transpose entire octaves see <code>use_octave</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50
use_transpose 1
play 50 # Plays note 51</code></pre>
          
            <pre><code>
# You may change the transposition multiple times:
play 62 # Plays note 62
use_transpose -12
play 62 # Plays note 50
use_transpose 3
play 62 # Plays note 65</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="use_tuning">Use alternative tuning systems</h2>
        <code><span class="function">use_tuning</span> tuning <span class="arg_type">(symbol)</span>, fundamental_note <span class="arg_type">(symbol_or_number)</span></code>
        <p>In most music we make semitones by dividing the octave into 12 equal parts, which is known as equal temperament. However there are lots of other ways to tune the 12 notes. This method adjusts each midi note into the specified tuning system. Because the ratios between notes aren&#8217;t always equal, be careful to pick a centre note that is in the key of the music you&#8217;re making for the best sound. Currently available tunings are <code>:just</code>, <code>:pythagorean</code>, <code>:meantone</code> and the default of <code>:equal</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play :e4 # Plays note 64
use_tuning :just, :c
play :e4 # Plays note 63.8631
# transparently changes midi notes too
play 64 # Plays note 63.8631</code></pre>
          
            <pre><code>
# You may change the tuning multiple times:
play 64 # Plays note 64
use_tuning :just
play 64 # Plays note 63.8631
use_tuning :equal
play 64 # Plays note 64</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="vector">Create a vector</h2>
        <code><span class="function">vector</span> list <span class="arg_type">(array)</span></code>
        <p>Create a new immutable vector from args. Out of range indexes return nil.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>(vector 1, 2, 3)[0] #=> 1</code></pre>
          
            <pre><code>(vector 1, 2, 3)[1] #=> 2</code></pre>
          
            <pre><code>(vector 1, 2, 3)[2] #=> 3</code></pre>
          
            <pre><code>(vector 1, 2, 3)[3] #=> nil</code></pre>
          
            <pre><code>(vector 1, 2, 3)[1000] #=> nil</code></pre>
          
            <pre><code>(vector 1, 2, 3)[-1] #=> nil</code></pre>
          
            <pre><code>(vector 1, 2, 3)[-1000] #=> nil</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="version">Get current version information</h2>
        <code><span class="function">version</span> </code>
        <p>Return information representing the current version of Sonic Pi. This information may be further inspected with <code>version.major</code>, <code>version.minor</code>, <code>version.patch</code> and <code>version.dev</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts version # => Prints out the current version such as v2.0.1</code></pre>
          
            <pre><code>
  puts version.major # => Prints out the major version number such as 2</code></pre>
          
            <pre><code>
  puts version.minor # => Prints out the minor version number such as 0</code></pre>
          
            <pre><code>
  puts version.patch # => Prints out the patch level for this version such as 0</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="vt">Get virtual time</h2>
        <code><span class="function">vt</span> </code>
        <p>Get the virtual time of the current thread.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  puts vt # prints 0
   sleep 1
   puts vt # prints 1</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="wait">Wait for duration</h2>
        <code><span class="function">wait</span> beats <span class="arg_type">(number)</span></code>
        <p>Synonym for <code>sleep</code> - see <code>sleep</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_arg_bpm_scaling">Block-level enable and disable BPM scaling</h2>
        <code><span class="function">with_arg_bpm_scaling</span> </code>
        <p>Turn synth argument bpm scaling on or off for the supplied block. Note, using <code>rt</code> for args will result in incorrect times when used within this block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>use_bpm 120
play 50, release: 2   # release is actually 1 due to bpm scaling
sleep 2               # actually sleeps for 1 second
with_arg_bpm_scaling false do
  play 50, release: 2 # release is now 2
  sleep 2             # still sleeps for 1 second
end</code></pre>
          
            <pre><code>                         # Interaction with rt
use_bpm 120
play 50, release: rt(2)   # release is 2 seconds
sleep rt(2)               # sleeps for 2 seconds
with_arg_bpm_scaling false do
  play 50, release: rt(2) # ** Warning: release is NOT 2 seconds! **
  sleep rt(2)             # still sleeps for 2 seconds
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_arg_checks">Block-level enable and disable arg checks</h2>
        <code><span class="function">with_arg_checks</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Similar to <code>use_arg_checks</code> except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous arg check value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Turn on arg checking:
use_arg_checks true

play 80, cutoff: 100 # Args are checked

with_arg_checks false do
  #Arg checking is now disabled
  play 50, release: 3 # Args are not checked
  sleep 1
  play 72             # Arg is not checked
end

# Arg checking is re-enabled
play 90 # Args are checked
</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_bpm">Set the tempo for the code block</h2>
        <code><span class="function">with_bpm</span> bpm <span class="arg_type">(number)</span></code>
        <p>Sets the tempo in bpm (beats per minute) for everything in the given block. Affects all containing calls to <code>sleep</code> and all temporal synth arguments which will be scaled to match the new bpm. See also <code>use_bpm</code></p>
<p>For dance music here&#8217;s a rough guide for which BPM to aim for depending on your genre:</p>
<ul>
<li>Dub: 60-90 bpm</li>
<li>Hip-hop: 60-100 bpm</li>
<li>Downtempo: 90-120 bpm</li>
<li>House: 115-130 bpm</li>
<li>Techno&#47;trance: 120-140 bpm</li>
<li>Dubstep: 135-145 bpm</li>
<li>Drum and bass: 160-180 bpm</li>
</ul>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # default tempo is 60 bpm
  4.times do
    sample :drum_bass_hard
    sleep 1 # sleeps for 1 second
  end

  sleep 5 # sleeps for 5 seconds

  # with_bpm sets a tempo for everything between do ... end (a block)
  # Hear how it gets faster?
  with_bpm 120 do  # set bpm to be twice as fast
    4.times do
      sample :drum_bass_hard
      sleep 1 # now sleeps for 0.5 seconds
    end
  end

  sleep 5

  # bpm goes back to normal
  4.times do
    sample :drum_bass_hard
    sleep 1 # sleeps for 1 second
  end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_bpm_mul">Set new tempo as a multiple of current tempo for block</h2>
        <code><span class="function">with_bpm_mul</span> mul <span class="arg_type">(number)</span></code>
        <p>Sets the tempo in bpm (beats per minute) for everything in the given block as a multiplication of the current tempo. Affects all containing calls to <code>sleep</code> and all temporal synth arguments which will be scaled to match the new bpm. See also <code>with_bpm</code></p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_bpm 60   # Set the BPM to 60
  play 50
  sleep 1      # Sleeps for 1 second
  play 62
  sleep 2      # Sleeps for 2 seconds
  with_bpm_mul 0.5 do # BPM is now (60 * 0.5) == 30
    play 50
    sleep 1           # Sleeps for 2 seconds
    play 62
  end
  sleep 1            # BPM is now back to 60, therefore sleep is 1 second
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.3.0</p>
      </section>
    
      <section>
        <h2 id="with_cent_tuning">Block-level cent tuning</h2>
        <code><span class="function">with_cent_tuning</span> cent_shift <span class="arg_type">(number)</span></code>
        <p>Similar to <code>use_cent_tuning</code> except only applies cent shift to code within supplied <code>do</code>&#47;<code>end</code> block. Previous cent tuning value is restored after block. One semitone consists of 100 cents. To transpose entire semitones see <code>with_transpose</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_cent_tuning 1
play 50 # Plays note 50.01

with_cent_tuning 2 do
  play 50 # Plays note 50.02
end

# Original cent tuning value is restored
play 50 # Plays note 50.01
</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="with_cue_logging">Block-level enable and disable cue logging</h2>
        <code><span class="function">with_cue_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Similar to use<em>cue</em>logging except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous cue log value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Turn on debugging:
  use_cue_logging true

  cue :foo # cue message is printed to log

  with_cue_logging false do
    #Cue logging is now disabled
    cue :bar # cue *is* sent but not displayed in log
  end
  sleep 1
  # Debug is re-enabled
  cue :quux # cue is displayed in log
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
      <section>
        <h2 id="with_debug">Block-level enable and disable debug</h2>
        <code><span class="function">with_debug</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Similar to use_debug except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous debug value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Turn on debugging:
use_debug true

play 80 # Debug message is sent

with_debug false do
  #Debug is now disabled
  play 50 # Debug message is not sent
  sleep 1
  play 72 # Debug message is not sent
end

# Debug is re-enabled
play 90 # Debug message is sent
</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_fx">Use Studio FX</h2>
        <code><span class="function">with_fx</span> fx_name <span class="arg_type">(symbol)</span></code>
        <p>This applies the named effect (FX) to everything within a given <code>do</code>&#47;<code>end</code> block. Effects may take extra parameters to modify their behaviour. See FX help for parameter details.</p>
<p>For advanced control, it is also possible to modify the parameters of an effect within the body of the block. If you define the block with a single argument, the argument becomes a reference to the current effect and can be used to control its parameters (see examples).</p>

        
          <table>
          
            <tr>
              <th><code>reps</code></th>
              <td>Number of times to repeat the block in an iteration.</td>
            </tr>
          
            <tr>
              <th><code>kill_delay</code></th>
              <td>Amount of time to wait after all synths triggered by the block have completed before stopping and freeing the effect synthesiser.</td>
            </tr>
          
            <caption>Options for with_fx</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
# Basic usage
with_fx :distortion do # Use the distortion effect with default parameters
  play 50 # => plays note 50 with distortion
  sleep 1
  sample :loop_amen # => plays the loop_amen sample with distortion too
end</code></pre>
          
            <pre><code># Specify effect parameters
with_fx :level, amp: 0.3 do # Use the level effect with the amp parameter set to 0.3
  play 50
  sleep 1
  sample :loop_amen
end</code></pre>
          
            <pre><code>
# Controlling the effect parameters within the block
with_fx :reverb, mix: 0.1 do |fx|
  # here we set the reverb level quite low to start with (0.1)
  # and we can change it later by using the 'fx' reference we've set up

  play 60 # plays note 60 with a little bit of reverb
  sleep 2

  control fx, mix: 0.5 # change the parameters of the effect to add more reverb
  play 60 # again note 60 but with more reverb
  sleep 2

  control fx, mix: 1 # change the parameters of the effect to add more reverb
  play 60 # plays note 60 with loads of reverb
  sleep 2
end</code></pre>
          
            <pre><code>
# Repeat the block 16 times internally
with_fx :reverb, reps: 16 do
  play (scale :e3, :minor_pentatonic), release: 0.1
  sleep 0.125
end

# The above is a shorthand for this:
with_fx :reverb do
  16.times do
    play (scale :e3, :minor_pentatonic), release: 0.1
    sleep 0.125
  end
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_merged_midi_defaults">Block-level merge midi defaults</h2>
        <code><span class="function">with_merged_midi_defaults</span> </code>
        <p>Specify opt values to be used by any following call to the <code>midi_*</code> fns within the specified <code>do</code>&#47;<code>end</code> block. Merges the specified values with any previous midi defaults, rather than replacing them. After the <code>do</code>&#47;<code>end</code> block has completed, previous defaults (if any) are restored.</p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Note velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Velocity as a value between 0 and 1 (will be converted to a MIDI velocity between 0 and 127)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note on message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_on` regardless of value).</td>
            </tr>
          
            <caption>Options for with_merged_midi_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
midi_note_on :e1 # Sends MIDI :e1 note_on with default opts

use_midi_defaults channel: 3, port: "foo"

midi_note_on :e3 # Sends MIDI :e3 note_on to channel 3 on port "foo"

with_merged_midi_defaults channel: 1 do

  midi_note_on :e2 # Sends MIDI :e2 note_on to channel 1 on port "foo".
                   # This is because the call to use_merged_midi_defaults overrode the
                   # channel but not the port which got merged in.
end

midi_note_on :e2 # Sends MIDI :e2 note_on to channel 3 on port "foo".
                 # This is because the previous defaults were restored after
                 # the call to with_merged_midi_defaults.
</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_merged_sample_defaults">Block-level use merged sample defaults</h2>
        <code><span class="function">with_merged_sample_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>sample</code> within the <code>do</code>&#47;<code>end</code> block.  Merges the specified values with any previous sample defaults, rather than replacing them. After the <code>do</code>&#47;<code>end</code> block has completed, the previous sampled defaults (if any) are restored.</p>

        
          <table>
          
            <caption>Options for with_merged_sample_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen # plays amen break with default arguments

use_merged_sample_defaults amp: 0.5, cutoff: 70

sample :loop_amen # plays amen break with an amp of 0.5, cutoff of 70 and defaults for rest of args

with_merged_sample_defaults cutoff: 90 do
  sample :loop_amen  # plays amen break with a cutoff of 90 and amp of 0.5
end

sample :loop_amen  # plays amen break with a cutoff of 70 and amp is 0.5 again as the previous defaults are restored.</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="with_merged_synth_defaults">Block-level merge synth defaults</h2>
        <code><span class="function">with_merged_synth_defaults</span> </code>
        <p>Specify synth arg values to be used by any following call to play within the specified <code>do</code>&#47;<code>end</code> block. Merges the specified values with any previous synth defaults, rather than replacing them. After the <code>do</code>&#47;<code>end</code> block has completed, previous defaults (if any) are restored.</p>

        
          <table>
          
            <caption>Options for with_merged_synth_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
with_merged_synth_defaults amp: 0.5, pan: 1 do
  play 50 # => plays note 50 with amp 0.5 and pan 1
end</code></pre>
          
            <pre><code>play 50 #=> plays note 50
with_merged_synth_defaults amp: 0.5 do
  play 50 #=> plays note 50 with amp 0.5

  with_merged_synth_defaults pan: -1 do
    with_merged_synth_defaults amp: 0.7 do
      play 50 #=> plays note 50 with amp 0.7 and pan -1
    end
  end
  play 50 #=> plays note 50 with amp 0.5
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_midi_defaults">Block-level use new MIDI defaults</h2>
        <code><span class="function">with_midi_defaults</span> </code>
        <p>Specify new default values to be used by all calls to <code>midi_*</code> fns within the <code>do</code>&#47;<code>end</code> block. After the <code>do</code>&#47;<code>end</code> block has completed the previous MIDI defaults (if any) are restored.</p>

        
          <table>
          
            <tr>
              <th><code>channel</code></th>
              <td>MIDI channel(s) to send event on</td>
            </tr>
          
            <tr>
              <th><code>port</code></th>
              <td>MIDI port(s) to send to</td>
            </tr>
          
            <tr>
              <th><code>velocity</code></th>
              <td>Note velocity as a MIDI number.</td>
            </tr>
          
            <tr>
              <th><code>vel_f</code></th>
              <td>Velocity as a value between 0 and 1 (will be converted to a MIDI velocity between 0 and 127)</td>
            </tr>
          
            <tr>
              <th><code>on</code></th>
              <td>If specified and false/nil/0 will stop the midi note on message from being sent out. (Ensures all opts are evaluated in this call to `midi_note_on` regardless of value).</td>
            </tr>
          
            <caption>Options for with_midi_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
midi_note_on :e1 # Sends MIDI :e1 note on with default opts

with_midi_defaults channel: 3, port: "foo" do
  midi_note_on :e3 # Sends MIDI :e3 note on to channel 3 on port "foo"
end

use_midi_defaults channel: 1   # this will be overridden by the following

with_midi_defaults channel: 5 do
  midi_note_on :e2 # Sends MIDI :e2 note on to channel 5.
                   # Note that the port is back to the default
end

  midi_note_on :e4 # Sends MIDI :e4 note on to channel 1
                   # Note that the call to use_midi_defaults is now honoured.</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_midi_logging">Block-level enable and disable MIDI logging</h2>
        <code><span class="function">with_midi_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Similar to use<em>midi</em>logging except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous MIDI log value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Turn on MIDI logging:
  use_midi_logging true

  midi :e1 #  message is printed to log

  with_midi_logging false do
    #MIDI logging is now disabled
    midi :f2 # MIDI message *is* sent but not displayed in log
  end
  sleep 1
  # Debug is re-enabled
  midi :G3 # message is displayed in log
  </code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_octave">Block level octave transposition</h2>
        <code><span class="function">with_octave</span> octave_shift <span class="arg_type">(number)</span></code>
        <p>Transposes your music by shifting all notes played by the specified number of octaves within the specified block. To shift up by an octave use a transpose of 1. To shift down use negative numbers. For transposing the notes within the octave range see <code>with_transpose</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays note 50
sleep 1
with_octave 1 do
 play 50 # Plays note 62
end
sleep 1
play 50 # Plays note 50</code></pre>
          
          </details>
        
        <p>Introduced in 2.9.0</p>
      </section>
    
      <section>
        <h2 id="with_osc">Block-level setting for the default hostname and port number of outgoing OSC messages.</h2>
        <code><span class="function">with_osc</span> hostname <span class="arg_type">(string)</span>, port <span class="arg_type">(number)</span></code>
        <p>Sets the destination host and port that <code>osc</code> will send messages to for the given do&#47;end block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_osc "localhost", 7000  # Specify port 7000
osc "/foo/baz"             # Send an OSC message to port 7000

with_osc "localhost", 7010 do # set hostname and port for the duration
                                # of this do/end block
   osc "/foo/baz"             # Send an OSC message to port 7010
end

osc "/foo/baz"             # Send an OSC message to port 7000
                             # as old setting is restored outside
                             # do/end block</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_osc_logging">Block-level enable and disable OSC logging</h2>
        <code><span class="function">with_osc_logging</span> true_or_false <span class="arg_type">(boolean)</span></code>
        <p>Similar to use<em>osc</em>logging except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous OSC log value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  # Turn on OSC logging:
  use_osc_logging true

  osc "/foo" #  message is printed to log

  with_osc_logging false do
    #OSC logging is now disabled
    osc "/foo" # OSC message *is* sent but not displayed in log
  end
  sleep 1
  # Debug is re-enabled
  osc "/foo" # message is displayed in log
  </code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_random_seed">Specify random seed for code block</h2>
        <code><span class="function">with_random_seed</span> seed <span class="arg_type">(number)</span></code>
        <p>Resets the random number generator to the specified seed for the specified code block. All generated random numbers and randomisation functions such as <code>shuffle</code> and <code>choose</code> within the code block will use this new generator. Once the code block has completed, the original generator is restored and the code block generator is discarded. Use this to change the sequence of random numbers in your piece in a way that can be reproduced. Especially useful if combined with iteration. See examples.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_random_seed 1 # reset random seed to 1
  puts rand # => 0.733917236328125
  puts rand  #=> 0.464202880859375
  use_random_seed 1 # reset it back to 1
  puts rand # => 0.733917236328125
  with_random_seed 1 do # reset seed back to 1 just for this block
    puts rand # => 0.733917236328125
    puts rand #=> 0.464202880859375
  end
  puts rand # => 0.464202880859375
            # notice how the original generator is restored</code></pre>
          
            <pre><code>
  ## Generating melodies
  notes = (scale :eb3, :minor_pentatonic, num_octaves: 2)  # Create a set of notes to choose from.
                                           # Scales work well for this

  with_fx :reverb do
    live_loop :repeating_melody do         # Create a live loop

      with_random_seed 300 do              # Set the random seed to a known value every
                                           # time around the loop. This seed is the key
                                           # to our melody. Try changing the number to
                                           # something else. Different numbers produce
                                           # different melodies

        8.times do                         # Now iterate a number of times. The size of
                                           # the iteration will be the length of the
                                           # repeating melody.

          play notes.choose, release: 0.1  # 'Randomly' choose a note from our ring of
                                           # notes. See how this isn't actually random
                                           # but uses a reproducible method! These notes
                                           # are therefore repeated over and over...
          sleep 0.125
        end
      end

      play notes.choose, amp: 1.5, release: 0.5 # Note that this line is outside of
                                                # the with_random_seed block and therefore
                                                # the randomisation never gets reset and this
                                                # part of the melody never repeats.
    end
  end
  </code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_random_source">Specify random distribution for code block</h2>
        <code><span class="function">with_random_source</span> noise_type <span class="arg_type">(symbol)</span></code>
        <p>Resets the random number generator to the specified noise type for the specified code block. All generated random numbers and randomisation functions such as <code>shuffle</code> and <code>choose</code> within the code block will use this new generator. Once the code block has completed, the original generator is restored and the code block generator is discarded. Use this to change the sequence of random numbers in your piece in a way that can be reproduced. Especially useful if combined with iteration. See examples.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
  use_random_source :white # use white noise as the distribution (default)
  rand_reset # reset random seed
  puts rand # => 0.75006103515625
  puts rand # => 0.733917236328125
  puts rand # => 0.464202880859375
  rand_reset # reset it again
  use_random_source :pink # use pink noise as the distribution
  puts rand # => 0.47808837890625
  puts rand # => 0.56011962890625
  rand_reset # reset it
  use_random_source :perlin # use perlin noise as the distribution
  puts rand # => 0.546478271484375
  puts rand # => 0.573150634765625

  with_random_source :white do # use white noise just for this block
    puts rand # => 0.464202880859375
  end

  puts rand # => 0.597015380859375
            # notice how the last generator (perlin) is restored</code></pre>
          
          </details>
        
        <p>Introduced in 3.3.0</p>
      </section>
    
      <section>
        <h2 id="with_real_time">Sets sched ahead time to 0 within the block for the current thread</h2>
        <code><span class="function">with_real_time</span> </code>
        <p>Sets sched ahead time to 0 within the block for the current thread. Shorthand for <code>with_sched_ahead_time 0</code>.</p>
<p>See <code>with_sched_ahead_time</code> for a version of this function which allows you to set the schedule ahead time to any arbitrary value. Note, <code>with_real_time</code> will override any value set with <code>set_sched_ahead_time!</code> for the current thread.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
with_real_time do
  play 70  # Sound will happen without a scheduling delay.
end

play 70  # Sound will happen with the default latency (0.5s).</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_sample_bpm">Block-scoped sample-duration-based bpm modification</h2>
        <code><span class="function">with_sample_bpm</span> string_or_number <span class="arg_type">(sample_name_or_duration)</span></code>
        <p>Block-scoped modification of bpm so that sleeping for 1 will sleep for the duration of the sample.</p>

        
          <table>
          
            <tr>
              <th><code>num_beats</code></th>
              <td>The number of beats within the sample. By default this is 1.</td>
            </tr>
          
            <caption>Options for with_sample_bpm</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
live_loop :dnb do
  with_sample_bpm :loop_amen do #Set bpm based on :loop_amen duration
    sample :bass_dnb_f
    sample :loop_amen
    sleep 1                     #`sleep`ing for 1 sleeps for duration of :loop_amen
  end
end</code></pre>
          
            <pre><code>live_loop :dnb do
  with_sample_bpm :loop_amen, num_beats: 4 do # Set bpm based on :loop_amen duration
                                              # but also specify that the sample duration
                                              # is actually 4 beats long.
    sample :bass_dnb_f
    sample :loop_amen
    sleep 4                     #`sleep`ing for 4 sleeps for duration of :loop_amen
                                # as we specified that the sample consisted of
                                # 4 beats
  end
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.1.0</p>
      </section>
    
      <section>
        <h2 id="with_sample_defaults">Block-level use new sample defaults</h2>
        <code><span class="function">with_sample_defaults</span> </code>
        <p>Specify new default values to be used by all subsequent calls to <code>sample</code> within the <code>do</code>&#47;<code>end</code> block. After the <code>do</code>&#47;<code>end</code> block has completed, the previous sampled defaults (if any) are restored. For the contents of the block, will remove and override any previous defaults.</p>

        
          <table>
          
            <caption>Options for with_sample_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
sample :loop_amen # plays amen break with default arguments

use_sample_defaults amp: 0.5, cutoff: 70

sample :loop_amen # plays amen break with an amp of 0.5, cutoff of 70 and defaults for rest of args

with_sample_defaults cutoff: 90 do
  sample :loop_amen  # plays amen break with a cutoff of 90 and defaults for rest of args - note that amp is no longer 0.5
end

sample :loop_amen  # plays amen break with a cutoff of 70 and amp is 0.5 again as the previous defaults are restored.</code></pre>
          
          </details>
        
        <p>Introduced in 2.5.0</p>
      </section>
    
      <section>
        <h2 id="with_sched_ahead_time">Block-level set sched ahead time for the current thread</h2>
        <code><span class="function">with_sched_ahead_time</span> time <span class="arg_type">(number)</span></code>
        <p>Specify how many seconds ahead of time the synths should be triggered for the block. See <code>use_sched_ahead_time</code> for further information.</p>
<p>See <code>set_sched_ahead_time!</code> for a global version of this function. Note, <code>with_sched_ahead_time</code> will override any value set with <code>set_sched_ahead_time!</code> for the given block within the current thread.</p>
<p>See <code>with_real_time</code> for a simple way of setting the schedule ahead time to 0.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
with_sched_ahead_time 1 do
  play 70  # Sound will happen with a latency of 1
end

play 70  # Sound will happen with the default latency (0.5s)</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_swing">Add swing to successive calls to do/end block</h2>
        <code><span class="function">with_swing</span> shift <span class="arg_type">(beats)</span>, pulse <span class="arg_type">(number)</span>, tick <span class="arg_type">(symbol)</span>, offset <span class="arg_type">(number)</span></code>
        <p>Runs block within a <code>time_warp</code> except for once every <code>pulse</code> consecutive runs (defaulting to 4). When used for rhythmical purposes this results in one in every <code>pulse</code> calls of the block being &#8216;on beat&#8217; and the rest shifted forward or backwards in time by <code>shift</code> beats.</p>

        
          <table>
          
            <tr>
              <th><code>shift</code></th>
              <td>How much time to delay/forward the block. Greater values produce more emphasised swing. Defaults to 0.1 beats.</td>
            </tr>
          
            <tr>
              <th><code>pulse</code></th>
              <td>How often to apply the swing. Defaults to 4.</td>
            </tr>
          
            <tr>
              <th><code>tick</code></th>
              <td>A key for the tick with which to count pulses. Override this if you have more than one `with_swing` block in your `live_loop` or thread to stop them interfering with each other.</td>
            </tr>
          
            <tr>
              <th><code>offset</code></th>
              <td>Count offset - before modding the count with the pulse size - integer offset to add to the result of calling `tick` with the specified tick key (via the `tick:` opt)</td>
            </tr>
          
            <caption>Options for with_swing</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
live_loop :foo do
  with_swing 0.1 do
    sample :elec_beep      # plays the :elec_beep sample late except on the 1st beat of every 4
  end
  sleep 0.25
end</code></pre>
          
            <pre><code>
live_loop :foo do
  with_swing -0.1 do
    sample :elec_beep      # plays the :elec_beep sample slightly early
  end                      # on the 1st beat of every 4
  sleep 0.25
end</code></pre>
          
            <pre><code>
live_loop :foo do
  with_swing -0.1, pulse: 8 do
    sample :elec_beep      # plays the :elec_beep sample slightly early
  end                      #  on the 1st beat of every 8
  sleep 0.25
end</code></pre>
          
            <pre><code>
# Use unique tick names if you plan on using with_swing
# more than once in any given live_loop or thread.
live_loop :foo do
  with_swing 0.14, tick: :a do
    sample :elec_beep      # plays the :elec_beep sample slightly late
  end                      #  on the 1st beat of every 4

  with_swing -0.1, tick: :b do
    sample :elec_beep, rate: 2  # plays the :elec_beep sample at double rate
  end                           #  slightly early except  on the 1st beat of every 4
  sleep 0.25
end</code></pre>
          
            <pre><code>
live_loop :foo do
  with_swing 0.1 do
    cue :tick              # send out cue messages with swing timing
  end
  sleep 0.25
end

live_loop :bar do
  sync :tick
  sample :elec_beep       # sync on the swing cue messages to bring the swing into
                          # another live loop (sync will match the timing and clock of
                          # the sending live loop)
end</code></pre>
          
            <pre><code>
live_loop :foo do
  with_swing 0.1, offset: 2 do
    sample :elec_beep      # plays the :elec_beep sample slightly late
  end                      # on the the 3rd beat of every 4
  sleep 0.25
end</code></pre>
          
            <pre><code>
live_loop :foo do
  with_swing 0.1, pulse: 2, offset: 1 do
    sample :elec_beep      # plays the :elec_beep sample slightly late
  end                      # on the 2nd beat of every 2
  sleep 0.25
end</code></pre>
          
          </details>
        
        <p>Introduced in 3.0.0</p>
      </section>
    
      <section>
        <h2 id="with_synth">Block-level synth switching</h2>
        <code><span class="function">with_synth</span> synth_name <span class="arg_type">(symbol)</span></code>
        <p>Switch the current synth to <code>synth_name</code> but only for the duration of the <code>do</code>&#47;<code>end</code> block. After the <code>do</code>&#47;<code>end</code> block has completed, the previous synth is restored.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # Plays with default synth
sleep 2
use_synth :supersaw
play 50 # Plays with supersaw synth
sleep 2
with_synth :saw_beep do
  play 50 # Plays with saw_beep synth
end
sleep 2
# Previous synth is restored
play 50 # Plays with supersaw synth</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_synth_defaults">Block-level use new synth defaults</h2>
        <code><span class="function">with_synth_defaults</span> </code>
        <p>Specify new default values to be used by all calls to <code>play</code> within the <code>do</code>&#47;<code>end</code> block. After the <code>do</code>&#47;<code>end</code> block has completed the previous synth defaults (if any) are restored.</p>

        
          <table>
          
            <caption>Options for with_synth_defaults</caption>
          </table>
        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
play 50 # plays note 50 with default arguments

use_synth_defaults amp: 0.5, pan: -1

play 50 # plays note 50 with an amp of 0.5, pan of -1 and defaults for rest of args

with_synth_defaults amp: 0.6, cutoff: 80 do
  play 50 # plays note 50 with an amp of 0.6, cutoff of 80 and defaults for rest of args (including pan)
end

play 60 # plays note 60 with an amp of 0.5, pan of -1 and defaults for rest of args</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_timing_guarantees">Block-scoped inhibition of synth triggers if too late</h2>
        <code><span class="function">with_timing_guarantees</span> bool <span class="arg_type">(true_or_false)</span></code>
        <p>For the given block, if set to true, synths will not trigger if it is too late. If false, some synth triggers may be late. After the block has completed, the previous value is restored. </p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
with_timing_guarantees true do
  sample :loop_amen  #=> if time is behind by any margin, this will not trigger
end</code></pre>
          
            <pre><code>
with_timing_guarantees false do
  sample :loop_amen  #=> unless time is too far behind, this will trigger even when late.
end</code></pre>
          
          </details>
        
        <p>Introduced in 2.10.0</p>
      </section>
    
      <section>
        <h2 id="with_transpose">Block-level note transposition</h2>
        <code><span class="function">with_transpose</span> note_shift <span class="arg_type">(number)</span></code>
        <p>Similar to use_transpose except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous transpose value is restored after block. To transpose entire octaves see <code>with_octave</code>.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_transpose 3
play 62 # Plays note 65

with_transpose 12 do
  play 50 # Plays note 62
  sleep 1
  play 72 # Plays note 84
end

# Original transpose value is restored
play 80 # Plays note 83
</code></pre>
          
          </details>
        
        <p>Introduced in 2.0.0</p>
      </section>
    
      <section>
        <h2 id="with_tuning">Block-level tuning modification</h2>
        <code><span class="function">with_tuning</span> tuning <span class="arg_type">(symbol)</span>, fundamental_note <span class="arg_type">(symbol_or_number)</span></code>
        <p>Similar to use_tuning except only applies to code within supplied <code>do</code>&#47;<code>end</code> block. Previous tuning value is restored after block.</p>

        
        
          <details>
            <summary>Examples</summary>
          
            <pre><code>
use_tuning :equal, :c
play :e4 # Plays note 64
with_tuning :just, :c do
  play :e4 # Plays note 63.8631
  sleep 1
  play :c4 # Plays note 60
end
# Original tuning value is restored
play :e4 # Plays note 64</code></pre>
          
          </details>
        
        <p>Introduced in 2.6.0</p>
      </section>
    
	</body>
</html>
